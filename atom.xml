<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>Just Some Ramblings</title>
    <link rel="self" type="application/atom+xml" href="https://ghost.livexia.xyz/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2024-12-25T00:00:00+00:00</updated>
    <id>https://ghost.livexia.xyz/atom.xml</id>
    <entry xml:lang="en">
        <title>Advent of Code 2024</title>
        <published>2024-12-25T00:00:00+00:00</published>
        <updated>2024-12-25T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/adventofcode2024/"/>
        <id>https://ghost.livexia.xyz/adventofcode2024/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/adventofcode2024/">&lt;ul&gt;
&lt;li&gt;https:&#x2F;&#x2F;adventofcode.com&#x2F;&lt;&#x2F;li&gt;
&lt;li&gt;https:&#x2F;&#x2F;github.com&#x2F;livexia&#x2F;advent-of-code-2024&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;yi-chu-suo-you-de-input-txt&quot;&gt;移除所有的 input.txt&lt;&#x2F;h2&gt;
&lt;p&gt;根据社区和作者的规定，其实参与者并不允许上传 input 到公共仓库，我之前一直没有意识到这个问题，所以为了可确定性所以一直上传输入，今天意识到这个问题，所以删除了所有的输入，也许还有少量残留（不太可能）。&lt;&#x2F;p&gt;
&lt;p&gt;使用的方法来自社区：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;old.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;wiki&#x2F;faqs&#x2F;copyright&#x2F;inputs&quot;&gt;Puzzle Inputs&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;git filter-repo --path-glob &quot;2022&#x2F;*&#x2F;input&quot; --invert-paths --force was the nice way to fix this for me. Edit the glob to match how you had inputs saved&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;需要重新配置仓库远端地址，同时需要强制推送代码，以及 github 可能存在短暂的更新延时，以及可能的云端缓存，不是很确定，以及会丢失本地的 input 文件，也算是我的教训吧，下次记得要检查类似的问题。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;old.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;18ehed6&#x2F;re_not_sharing_inputs_psa_deleting_and_committing&#x2F;kcroxma&#x2F;&quot;&gt;fragger&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;newren&#x2F;git-filter-repo&quot;&gt;newren&#x2F;git-filter-repo&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;day-1&quot;&gt;Day 1&lt;&#x2F;h2&gt;
&lt;p&gt;太久没编程，还好大部分的记忆还在，有一点点手生，但是没什么问题。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;day-2&quot;&gt;Day 2&lt;&#x2F;h2&gt;
&lt;p&gt;第二天的题目并不困难，第一部分很简单，前后比较即可，第二部分虽然想有更好的方法，但是思路并不那么清晰，最后就暴力解决了，因为输入的问题，所以效率也不差。输入的数据每行的长度也不大，同时数据每行大都是有序的，而且也只考虑移除一个元素后数列的变化情况，所以实际上问题的求解空间就不大。如果输入数列趋于无序，同时需要计算删除最少元素以保证数列排序要求，那么求解空间就变得很大了，暴力实现也就不怎么现实了。在社区上简单浏览了一下也没有看见贴别好的方法，也许还要再等等吧，就这样了。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;day-3-zheng-ze-chu-li-shu-ru&quot;&gt;Day 3 （正则处理输入）&lt;&#x2F;h2&gt;
&lt;p&gt;第三天的题目依旧不困难，但是在输入的处理上稍有麻烦，太久没编程都忘了还能用 regex 处理输入了，刚开始想要自己实现输入的匹配，但是没能下定决定，然后浪费了不少时间。虽然对 regex 并不是很熟练，但是基础还是有的，所以写个简单的表达式并没有问题，利用&lt;a href=&quot;https:&#x2F;&#x2F;regex101.com&#x2F;&quot;&gt;网站&lt;&#x2F;a&gt;简单的测试，再根据 &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;regex&#x2F;latest&#x2F;regex&#x2F;index.html&quot;&gt;regex&lt;&#x2F;a&gt; 的文档很容易的就实现了输入的解析和处理。对输入的计算其实很容易，再处理完输入之后很容易就可以得出结果。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;day-4&quot;&gt;Day 4&lt;&#x2F;h2&gt;
&lt;p&gt;今天的题目真的很简单，但是我却花了太多的时间，第一部分很快就有解决方法了，以为会出现的深度搜索也不需要，最后我的示例答案和正确答案差 1 ，我就知道有个边界错误了，但是光看是看不出来的，最后在纸上手动计算了一下，对比了差异，果然在边界上判断错误了。可能是小瞧了难度，所以写代码的时候有点过于花样多了，导致要从代码调试输出更加困难，而我又不想改，所以浪费了很多的时间。第一部分需要在水平、垂直和对角方向上搜索单词，注意无论是什么方向，单词都是在一行的，这极大的降低了问题难度。从一个位置出发，实际上需要匹配八个方向的所有可能，因为单词可以是翻转的，所以我并没有匹配八个方向，而是判断当前位置是和单词的第一个字符还是最后一个字符相同，如果和最后一个字符相同，那就翻转单词，这样在一个位置其实最多只需要寻找四个方向。第二个部分更加简单，只需要找到所有的字符 A 即可，判断以 A 为中心的，两个对角线的单词是否是 MAS 或 SAM 即可，只有都满足的情况才是正解，也就是说对于一个字符 A 其实只存在一个可能性。第一部分中无论是对于字符 X 还是 S ，其实都存在四种可能（我的解法）。吸取教训，不要求快，求快反而更慢了。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;day-5&quot;&gt;Day 5&lt;&#x2F;h2&gt;
&lt;p&gt;今天的题目依旧不难，但我还是太不熟练了，在很多的地方有的思路并不是最佳的，这些思路可能一年前对我来说是很自然的。题目给出的输入是一组排序规则，其中确定部分元素的前后关系，还有的一部分输入是可能有序的序列，第一部分要寻找其中已经按照排序规则有序的序列，取得中间元素的值。第二部分则要对未排序的序列进行排序，取得排序后序列中间元素的值。我的思路很直接明了，就是搜索，我先把输入的序列规则进行了处理，确定在一个元素之后的所有元素（对输入规则进行拓扑排序）。题目要求的是，需要排除序列中没有元素的排序规则，所以实际上对每一个序列都需要处理输入规则，也就是说对不同的序列，其实有不同的排序规则，因为如果不针对输入序列进行再次处理，会发现输入规则的拓扑排序存在环，那么所有的排序都是可行的，但其实存导致环的规则并不会同时出现在一个序列中，所以对于任一序列，规则是不存在环的（因为排除了）。按照我的方法，处理排序规则就已经有不少的复杂度了。然后在第二部分，需要对未排序的序列进行排序，我使用的排序算法也不是最好的，遍历比较前后元素，如果不符合排序规则就交换两个元素，然后回溯比较前一对是否有序（当前两个交换会影响前一对的比较结果）。&lt;&#x2F;p&gt;
&lt;p&gt;其实除了没有使用更好的排序算法，我的方法没啥问题，对需要的规则进行拓扑排序，但是在阅读社区的解法和讨论之后，我意识到对于序列中任何两个相邻的元素，必然存在规则确定二者的大小关系，即如果存在 &lt;code&gt;a|b&lt;&#x2F;code&gt; 和 &lt;code&gt;b|c&lt;&#x2F;code&gt; 两条规则，那么规则 &lt;code&gt;a|c&lt;&#x2F;code&gt; 必然存在，所以对于某一输入序列而言，实际上一定存在对应的规则，也就是说对于某一输入而言，其实完全不需要进行拓扑排序，即可能发生的比较都已经在需要的规则中确定好了，只需要取用即可。在对自己爹输入测试之后果然如此，理所当然的这个方法比我自己的方法要快很多。&lt;&#x2F;p&gt;
&lt;p&gt;参考：&lt;a href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;1h73c98&#x2F;2024_day_5_rules_are_not_a_dag&#x2F;?utm_source=share&amp;amp;utm_medium=web3x&amp;amp;utm_name=web3xcss&amp;amp;utm_term=1&amp;amp;utm_content=share_button&quot;&gt;[2024 Day 5]Rules are not a DAG &lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;day-6-guan-zhu-xi-jie&quot;&gt;Day 6 （关注细节）&lt;&#x2F;h2&gt;
&lt;p&gt;今天的题继续不难，提交的成绩比前几天好太多了，但是在完成之后需要进行优化时依旧卡壳。这类型的题目已经是 AOC 的传统艺能了，所以在输入处理和抽象建立上并没有问题，第一部分就是按照提议要求模拟行走就行，很简单。第二部分很明显复杂了一些，但是本质上还是做 N 次第一部分的内容，所以实际上理解也不困难，并没有很直接的算法能够加快这个过程。很自然的，我尝试用暴力法，逐一替换给出地图中的路径为障碍，然后一一测试是否存在环路，环路判断只需要用 &lt;code&gt;HashSet&lt;&#x2F;code&gt; 保存守卫的位置和前进方向，然后当再次遇到状态一模一样的守卫时，就发现了环。理所当然的这个方法的效率并不好。因为每次守卫巡逻，最多只允许替换一次路径为障碍，那么实际上对那些守卫本就不会走到的路径就没有必要替换为障碍进行测试，所以可以先把不替换时守卫巡逻的所以位置进行记录，然后只需要对这些位置进行替换，再测试环即可，这可以大量降低运行时间。那么能不能再进一步加快运行效率呢？我就是卡在这个问题上了。在前面两种方法中，每次替换并检测环的时候，守卫都是从起始位置行走的，那存在大量的重叠运算，假如被替换的位置处于守卫巡逻路径的最后部分并且相邻，那么理论上可以对部分的运算进行复用。所以我就有了这样的思路，守卫在巡逻路径上某一个位置的时候，他存在两种选择，第一就是按照未替换的巡逻路径前进一个位置，或者把路径下一个位置替换为障碍，即守卫进行转向。对于巡逻路径上的每一个位置都存在两种选择，所以对于长度为 N 的巡逻路径未替换的路径需要计算一次，除去初始位置其余位置都需要计算一次。如果路径不存在交叉，也就是最理想的情况，那么总共需要移动的次数就是 N + (N - 1) + (N + 2) + ... + 1，这个结论不完全正确，因为当一个位置被替换后，其实路径的长度也会变化。刚开始我一直没有考虑可能的路径交叉情况，正是在这个情况的判断上，我无法取得正确的结果。&lt;&#x2F;p&gt;
&lt;p&gt;考虑位置 A 处于巡逻路径的某个位置，而且路径会多次经过 A ，如果在首次前进到 A 处，测试将 A 替换为路障是否存在环路。如果不存在那么按照原本的巡逻路径继续前进再次到达 A 位置时是否需再次测试？这个情况下是不需要测试的，因为如果进行替换，那么首先到达当前状态的前提就不存在了，替换并不是在前进到某个时刻随意选择替换的，而是在守卫开始走的时候就进行替换的。回到如果 A 存在回路的情况，那么按照原本路径再次到达 A 时同样的也不需要进行测试，因为替换 A 已经验证是存在回路的。&lt;&#x2F;p&gt;
&lt;p&gt;按照这个思路实现的代码结果依旧不对，相比于正解更少的位置在替换后能使得守卫巡逻路径为环路，也就是存在部分环路没有被成功的检测，也许是环路检测部分的代码有问题。考虑边界情况，起始和路径上的其他位置没差别，因为替换的是下一个位置的，路径最后一个位置时，下一个位置不在输入范围内，所以也就不存在两种情况。在写下这段思考之后，仔细研究发现在判断交叉位置的部分是存在错误的，调整之后这个方法毫无问题。&lt;&#x2F;p&gt;
&lt;p&gt;代码在 release 编译下从最初的 8s 到中间的 2s 到现在的 500ms ，代码效率提升明显，但是仍旧不快，因为大量使用了 &lt;code&gt;HashSet&lt;&#x2F;code&gt; ，在火焰图中也可以发现 Hash 的相关操作占据了大部分的运行时，这个部分依旧可以优化。需要哈希的主要数据类型是两个 &lt;code&gt;usize&lt;&#x2F;code&gt; 构成的 &lt;code&gt;tuple &lt;&#x2F;code&gt;和一个 &lt;code&gt;enum&lt;&#x2F;code&gt; ，理论上的哈希操作并不困难。观察火焰图可以发现存在大量的 &lt;code&gt;rehash&lt;&#x2F;code&gt; ，就是说存在大量哈希重新计算的情况，大概率是 &lt;code&gt;HashSet&lt;&#x2F;code&gt; 的容量增长导致的，所以在新建 &lt;code&gt;HashSet&lt;&#x2F;code&gt; 的时候可以提前分配一个较大的空间，这样操作之后运行时间减少一半，同样的 &lt;code&gt;rehash&lt;&#x2F;code&gt; 在火焰图中也没有多少。当然这样的性能提升依旧有限，因为还是存在大量的 &lt;code&gt;insert&lt;&#x2F;code&gt; 操作，也许可以换第三方的哈希库，但是也许可以用完全不同的方法。&lt;&#x2F;p&gt;
&lt;p&gt;在某一个位置，守卫最多存在四种前进方向，也就是说某一个位置最多存在四种状态，那么就可以用一个三维数组存储这些，直接利用数组替换哈希，测试发现数组比哈希更慢，这也可以理解，因为数组需要更大的空间，哈希其实还是只用了较少的空间。因为输入的大小为 130x130 理论上可以用大小为 &lt;code&gt;[[u64; 43]; 130]&lt;&#x2F;code&gt; 的 array 对应输入二维矩阵每个位置的状态，同样只需要四个这样的 array 对应守卫在每一个位置可能有的四种状态。通过位运算，可以将每个坐标对应到这个 array 中 u64 的一个 bit 上，这也是 AOC 中经常出现的优化。我在今天的题目上已经花了很多的时间，就随它去。&lt;&#x2F;p&gt;
&lt;p&gt;参考了 Reddit 的&lt;a href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;1h7vpqi&#x2F;comment&#x2F;m0pcrrh&#x2F;?utm_source=share&amp;amp;utm_medium=web3x&amp;amp;utm_name=web3xcss&amp;amp;utm_term=1&amp;amp;utm_content=share_button&quot;&gt;评论&lt;&#x2F;a&gt; 和&lt;a href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;1h8g6za&#x2F;2024_day_6_part_2_various_optimization_tricks&#x2F;&quot;&gt;帖子&lt;&#x2F;a&gt; 我意识到在环检测的时候，只需要保存在守卫发生转向时的状态即可，如果成环那么守卫一定会走过每个角落多次，这可以减少需要保存和检查的状态值。这个优化是显著的，在 debug 编译下，运行时间降低到了 300ms ，release 下则降低到了 70ms。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;day-7&quot;&gt;Day 7&lt;&#x2F;h2&gt;
&lt;p&gt;也许是最简单的一天，这让我担心明后天的题目了，没有什么特别的花样，老老实实的暴力递归解决，清晰明了，看社区貌似也没更好的方法。有一个 rust 的语法糖（？），可以用 &lt;code&gt;checked_ilog10&lt;&#x2F;code&gt; 确定一个数的十进制长度。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;day-8&quot;&gt;Day 8&lt;&#x2F;h2&gt;
&lt;p&gt;题目在描述上有些含糊不清，和前后矛盾，理论上一条直线上的三个点，分别为 A，B 和 C，其中 A 和 C 的距离刚好是 B 和 C 的距离的一半或者一倍，A 和 B 位置确定，那么满足这个条件的点 C 应该有四种可能，题目却说只有两种可能。对这两种可能题目很明确的说是在两点的两侧，也就是说不可能落在两点之间。从这个条件出发，计算 A 和 B 两个方向上的距离差，然后第一部分只要点 A 减去距离差以及点 B 加上距离差即可，第二部分则是不断进行这个延伸，直到超出边界。题目很简单，说实在的也没什么优化的空间。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;day-9-qu-jian-xian-duan&quot;&gt;Day 9 （区间、线段）&lt;&#x2F;h2&gt;
&lt;p&gt;一看见题目就知道应该采取怎么样的思路，但是太久没写类似的题目了，所以只有大概的思路，很明显是需要用区间解决的。但是我在决定该如何表达区间上犹豫不决花了太多的时间，所以我决定用暴力法试试看，在计算了需要的数组大小并不是特别大之后，用模拟的方法很容易的就解决了今天的问题，当然运行时间并不好，所以我还是需要用区间的思路解决。输入包含了两类区间，分别是文件和空闲，第一部分需要将文件拆分，填满空闲区间，文件从尾部开始拆分，而空闲空间从头部开始填满。第二部分则是不将文件拆分，需要将整个文件移动到可以容纳的空闲区间。&lt;&#x2F;p&gt;
&lt;p&gt;考虑第二部分，当一个文件移动到一个空闲空间时，首先文件占用的位置设为空，因为是从尾部的文件开始移动，而且一个文件最多只能尝试移动一次，所以位置上在这个文件之后的文件都已经被尝试过了，同时因为文件都是向前移动，所以这个文件移动后留空的部分只需要置空，而无需将其是做可能有文件会移动的空闲空间（空闲但不允许被写入）。然后考虑被占用的空闲空间，首先存在两种情况，一是大小刚刚好，那么这个空闲空间需要被删除，后续其他文件的移动无需考虑，而是大小大于文件的大小，那么就要调整空闲空间的区间值。&lt;&#x2F;p&gt;
&lt;p&gt;考虑第一部分，当一个文件移动后留下的空闲空间依旧是无法作为移动的空闲空间使用。当文件小于空闲空间时，实际上就是第二部分，而当文件大于空闲空间时，则需要拆分文件的区间，优先处理一部分文件，同样的处理过的文件不在移动。实际上对于第一部分，其实用暴力法来的更加方便，因为并不存在文件间的区分，而且从头部开始的空闲空间总是会被填满的，以及尾部的占用空间总是会移动，所以只需要用双指针分别表示最初的空闲空间以及最后的占用空间即可，然后不断的替换两个指针处的空间即可，时间复杂度是 O(N) ，虽然利用区间进行计算，时间复杂度应该也是 O(N) ，但是涉及到文件间的区分，逻辑上就更加复杂了。实际上的运行时也有差距，在第一部分就使用区间涉及到更多的查找操作，或者是移除无用的空闲空间所耗费的开销。&lt;&#x2F;p&gt;
&lt;p&gt;应该能进一步的优化，第二部分中查找符合大小的空闲区间我是直接线性搜索的，应该存在更好的搜索算法，也许可以维护一棵树？Reddit 社区有提到区间树，应该可以更快的找到满足要求的区间，只不过题目比一般的区间树其实存在更多的要求，比如移动后的空闲区间不能再使用（不插入区间树），以及区间要移动到起点较小的区间（需要修改区间树的查询？）。&lt;&#x2F;p&gt;
&lt;p&gt;参考：&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Interval_tree&quot;&gt;Interval tree&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;day-10&quot;&gt;Day 10&lt;&#x2F;h2&gt;
&lt;p&gt;今天的题目很简单，输入处理也很简单，输入也很小，搜索路径。两个部分之间也没什么差别，第一部分需要计算从一个位置能达到多少个目标，第二部分则需要计算从一个位置能有多少路径达到目标。第一部分误读了几次题意，其实就出现了第二部分的解。第一部分可以保存搜索过的路径，减少搜索空间，第二部分则可以保存搜索过的每个位置到目标的路径数，动态规划，减少搜索空间。但是因为输入太小了，所以根本无所谓，递归的深度优先搜索或者迭代的广度优先搜索都可以实现。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;day-11&quot;&gt;Day 11&lt;&#x2F;h2&gt;
&lt;p&gt;给定的输入其实很小，处理也相当容易，看完题目其实就知道是存在某种循环、规律，第一部分往往都可以直接模拟解决，经过一次变化，石头数最多翻倍，第一次的变化次数很少，所以在时间、空间复杂度上，简单的模拟是完全可以实现的。&lt;&#x2F;p&gt;
&lt;p&gt;第二部分循环的次数增加的，对于模拟而言次数增加一次，模拟操作是翻倍的，所以时间、空间复杂度是指数增长的，需要寻找某种模式或者更好的算法。对于类似的变化题目，很大程度上都是要寻找某种固定的模式，减少实际需要模拟的次数。简单的检查每次变化后石头的数字， 发现第二部分很明显会进入一个循环的状态，所有石头可能的数字并不增加，数字相同的石头不断增加。那么就可以对石头的转换进行缓存，保存每次缓存的结果，当再次遇到一样数字的石头时直接从缓存中取得即可，不需要重复的模拟。同时在计算过程中并不保存所有石头，而是记录每个石头出现的次数，那么就可以很轻易的计算（乘法）出所有这些相同数字的石头经过变换后会变为哪些石头。也许可以进一步分析每一次变化后，相同数字石头数量的变化，确定这个规律后，甚至可以直接取消重复模拟计算。当然这个规律并不容易取得，而且存在石头间的变化，所以单对一个数字进行分析是很难推出规律的，实际的测试也说明这一点。&lt;&#x2F;p&gt;
&lt;p&gt;再阅读了部分社区的解法之后，也有一个类似但不同的思路，类似动态规划，令 f(x, n) 为数字为 x 的石头经过 n 次变化后可能的石头数，那么根据变化规则就可以判断 f(x, n) 为 f(1, n - 1) 或者 f(left(x), n - 1) + f(right(x), n - 1) 或者 f(x * 2024, n) ，同时如果 n 为 0 f(x, 0) = 1，这就是石头变化数量的转换方程。转换过程中只需要缓存即可。某种程度上这两种角度是同一个方法的不同表现，第一种方法减少了每次需要判断的石头数，第二种方法则是减少了转换的次数。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;day-12-can-kao-reddit-jie-fa-ji-suan-jiao-de-shu-liang-yi-ji-suan-bian-de-shu-liang&quot;&gt;Day 12 （参考 Reddit 解法，计算角的数量以计算边的数量）&lt;&#x2F;h2&gt;
&lt;p&gt;应该是连通性的问题，连接区域的面积比较容易计算，可以计算区域中和相邻区域接触的数量即可，用深度搜索实现即可，当前位置的四个方向上存在不是本区域的植物即是边界的一部分，第一部分还是很轻松的，只是要在搜索过程中排除已经搜索过的位置即可。&lt;&#x2F;p&gt;
&lt;p&gt;第二部分需要计算连接面积的边的数量，处在边上的元素最多只和两个相同元素相连，当存在转弯时，搜索到新的边。这个思路没问题，但是实际的实现并不清晰，浪费了很多时间，最后我决定用笨办法，遍历区域中所有的点，确定四个相邻的点有多少是在区域内的，如果四个都在区域内说明这个点不在边上。如果有三个都在区域内，说明这个点在边上，只有一个方向与其他区域相邻，然后我记录这个边的直线以及这个点是在这个边的哪个方向（边的哪个方向是不在区域内的），将边和边的方向作为哈希表的键，以及点作为哈希表的值进行保存。同样的如果只有两个相邻的点在区域内，那么这个点就存在两个边上，同样的写入哈希表。一样的保存只有一个相邻点在区域内时三边和对应方向到哈希表。&lt;&#x2F;p&gt;
&lt;p&gt;参考 Reedit 的解法之后，其实我的第一个思路是没问题的，只不过我没意识到只要确定区域每有一个角就有一个边。~而实际上在我的第二个方法里，我已经计算了角的数量，如果一个位置的四个相邻位置中有四个都在区域内，这个位置一定不是角，如果有三个都在区域内，这个位置也一定不是角，如果有两个在区域内，并且两个位置的垂直和水平方向上的距离都是1，即这两个相邻位置不在一条直线上，那么这个位置一定是一个角，最后如果只有一个相邻位置在区域内，说明这个位置存在两个角（在三个边上）。如果没有相邻位置在区域内，那么就有四个角，其实区域大小为1。~没有意识到角的数量等同于边的数量让我做了不少无用功。&lt;&#x2F;p&gt;
&lt;p&gt;计算区域角的数量并没有我最初所想的那么简单，仅仅通过判断一个位置的四个相邻位置是否在区域内并不行。自己尝试从各种角度解决，但是依旧没能取得正确的答案，没能静心分析，最后参考了 &lt;a href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;1hcdnk0&#x2F;comment&#x2F;m1nkmol&#x2F;?utm_source=share&amp;amp;utm_medium=web3x&amp;amp;utm_name=web3xcss&amp;amp;utm_term=1&amp;amp;utm_content=share_button&quot;&gt;Reddit&#x2F;Polaric_Spiral&lt;&#x2F;a&gt; 的计算角数量的思路。大致思路如下，在每一个位置，可能有的四个角中，每个角都可能有两种状态，内凹或者外凸的。
对于是外凸的角，那么在两个 90 度相邻位置的邻居必然不在区域内，可见示例对于北方和东方的角：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;..
&lt;&#x2F;span&gt;&lt;span&gt;#.
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;对于内凹的角，那么在两个 90 度相邻位置的邻居必然在区域内，同时在这两个位置构成的对角线位置必然不在区域内，例如示例：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;#.
&lt;&#x2F;span&gt;&lt;span&gt;##
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;刚开始我一直以一个位置四周的四个位置落在区域内的数量，作为位置是否在边上的判断条件，考虑形状为十字架的区域，十字架中心的位置实际上也是落在边上的，但是它的相邻四个位置都在区域内。我是直到计算角的数量才发现我在这个边界情况上的错误判断，对于我自己的方法，这个错误并不影响计算，因为既然是十字架形状，那么四个方向上除了中心位置肯定还有其他位置落在同一个边上，那么没有这个点也不影响边数量的计算。但是在计算角的数量的时候就要考虑到这一点，因为如果只计算边上的位置存在角的数量时，少掉一个位置肯定会影响结果。这个误判也不只出现在十字架的形状中，对于大部分内凹的角的位置，其实都会收到这个误判的影响，例如下例中 (1, 1) 处其实存在一个内凹的角，这个位置也落在边上，同时四个相邻的位置都在区域内。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;AA.
&lt;&#x2F;span&gt;&lt;span&gt;AAA
&lt;&#x2F;span&gt;&lt;span&gt;AAA
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;今天的题目依旧不难，至少在时间、空间复杂度上不是偏难的题目，需要用的算法也很常见，但是在细节的处理上需要很好的分析。对于多边形边的数量等于角的数量这一知识点没能第一时间意识到，还有就是自己下了一些错误的决定，比如判断点是否在边上。这类题目其实就是考察边界情况，以及耐心。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;day-13-xian-xing-dai-shu&quot;&gt;Day 13 （线性代数）&lt;&#x2F;h2&gt;
&lt;p&gt;今天的题目和让人措手不及，总感觉应该是需要用到算法了吧，题目的描述又好像存在某种最优解，某种最优的抓取方式使得最后的耗费最少。带着这种偏见，我就用动态规划解决第一部分，令 m(p) 为到达奖品 p 处的最少耗费，那么就有如下转移方程 m(p) = min{3 + m(p - 1), 1 + m(p - b)}，其中 a 和 b 为按钮 a 和 b 移动的距离，同时还有边界条件 m((0, 0)) = 0 。根据这个就可以实现递归的方式从上往下依次计算，期间保存 m(p) 可以减少中间的计算过程，当然运行时间并并不好，因为还是有很多无用功。&lt;&#x2F;p&gt;
&lt;p&gt;第二部分把求解空间瞬间放大，再用动态规划就不现实了，花了我好一会才意识到这个题目根本不需要动态规划，有一个很重要的提示是题目不断地说起某些机器永远无法到达奖品位置，一般来说对于动态规划的问题，往往是存在多解，比如最短路径，往往是需要从中选择最优，有两个关键词很重要，就是多解和最优。因为最优把我引导到了动态规划，但是我却没有思考一下究竟是不是存在多解，是不是真的有所谓最优的情况。&lt;&#x2F;p&gt;
&lt;p&gt;动态规划里很常见的题目就是青蛙跳的题目了，一次跳一步还是两步计算最少的跳跃次数，在这个常见的问题里，求解空间是一维的，也就是说其实是一个二元一次方程，这样的话是存在多个解的，动态规划也就适用了。&lt;&#x2F;p&gt;
&lt;p&gt;而这个题目，抓取爪是在两个方向上移动，同时每个按钮也是控制抓取爪在两个方向上移动一定距离，同时奖品位于二维空间的特定位置，而且只有当抓取爪恰好处于所需要的位置时才能抓取成功，所以需要同时在两个方向上到达奖品位置，那么就构成了两个个二元一次方程组，其中参数和元都要是整数。只要计算这个方程组的解即可，而对于两个二元一次方程，是存在唯一解的，同时题目涉及到的解又只可能是整数，所以只要解方程就好了，用消参法可以很容易的计算唯一解，只要判断是不是整数即可。对于这个问题，其实根本不存在什么最优解，因为就一个解，对于算法的适用场景，还是要更仔细的分析才行，不要轻易被部分关键词所误导。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;day-14&quot;&gt;Day 14&lt;&#x2F;h2&gt;
&lt;p&gt;今天的题目依旧有些出其不意，第一部分简单的模拟即可，当然不需要构建地图进行一步一步的模拟，直接更新机器人的坐标即可，不过要注意当机器人移动到边界时会瞬移，也就是可能会溢出边界，需要对坐标进行求余操作，rust 中 &lt;code&gt;%&lt;&#x2F;code&gt; 的运算符会保留符号，取得的结果并不靠向 0 ，所以需要用 &lt;code&gt;rem_euclid&lt;&#x2F;code&gt; 计算非负的余数才行。&lt;&#x2F;p&gt;
&lt;p&gt;第二题其实很让人困惑，即没给出大概范围，又没给出需要搜索的形状，只是很模糊的表示大部分机器人可能会构成一个圣诞树的图片，那就只能自己找规律了。我先在每一次移动之后都打印出机器人的现有位置，自然的这样有大量的干扰输出，保存输出的文件不一会就超过 1G ，然后观察输出可以发现其中部分输出机器人会大部分的位于几行或者几列。最初我想是不是应该统计在集中出现几行和几列的频率，然后当同时出现在几列和几行的时候，就是结果，但是对我来说这个思路有点麻烦，因为既要检测形状，又要检测环。然后我就想到，如果大部分的机器人都构成一个图片，那这些机器人之间的距离应该是较小的，于是在每一次移动之后我都计算每对机器人间的距离，如果距离小于之前记录的最小距离，说明这个时候&lt;strong&gt;可能&lt;&#x2F;strong&gt;是构成了圣诞树。用这个方法很容易的过滤了大量的输出，同时也可以很容易的从中发现的确有正解。取得正解之后，为了避免程序不断循环，我增加了最小距离更新的时间间隔上限，如果超过这个上限最小距离还没更新，就退出程序，当然这是事后之明，这个方法其实也是有些运气的，如果作者夹杂了其他的不是圣诞树的图片，那么就可能会有错误的解，但是这类题目本身就有点像脑筋急转弯，严谨并不是最重要的部分，这类题目的有趣也就在此。&lt;&#x2F;p&gt;
&lt;p&gt;Reddit 上除了我这样的方法还有其他一些方法，都各有创意，也各有运气。就我个人而言这类题目最有趣，略微脱离某种严谨的编程，我还记得几年前有个题目最好的方法是折纸盒，这类问题阅读大家的方法也很有启发。&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;1hdvhvu&#x2F;comment&#x2F;m1z79gn&quot;&gt;将输出存为 PNG 格式，然后检查文件大小较小的输出，因为有规律的图片压缩更加优秀&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;1hdvhvu&#x2F;comment&#x2F;m1z7j2t&quot;&gt;计算连接机器人的数量，当数量超过一个人为给定的阈值之后，可能就是正解&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;1hdvhvu&#x2F;comment&#x2F;m1z9by8&quot;&gt;检查位置重叠机器人的数量，当没有机器人重叠的时候，即为正解&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;1hdwqgy&#x2F;2024_day_14_part_2_the_rsi_solution&quot;&gt;我的第一思路，计算大部分集中在行和列的频率，计算相交也是可行的&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;也许可以检查四个象限接触部分机器人的数量，因为最后结果圣诞树大致处于图片中间的位置。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;参考：&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-LANg.org&#x2F;std&#x2F;primitive.isize.html#method.rem_euclid&quot;&gt;rem_euclid&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;day-15&quot;&gt;Day 15&lt;&#x2F;h2&gt;
&lt;p&gt;今天的题目有点麻烦，第一部分其实还好，利用递归检查移动方向上下一个位置是否可以通行，存在如下三种可能：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;当下个位置空闲时可直接交换前后两个位置。&lt;&#x2F;li&gt;
&lt;li&gt;当下个位置为墙壁时说明机器人无法移动。&lt;&#x2F;li&gt;
&lt;li&gt;当下个位置为箱子，而且这个箱子通过递归判断最终是可移动的，那就交换当前位置和下一个位置。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;在这个递归中，总是在遇到空闲位置时开始交换位置，也就是说空闲位置不断的向最初位置进行交换，同时有且仅有递归搜索最后存在空闲位置才进行交换。&lt;&#x2F;p&gt;
&lt;p&gt;第二部分复杂了一点，地图被拉伸了，一个箱子本来只占据一个位置，现在箱子占据了左右两个位置（高度不变，宽度翻倍），但是机器人的大小不变。那么当机器人遇到箱子后，就存在多种情况。如果机器人的运动方向是向左或向右，那么机器人推动箱子的逻辑和之前其实是一致的，机器人推动一个箱子，然后箱子可能继续推动同一个方向上的箱子，依次类推直到遇到一个空闲位置。复杂的情况就是当机器人的运动方向为向上或向下，当机器人推动箱子时，因为箱子的宽度增加变成 2 了，那么一个箱子在运动方向上可能就会推着两个箱子，依次类推机器人最终推动的箱子可能是像一棵树一样，只有每一层的多个箱子都能被推动机器人才能移动。这个箱子树之间是存在依赖关系的，考虑机器人推动一个箱子 a ，而箱子 a 推动了两个箱子 b 和 c ，假设箱子 b 能被推动，但在确认箱子 c 能否被推动之前，是不应该推动箱子 b 的，反之亦然。也就是说对于第二部分简单的搜索回溯并不行，因为搜索的分支会决定是否需要回溯。&lt;&#x2F;p&gt;
&lt;p&gt;基于这个认识，我写出了解决方案，但是我的方法很丑陋，大致是进行了 2 次搜索，第一次确定机器人是否能够移动，如果机器人能够移动，第二次则移动箱子。这个思路虽然不是最优雅的，但却是没错的，结果我浪费了很多的时间在这个方法上，因为确定思路没错，所以不断的尝试取得正确答案，最后发现是在分支的判断上存在问题，导致部分情况没考虑到，而这些情况只存在复杂的情况中，对于给出的示例根本就不会遇到这些情况。&lt;&#x2F;p&gt;
&lt;p&gt;更好的思路是只进行一次搜索，在判断机器人能否移动的搜索中记录所有可能被推动的箱子，如果机器人能移动，那么最后只要循环推动这些记录的箱子即可。即便得到了所有可能需要移动的箱子，依然有一个问题没有解决，那就是推箱子的顺序问题，箱子移动留下的空间要么置空，要么被其他需要移动的箱子占用，那么就存在一个移动顺序，如果不按照移动的先后顺序修改地图，就有可能导致置空被写入，或者本需要的空间被置空。但是可以首先将所有需要移动的箱子占用空间置为空闲，再一次性的将所有箱子移动后需要的空间写入箱子，这样可以直接规避写入顺序的问题。对一个箱子而言，移动前的位置须要被置空，新的位置的箱子需要移动，所以不妨先都置空，再一次性重新写入箱子。移动并不导致箱子增加或减少，这样也避免由于移动顺序导致的箱子重叠问题。&lt;&#x2F;p&gt;
&lt;p&gt;上面这个思路没问题，但是应该还存在优化空间，我其实将机器人推动箱子和箱子推动箱子分开看了，但是理论上我可以将这二者归纳起来，箱子推箱子几乎就是两个机器人推箱子，这样应该能实现一定程度的优化。参考：&lt;a href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;1hele8m&#x2F;comment&#x2F;m250a7q&quot;&gt;SuperSmurfen&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;自己实现了这个方法，这个方法有一个弊端，如果将所有移动都视为机器人移动，那么在判断箱子能否移动的时候就需要根据情况检查两个可能位置的情况。假如一个箱子的正上方刚好是另一个箱子，那么在判断当前箱子的两个部分时就会分别判断对应上方整个箱子空间是否适适用，会涉及较多的重复判断，所以需要引入哈希表记录当前位置是否正在判断，而这会增加运行耗时。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;day-16-zhong-xin-xue-xi-dijkstra&quot;&gt;Day 16 （重新学习 Dijkstra ）&lt;&#x2F;h2&gt;
&lt;p&gt;今天终于遇到了我不会的题目了，题目其实很简单，就是最短路径，但是我并不熟悉相关的算法，尝试用 DFS 解决的时候，发现自己在很多细节上并不是最短路径的解决方法，我不断的在类似的题目上犯这个错误。然后用 BFS 解决的时候才理清了思路，但是无论是 BFS 还是 DFS 其实都会耗费大量的时间，因为在我的 BFS 和 DFS 方法中并没有实现什么缓存，也就是说我在搜索过程中不断的进行重复计算。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;del&gt;可以从题目中取得转移方程，令 m(c, f) 为坐标 c 和方向 f 到目标位置的最小分数，那么就有 m(c, f) = min{m(c-1, f) + 1, m(c, clockwise(f) + 1000, counterclockwise(f) + 1000} ，转移方程很明确，如果采用动态规划就能减少计算量，自顶向下要从初始点开始搜索，自底向上则要从目标位置开始，，无论是自顶向下还是自底向上其实都要穷尽可能性，否则将会出现我一直反的错误，即缺失了部分路径。&lt;&#x2F;del&gt;&lt;&#x2F;p&gt;
&lt;p&gt;最后自己绞尽脑汁依旧没想到该怎么实现，当然我是知道 Dijkstra 的最短路径算法是可以的，可是我并没有掌握这个算法，于是最后选择查看了相关的 wiki 页面，阅读了伪代码，然后自己实现了，在细节上因为对算法的理解不够，所以过程也不是一帆风顺，好在最后完成了第一部分。&lt;&#x2F;p&gt;
&lt;p&gt;第二部分实际上则是要取得所有的最短路径，应该也可以用 Dijkstra 算法解决。通过在过程中每当从起始节点到当前位置节点减少或&lt;strong&gt;不变&lt;&#x2F;strong&gt;时，记录当前位置的前置节点，并及时根据新的最短距离更新当前节点的前置节点集合，用 HashMap 进行表示，其中键为当前节点，而值为一直的最短距离和这个最短距离时已经发现的前置节点集合，当距离不变时将新的前置节点加入集合，当距离变小时，清空集合，同时将前置节点加入集合。在阅读了 wiki 中关于这个部分的内然后，wiki 中没有提到需要根据距离大小维护前置节点集合，我自己测试之后发现即使不清空集合，在这个问题中最后的解是不变的，也许这只是这个问题涉及的图比较特殊。在逻辑上，每次有新的节点进入优先队列时，实际上只是表示找到了这个节点目前的最短路径，而不是最终的最短路径，如果不维护前置节点集合，那么就可能最终的最短路径的节点中，前置节点集合包含非最优的情况，按照我的理解就会存在错误的路径分支才对。&lt;&#x2F;p&gt;
&lt;p&gt;再阅读了不少的解之后，我意识到 Dijkstra 实际上是特殊的 BFS ，一般来说 BFS 是采用先进先出的队列进行搜索，Dijkstra 则是采用优先队列，除去队列的不同，其他方面的差别很小。优先队列是为了将当前已知最短距离较小的节点优先进行搜索，采用优先队列的同时，记录在某一个节点前，起始节点到所有节点的已知最好距离，如果当前优先队列弹出节点的邻居节点的距离已经大于所记录的已知最小距离，那么当前节点的状态所在的路径一定不是最短路径，就不需要进行搜索了。有点类似在普通 DFS 或 BFS 中的剪枝，但是使用优先队列可以最大限度地剪枝，因为总是从较小的路径开始搜索，逐渐增加距离的过程。&lt;&#x2F;p&gt;
&lt;p&gt;今天的题目相比于一般的深度搜索或广度搜素，复杂的地方在于移动是存在方向限制的，而且方向存在着权重，所以一个位置上以某一种方向运动的麋鹿存在三个可能的走向，一个位置的麋鹿最多可能有四种方向，所以一个位置有个状态，四个节点。&lt;&#x2F;p&gt;
&lt;p&gt;阅读了部分社区的解之后，DFS 和 BFS 其实也是可行的，只不过需要将平时法访问表改变一下，一般来说访问表一般是检查&#x2F;搜索过的集合，当再次遇到相同状态就跳过，但在最短路径的算法中这个方法不可行，因为可能会跳过较优解，所以需要将访问表设为该状态目前的最短距离，如果再次遇到时距离大于访问表中的最短距离，就可以跳过搜索。通过剪枝是可以实现的，这个方法在第一部分可以在 10s 内运行完成，如果我刚开始在细节处理上没错，估计就会这样结束了。没必要纠结这个方法，因为这个方法本就不高效，好像每次自己都会在这个方法失败后纠结，反而没怎么深究 Dijkstra 或者其他的最短路径算法，不能老是踩一个坑。&lt;&#x2F;p&gt;
&lt;p&gt;即使用了 Dijkstra 我发现我的方法依旧不算快，然后通过火焰图发现我犯了一个很严重的错误，极其不应该的错误，Dijkstra 算法最后会取得其实状态到所有状态的最短距离，因为题目最后需要求的状态可能有好几个（不同方向进入目标位置），我的错误就在如何从所有最短距离中找到我需要的状态。我用目标位置的坐标去匹配所有节点的坐标，然后筛选出需要的最短距离。正确的方法，应该是直接构造目标位置可能的四种状态，直接用哈希表的查找即可。相当于 O(1) 能完成的操作，我用了 O(N) 的操作完成。&lt;&#x2F;p&gt;
&lt;p&gt;今天的题目在转弯的情况和直行的情况时，权重差别很大，所以其实无论在哪一条最短路径中，转弯的数量总是一定的，所以也可以在第二部分采用普通的 BFS ，检查转弯的数量。也可以直接 BFS 计算每条路径的长度，如果等于第一部分的答案就说明找到了一条可行路径。今天就这样吧，思路不清晰，算法也不熟悉，下次遇到不熟悉的算法，但是知道该用什么算法，不妨直接参考算法，靠自己苦思没什么价值。&lt;&#x2F;p&gt;
&lt;p&gt;参考：&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dijkstra%27s_algorithm&quot;&gt;Dijkstra&#x27;s algorithm&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;day-17&quot;&gt;Day 17&lt;&#x2F;h2&gt;
&lt;p&gt;今天的题目也是常见的题目，模拟 CPU 寻址执行，第一部分只要老老实实进行模拟就好。第二部分则让我绞尽脑汁，最后自己也没能解决，我首先根据提议将给定的输入程序转为伪代码，存在 3 个寄存器，但是经过转换后，可以确定从寄存器 A 直接得到输出的公式，需要确定寄存器 A 的初始值以得到满足题意的输出，如果暴力循环测试，对于我的输入，求解空间大小是 2^47 。往年这类题目的输入程序，往往没有这么容易就被化简，今年反而更容易化简，结果却无法轻易根据化简的结果取得想要的答案。&lt;&#x2F;p&gt;
&lt;p&gt;鉴于在尝试几小时后也没有很好的思路，我决定直接去 Reddit 寻找思路。参考1 ：&lt;a href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;1hg69ql&#x2F;comment&#x2F;m2gv80h&quot;&gt;jlhawn&lt;&#x2F;a&gt;，根据我的分析，可以确定 A 初始值的每 3 位(二进制)，对应每一个输出，根据这个提示，需要做的就是从 A 的最左侧 6 位和最后两个个输出进行判断。对我的输入程序的化简，可以得到每一个输出为 &lt;code&gt;a &amp;amp; 0b111 ^ 0b101 ^ (a &amp;gt;&amp;gt; (a &amp;amp; 0b111 ^ 1)) &amp;amp; 0b111&lt;&#x2F;code&gt;，同时当每一次输出后都需要对 a 进行右移三位，直到 a 为 0 ，然后程序退出。根据这个化简，可以得出每一个的输出和 a 是有直接关联的，如果这个公式中不存在 a 的右移，那么输出甚至只和 a 的最第三位有关，但是因为其中涉及到 a 的右移操作，所以并没有这么简单。每一个输出之后，a 的最左侧三位总是被丢弃，然后 a 右移三位，根据这一点可以从最后一位输出开始分析。&lt;&#x2F;p&gt;
&lt;p&gt;对每一个程序的输出，a 其中至少有 3 位和这个输出关联。如果有 16 个输出，那么寄存器 A 至少有 48 位长，对其中每 3 位，都有 8 种可能，可以对输出进行反向搜索，即先确定 a 的高位，根据化简的公式，可以发现当前的输出除了对应的三位，还和 a 更左侧的部分有关（公式中存在移位的部分），那么如果确定了a 左侧的部分，就能更容易的测试当前对应的三位，通过反向搜索正可以达到这个目的。在确定输出的最后一位，即确定 a 的最高三位时，a 不存在更左侧的部分，理论上可能对最后一个输出可能存在不止 8 个可能，但是对于我的输入和示例的输入，则最多只有 8 种可能，即存在大于等于 0 和小于 8 的 a 使得程序的输出为 0 。&lt;&#x2F;p&gt;
&lt;p&gt;在确定了 a 的最高 3 位之后，只需确定接下来的三位，对应输入程序中的倒数第二个，只需要将已经确定的 a 左移三位（对应输入程序中对 a 的右移三位），然后继续在这个基础上， 再在 0..8 中搜索可能的 3 位，逐渐的递归搜索，直到搜索到输入程序中的第一个。也许可能存在多个 a 满足条件，但是因为要求的是最小的 a ，同时又因为这个方法是反向搜索，所以第一个满足条件的 a 一定就是最小的。&lt;&#x2F;p&gt;
&lt;p&gt;本来以为我的方法会是只针对我的输入的，但经过测试，实际上给出的示例也是能够通过的，只要在搜索过程中使用第一部分的模拟方法取得输出，而不是用针对我的输入进行化简的公式计算输出即可，实现中也分成了两个部分，一个部分只支持我的输入，一个部分则是支持所有输入（题目给定的输入，随意的程序肯定是不行的）。&lt;&#x2F;p&gt;
&lt;p&gt;今天的题目不是那种往常的题目，方法其实很大程度取决于输入的程序，就好像编译器中对编译的优化，某种优化能不能实现很大程序取决于编译的程序，这类题目也很有趣，并不想 leetcode 之类的题目，不过也更加开放，需要动脑筋，只会算法并没有什么特别的帮助。自己的思路其实没有问题，但是在最后临门一脚上自己却思虑不够，我都能化简输入的程序，其实也已经发现了大致的规律，就是没意思的我应该反向搜索构造 a 。Reddit 社区上很多人都是测试程序运行输出，发现输出和 a 中的 3 位有关系，进而解决问题。如果把发现寄存器 A 和输出的关联规律算作第一部分的话，我是很完美的达成了这部分的。但是对于用深度搜索进行反向构造 a 的部分，我却没能很好解决。&lt;&#x2F;p&gt;
&lt;p&gt;社区上还有其他的一些方法，例如：1. 确定结果的大致区间，发现输入和输出的大致规律后，直接暴力测试。2. &lt;a href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;1hg38ah&#x2F;comment&#x2F;m2gwdtc&quot;&gt;在化简程序后，用 Z3 之类的外部依赖解决方程。&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;day-18&quot;&gt;Day 18&lt;&#x2F;h2&gt;
&lt;p&gt;今天的题目我感觉比前两天更简单，至少实现一个能解决题目的方法并不困难。题目虽然在开始说会每隔一纳秒掉下一块记忆，也就是每隔一纳秒地图会被阻塞一块，但是第一部分题目求的是当给定块记忆掉下后，从左上角到右下角的最短距离，最短距离而且每个方向上的权重都是一样的，那么简单的用 BFS 搜索即可，队列配合记录搜索过的位置即可实现。&lt;&#x2F;p&gt;
&lt;p&gt;本以为第二部分终于会用到题目中关于每一纳秒地图就会被堵塞的说明，结果也可以不用，第二部分只要判断在第几个记忆下落后从头开始前进，会无法到达右下角的位置。我先直接套用了第一个方法，遍历计算在 N 个记忆下落后的最短路径，当无法达到时，前一个结果既是正确答案。这个实现虽然慢，但是也很快的跑出结果了，因为搜索空间并不大。然后我意识到根本不需要计算最短路径，直接用 DFS 深度优先搜索路径即可，这个方法可以将运行时减半。&lt;&#x2F;p&gt;
&lt;p&gt;然后如果从尾部开始搜索更好，假设最初所有记忆都落下，那么只要从尾部移除记忆，然后进行路径搜索即可，如果联通那么可能路径很多，而且为了确认是联通的一般都要走到最后，但是如果被阻断了，那么搜索往往会提前结束。如果所有记忆中存在一块记忆使得路径被阻断，那么在这块记忆落下之后，其他记忆落下也不会使得路径开放。逆向测试搜索必然能找到最早使得路径被阻断的记忆，这个记忆的前一个记忆既是正确答案。同样的逆序搜索也可以不需要每次增加记忆块，而可以每次移除记忆块，根据实现的不同这也可能是有点。还有逆序搜索的时候，即使用广度优先搜索最短路径的算法效率也不必深度优先搜搜差，因为大部分的搜索都是不通的，往往搜索都会提早结束，这个情况下深度优先还是广度优先就差别不大了。&lt;&#x2F;p&gt;
&lt;p&gt;第二部分也可以用二分查找进一步减少搜索空间，Reedit 社区上很多人都用的这个方法，实现之后发现的确效率有提升，30ms 减少到 20ms 提升还是明显的。在社区上我还注意到了一个特别的地方，那就是其实不需要额外引入访问表，只需要把访问过的地方视作被阻塞的位置即可，这可以省去部分操作开销，现在我记起来这个操作的确是很常见的，在我的实现里这么做会有一点点冲突，当然在这个问题里也不是很有必要，总之这也是一个可能的优化点。简单的一天，Good.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;day-19&quot;&gt;Day 19&lt;&#x2F;h2&gt;
&lt;p&gt;今天的题目很轻松，第一部分是深度优先搜索，搜索到符合条件的模式即可，第二部分则需要计算所有可能的匹配模式，为了减少重复计算量，第二部分只需要加上缓存记录中间搜索状态即可，第二部分就是记忆化搜索。我为了快速得出答案，还采用了很直接的输入处理模式，我把输入都转为 bytes 的数组，搜索都是基于数组进行搜索，这个开销并不小，实际上可以直接使用字符串进行搜索，甚至可以进一步直接将字符串转为数字，不过这个不见得会比字符串要好。使用字符串直接进行处理的时候， 在中间搜索过程就可以使用字符串的方法，比如匹配前缀，这些方法应该也能提升运行效率，虽然实际上 rust 的 &lt;code&gt;Slice&lt;&#x2F;code&gt; 也有 &lt;code&gt;start_with&lt;&#x2F;code&gt; 直接判断前缀，同时查看源代码可以发现，其实也是简单的判断长度是否合适，然后简单比较，所以在这个实现上并没有效率提升，实际上我不需要使用 &lt;code&gt;String&lt;&#x2F;code&gt; 直接使用 &lt;code&gt;Vec&lt;&#x2F;code&gt; 也是没问题的，只不过在中间搜索过程中使用 &lt;code&gt;Slice&lt;&#x2F;code&gt; 就行。&lt;&#x2F;p&gt;
&lt;p&gt;在进一步阅读了部分社区的讨论之后，今天的题目也可以直接用正则表达式解决，第一题其实就是很简单的正则搜索，第二题则有的正则引擎能够直接实现，参考：&lt;a href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;1hhtrgj&#x2F;2024_day_19_alternative_solutions&quot;&gt; [2024 Day 19] Alternative solutions &lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;day-20-dijkstra&quot;&gt;Day 20 (Dijkstra)&lt;&#x2F;h2&gt;
&lt;p&gt;今天的题目对我而言难度不小，还是 2D 最短路线搜索，只不过多了一个条件，那就是在搜索过程中地图会发生变化，部分位置会变为可通行。第一部分在每次搜索中最多只有一个位置可以发生改变，在第二部分中则最多可以有 19 个相连的本不可以通行的位置发生改变，需要计算的就是有多少种位置发生改变的情况，可以使最短距离减少到题目所要求的距离。&lt;&#x2F;p&gt;
&lt;p&gt;第一部分我先列出所有可能的位置变化情况，然后依次进行广度优先搜索确定最短路径，然后筛选出正确的结果，运行效率并不好，但是也取得了正确结果。对于第二部分好像就不能这么简单的实现了，题目中提及的作弊，其实就是给两个节点之间增加新的边，也许可以先确定满足题意要求的边有多少。第二部分的搜索空间大到连两个节点间有多少可能的边都无法计算。&lt;&#x2F;p&gt;
&lt;p&gt;对我而言题意不是很明晰，相比于最初的思路，我意识到可以计算出所有作弊的可能和对应的作弊所需要的时间（距离），然后利用 Dijkstra 算法，计算出起点到每个作弊开始的最短距离，然后用同样的方法计算出终点到每个作弊结束的最短距离，那么对于任意中作弊就可以很容易的计算出最短距离。这个方法可以做到有结果输出，而且对于给出的示例是能取得正确答案的，但是对于实际的输入却不对。题意对我而言模糊的点有好几个：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;作弊中是否遇到可行驶的位置就停止作弊。实际测试中发现如果遇到可行驶的位置就停止，示例的结果会比示例给出的正确答案少很多，同时实际输入的答案也不正确。&lt;&#x2F;li&gt;
&lt;li&gt;作弊是否需要遇到墙壁才能启动，根据测试这个条件也是不必要的。&lt;&#x2F;li&gt;
&lt;li&gt;作弊过程中遇到终点是否结束作弊？我很明确的记得刚开始的题目要求中是有这一点的，但是刚刚测试了没有这个要求的答案，居然过了。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;根据这三个前提，我得到了正确答案，但是我的方法很慢，因为我计算作弊的路径时用了 Dijkstra 算法， 但是根本不需要这么复杂，只需要计算两个空闲位置的&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Taxicab_geometry&quot;&gt;曼哈顿距离&lt;&#x2F;a&gt; 即可。&lt;&#x2F;p&gt;
&lt;p&gt;在阅读 Reddit 的讨论中我也意识到题目给出的路径其实只有一条，所以根本就不需要用 Dijkstra 算法。 使用 &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;rayon&#x2F;latest&#x2F;rayon&#x2F;index.html&quot;&gt;rayon&lt;&#x2F;a&gt; 可以快速的实现迭代器的并行，不过并不是对所有的场景都有提升，在某些场景可能并行本身的开销就要大于实际操作的开销，在我的使用中大致可以实现运行效率翻2-3倍。&lt;&#x2F;p&gt;
&lt;p&gt;今天算是被题目描述坑了，根据最新的描述，其实大概率我可以提早完成，还有今天的题目并不是路径搜索，不过我自己的实现也算是对 BFS 和 Dijkstra 的进一步练习了。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;day-21-can-kao-reddit-ti-jie-shan-yong-ji-yi-hua-sou-suo&quot;&gt;Day 21 （参考 Reddit 题解，善用记忆化搜索）&lt;&#x2F;h2&gt;
&lt;p&gt;今天的题目有点链式搜索的意思，还是路径搜索，总共有好几层的搜索，需要求最后的最短路径，我不是很喜欢这个题目，有点让人心烦。我用 BFS 能求出某个层级的最短路径，但是这个路径传递到下一层时，对这个路径进行再次搜索的时候，又不见的就能取得最短的路径了。&lt;&#x2F;p&gt;
&lt;p&gt;我感觉我应该实现多层级的对应，直接确认当最外层的我按下按钮时，最内层的按钮是如何被按下的。实现多层级的映射以及直接搜索后，第一部分顺利通过。第二部分则没有这么轻松了，因为求解空间被放大了，而且增长是指数级的，每增加一个机器人分支的数量就指数增长，第一部分的方法就不再现实了。无论是逐层的求解最短路径，还是我的映射求解，这个问题都很严重吧，如果能保证每层搜索得到的最短路径都能确保下一层依照这个路径进行搜索也能得到最短路径，那么也许逐层的方法能够减少大量的求解空间，但就是这点困住了我，再想想吧。初步预估，按照第一部分的方法，大致需要 5^25 s ，不知道有没有超过宇宙的寿命。第一部分方法的时间复杂度是 O(N^5) ，N 是机器人的数量。&lt;&#x2F;p&gt;
&lt;p&gt;一些观察：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;对于数字输入，例如 029A ，长度为 4 ，那么外层的方向键盘输入，至少存在 4 个 A，对于数字 0 ，机器人的机械臂从数字键盘的 A 位置（初始位置），移动到 0 位置，然后外层机器人按下控制这个机器人的方向键盘上的 A 按键。假设每次输入 A 最少需要移动机械臂 N 次，N应该是介于 0 到 3 之间的数，假设平均为 2 ，那么最后的路径长度大致是 4 * 2^26 ，仅仅是某一条路径，也许都改变走不完。&lt;&#x2F;li&gt;
&lt;li&gt;对于方向键盘而言，从一个位置到另一个位置最多需要移动 3 次。&lt;&#x2F;li&gt;
&lt;li&gt;我发现当数字键盘输入某个特定的值时，所有机器人的机械臂都处于相同的位置，所有外层机器人的机械臂都在 A 处。&lt;&#x2F;li&gt;
&lt;li&gt;对于单个键盘而言，从一个位置到另一个位置，是存在某种较优的情况的，比如对于数字键盘而言，从 5 走到 A ，如果方向是向右或向下，这些路径一定大于向上或者向左。同时即使走了并不是曼哈顿距离的路线，对于最外层而言，依旧会有子集是曼哈顿距离的路线，5 走到 A ，在不存在穿越边界的情况下，总是需要向下和向右的。不难发现，对于再外层而言，曼哈顿距离的路线一定是较优解。&lt;&#x2F;li&gt;
&lt;li&gt;第 4 点里提及的较优路线，这些较优路线很大程度上会体现在外层的路线上，内层每少按一个按钮，外层机器人移动机械臂到 A 的次数就少一次。也就是说对于某一层的最短路线，它内一层的路线，一定是那一层最短路线中的一个。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;有点像多维的情况，有点难理解，需要很强的想象力，我总感觉存在一个地方能进行缓存。如果采用我的映射方法，那么每次的状态包括，所有机器人机械臂的坐标，同时也包括剩余的数字输入。根据第 5 点，也许能实现一个可行的方法，需要计算每一层的所有最短路径，再在这个基础上搜索其中的最短路径。&lt;&#x2F;p&gt;
&lt;p&gt;对于普通的 Dijkstra 算法而言，节点是位置的坐标，对于这个题目，节点是什么呢，如果同样是机器人机械臂的坐标，那么最后的图将是有环的，而且满足条件的路径是有要求的，也许这个题目改变就不是最短路径的题目。&lt;&#x2F;p&gt;
&lt;p&gt;对于任意的序列，例如数字键盘上从 5 走到 A ，这个的最短距离其实就是曼哈顿距离，其中存在几种不同的路线，但是路线中包含的移动策略类型是一样的，即至少需要向下走两次，然后向右走一次，对于外层而言，实际上就是要确定向下走两次和向右走一次以怎么样的方式排列能实现最少的移动。对于方向键盘，实际上也就是不断的递归计算，而对于数量众多的方向键盘，其实它们的规律都是一致的，所以可以很容易的计算出所有组合的规律。依照这个思路，也就可以用动态规划进行完成。&lt;&#x2F;p&gt;
&lt;p&gt;对每种键盘构造最短距离表，二维数组表示从一个键位到另一个键位所需要的最短距离，每个元素表示这个最短距离所需要的向上，向下，向左和向右移动分别需要的次数。直接用排列的方法取得所有可能的最短路径并不行，因为键盘上存在空白的位置，这会引入错误的路径，这就导致原本可以一个方向走到底，然后再转弯的情况，必须要提前转弯。&lt;&#x2F;p&gt;
&lt;p&gt;根据这个情况，可以发现，最短的路径应该是转弯最少的路径，如果机器人要不断的往一个方向移动，那么控制这个机器人的机器人只需要不断的将机械臂指向那个方向，同时再外层的机器人只要按 A 即可。即使我通过搜索完全确定从一个位置到另一个位置的所有最短距离修复了这个问题，根据之前预估的分支数量，求解空间依旧巨大。&lt;&#x2F;p&gt;
&lt;p&gt;如何直接确定最短路径中哪一条最可能获得最后的最短路径呢？是转向最小的路径吗？这个方法还是不对，搜索空间被排除的太多了，而且即使是这个方法在第二部分的运行效率依旧不高，也许可以加上缓存，记录所有方向键的序列对应的最短路径，但是我不觉得能有什么帮助，是时候去社区获取一点提示了。阅读了一个题解，大部分的提示都和我的观察不谋而合，只不过加上了缓存，缓存是同当前键盘的深度以及机械臂所在的位置相关连的，对某一层次的机器人而言，当使得数字键盘从一个按键移动到另一个按键时，这层的机器人总是从 A 开始到 A 结束。&lt;&#x2F;p&gt;
&lt;p&gt;总是在关键的地方就放弃了，我以为缓存不会巨大的求解空间有什么效果，结果事实证明我完全错误，当然我最初的缓存设想也不正确，缓存记录的是在某一层的机器人，从一个按键移动到另一个按键时直到最外层的最短移动距离。对于某一层的机器人而言，从特定的一个按键移动到另一个特定的按键，这层之外的其他机器人都是从 A 开始移动，并以 A 结束，于是对于相同的按键序列，总是能够得到相同的最完成最短距离。&lt;&#x2F;p&gt;
&lt;p&gt;在上面我实验了直接用排列构造下一层可能的最短距离，以及只选择转弯最少的方案的最短距离进行测试，要不是因为没有排除实际上不可行的路径，要不是把过多可行的路径删除，实际上我只需要对所有可能的最短路径进行移动测试即可，进行测试就能保证路径可行且是最短的，&lt;strong&gt;我需要更加耐心才行&lt;&#x2F;strong&gt;。这两种方法实际都可行，而且直接全排列构造可能的最短距更加快，实际上两个按键间的距离必然不可能太大，再加上可能有的全排列优化。&lt;&#x2F;p&gt;
&lt;p&gt;参考：&lt;a href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;1hj2odw&#x2F;comment&#x2F;m34fgf6&quot;&gt;ndunnett&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;day-22&quot;&gt;Day 22&lt;&#x2F;h2&gt;
&lt;p&gt;今天的题目很好理解，也没什么特别难的，第一部分就是简单的数学运算，第二部分实际上还是数学运算。第二部分需要计算某个价格变化的序列，使得每个买家在首次遇到序列时出价，最终能得到最高的价格。我直接对每个买家的 2000 个序列计算价格，和价格变化，然后将所有长度为 4 的价格变化序列作为哈希表的键，以及首次遇到时对应的价格作为哈希表的值。在对所有买家都取得了价格变化序列对应价格的哈希表后，遍历所有可能的序列取得每个买家首次遇到这个序列时的出价，再计算所有买家对这个价格变化序列的总出价，最后只需要计算其中的最大值即可。这个方法可以在 10s 内获得正确答案，也可以进一步优化，直接在建立哈希表的时候，就计算对应序列对所有买家的初次遇到时的出价总和，最后只要对这个哈希表计算值最大即可，这样优化之后程序的运行时间是 200ms 内。还有进一步的优化吗？&lt;&#x2F;p&gt;
&lt;p&gt;一些观察：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;价格变化的值的范围在 -9 到 9 ，对于长度为 4 的价格变化序列，总共存在 20 * 20 * 20 * 20 种可能。&lt;&#x2F;li&gt;
&lt;li&gt;遍历所有的价格变化序列是程序中最需要计算的部分，对于每个卖家总共存在 2000 个价格变化序列，每次遍历都需要检查对于这个卖家这个变化序列是否出现过，还可能修改价格变化序列对应总价的哈希表。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;将长度为 4 的价格变化序列对应为一个数字，这可以降低在检查序列是否出现时用 &lt;code&gt;HashSet&lt;&#x2F;code&gt; 的操作成本。参考 &lt;a href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;1hjroap&#x2F;comment&#x2F;m390cfi&quot;&gt;semi_225599&lt;&#x2F;a&gt; 的题解，我意识到在构造计算序列变化的出价总和时，只需要价格变化的序列反向进行计算即可，这样可以不需要检查是否出现过，逆序计算可以确保最终在哈希表中的价格是序列最早出现时的价格，不过这个优化不是很适用我的实现。&lt;&#x2F;p&gt;
&lt;p&gt;发现一个诡异的情况，那就是测试运行的速度居然比二进制运行的快，特别是在 release 模式下，破案了，运行的命令错了，加了一个错误的空格，鬼知道从几天前开始就这样了。&lt;&#x2F;p&gt;
&lt;p&gt;在将价格变化序列对应为一个数字，同时用数组记录序列对应的价格，以及序列出现的情况后，运行时间在 debug 下在 500ms 左右，而在 release 下则在 50ms 左右，这个优化还是很明显的，这才对嘛，难怪这两天总感觉自己做的优化效果不明显，原来是命令错了。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;day-23-di-yi-ci-zhi-dao-de-suan-fa-bron-kerbosch&quot;&gt;Day 23 （第一次知道的算法 Bron-Kerbosch）&lt;&#x2F;h2&gt;
&lt;p&gt;第二部分需要找到一个 LAN party ，其中每个成员都与其他成员互相连接。假设电脑 A 为满足要求中的一台电脑，令与电脑 A 互相连接的所有电脑为集合 Sa ，那么 Sa + {A} 既是所求 LAN party 的所有电脑，同时 Sa 中的一台电脑 B 对应的互相连接的集合 Sb ，就存在 Sa 和 Sb 的互相相对补集只有电脑 A 和 B 。&lt;strong&gt;这个思路并不对&lt;&#x2F;strong&gt;，因为并不是 Sa 中的所有电脑都要满足这个条件，最终的 LAN party 可能只是 A 和 Sa 的子集。&lt;&#x2F;p&gt;
&lt;p&gt;如果不从集合的角度入手，从图的角度呢？~应该不是图的题目，并不涉及间接相连，只考虑直接相连的情况。~集合和图密切相关的，只不过我的认知不足罢了。直接试试看暴力法吧，思路不是很清晰，也许暴力法能够给我一些提示。暴力法能够给出示例的正确答案，但是对于实际的输入就太慢了，因为可能的组合数太大了，而且每次检查的花费也不少。&lt;&#x2F;p&gt;
&lt;p&gt;我意识到暴力搜索所有可能的结果并不现实，但是可以对每台电脑进行逐一的暴力搜索。假如 A 在满足条件的 LAN party 中，那么 {A} + Sa 一定是最终 LAN party 所有电脑集合的超集，那只需要对 {A} + Sa 的所有元素进行组合搜索即可，搜索从最大的可能开始，到长度为 2 的最小的满足要求的集合，这样可以直接搜到 A 所在的满足条件的 LAN party 的最大集合。依次对所有电脑进行搜索，确定其中满足条件的最大集合即可。这样的实现，在 release 下运行的还是比较快的，30 ms 左右完成运行。这个方法得益于最初的观察和暴力法的测试，二者缺少一个都可能没法这么快的想到这个方法。&lt;&#x2F;p&gt;
&lt;p&gt;这个方法其实和我最初的设想一致，怎么根据集合的要求，从 Sa 中排除不满足要求的电脑，但最初的思路是从底向上，也就是慢慢的确定集合的成员。最后的方法则是反向的从顶向下，逐渐移除 Sa 中的电脑，检查移除后的集合是否满足要求。自顶向下我用了 &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;itertools&#x2F;latest&#x2F;itertools&#x2F;trait.Itertools.html#method.combinations&quot;&gt;Itertools&lt;&#x2F;a&gt; 的方法实现组合，最初的思路其实也可以这样操作，但是我没能很好的意识到这一点，我想一步一步构造正确的答案，而被其中可能的复杂所绕晕了。因为一台电脑所直接连接其它电脑的数量并不多，所以可以直接构造所有的可能，然后进行逆序搜索，这样的方法就能快速得出答案。&lt;&#x2F;p&gt;
&lt;p&gt;社区的题解也有好几种思路，比较多的就是直接从图的思路入手，其中有直接使用第三方能够解决这个问题的库，还有的则是实现了对应的算法，因为这个问题是已经被明确定义的问题，中文应该是最大团&#x2F;最大聚类，初步来看，其实就是我的最初思路，从一台电脑组建构建出可能的最大集合。&lt;&#x2F;p&gt;
&lt;p&gt;在对输入的处理上，刚开始纠结了好一会，因为不确定是不是用数字索引代表电脑更好，最后还是引入了索引表，但在这个问题中并不需要。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;bron-kerboschsuan-fa&quot;&gt;Bron-Kerbosch算法&lt;&#x2F;h3&gt;
&lt;p&gt;阅读 &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Bron%E2%80%93Kerbosch_algorithm&quot;&gt;Bron–Kerbosch algorithm&lt;&#x2F;a&gt; 以及其他的一些资料后，我可以照抄的实现算法，大致的思路我也知道了，描述如下：&lt;&#x2F;p&gt;
&lt;ol start=&quot;0&quot;&gt;
&lt;li&gt;是一个递归加回溯的算法&lt;&#x2F;li&gt;
&lt;li&gt;对于某一个最大团 R ，R 为最大团的集合（所有元素互相连接）。&lt;&#x2F;li&gt;
&lt;li&gt;存在一个集合 P ，P 中的元素可能会被加入到 R 中。&lt;&#x2F;li&gt;
&lt;li&gt;存在一个集合 X ，X 的作用我并不是很理解，大致的作用是去重，在搜索最大团的过程中，如果不重复，X 总是为空。X 中的元素的最大团都已经被搜索过了。&lt;&#x2F;li&gt;
&lt;li&gt;初始时 R 为空集，同时 P 为所有节点，X 为空集。&lt;&#x2F;li&gt;
&lt;li&gt;每次搜索时，都循环遍历 P 中的边（元素） v ，这时产生分支。&lt;&#x2F;li&gt;
&lt;li&gt;将 R ⋃ {v} 作为新的 R 进行递归搜索。
&lt;ol&gt;
&lt;li&gt;对于这个集合而言，对应的 P 就是 P 和 v 邻居的交集，只有同时在 P 中，又是 v 的邻居，才可能加入到新的最大集中。&lt;&#x2F;li&gt;
&lt;li&gt;同样的对应的 X 就是 X 和 v 邻居的交集，如果结果不为空说明目前的这个最大团，是某一个最大团的一部分。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;回溯：当递归搜索完成后，将 v 从 P 中移除，同时将 v 加入 X
&lt;ol&gt;
&lt;li&gt;从 P 中移除是在搜索其他最大团时避免再搜索到 v&lt;&#x2F;li&gt;
&lt;li&gt;把 v 加入到 X 是为了当 P 为空的时候，判断此时的 R 是否为新的最大团，如果 X 不为空，说明目前的 R 是某一个以及找到的最大团的子集。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;这个算法存在一些其他的优化，但是目前的我并不是很明确，即便是最基础的部分依旧存在让我困惑的部分，也许再次遇到我就能更加明白了，目前就先这样。&lt;&#x2F;p&gt;
&lt;p&gt;参考链接：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Clique_(graph_theory)&quot;&gt;Clique&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Clique_problem&quot;&gt;Clique problem&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;[Bron–Kerbosch algorithm](https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Bron%E2%80%93Kerbosch_algorith&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;oi-wiki.org&#x2F;graph&#x2F;max-clique&#x2F;&quot;&gt;OI Wiki 最大团搜索算法&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;ics.uci.edu&#x2F;~eppstein&#x2F;163&#x2F;lecture6b.pdf&quot;&gt;Lecture 6b: Cliques and the Bron–Kerbosch algorithm&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=_-AfhLQfb6w&quot;&gt;Can you find: five five-letter words with twenty-five unique letters?&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;day-24-shou-dong-tui-dao-de-chu-da-an&quot;&gt;Day 24 （手动推导得出答案）&lt;&#x2F;h2&gt;
&lt;p&gt;第二部分需要调试输入给出的加法器的程序，部分逻辑门被调换了位置，导致加法器结错误。在我的输入中最终结果的部分位并不对，需要修正的逻辑门应该是和这些逻辑门相关的部分。如果用暴力法，那就需要从所有逻辑门中选择八个进行排列，然后两两对换逻辑门右侧的部分，接着再对所有逻辑门进行重新求解，暴力法需要的实际无法想象，并不现实。&lt;&#x2F;p&gt;
&lt;p&gt;暴力是跑不完的，今天的注意力很难集中，没想到很完整的思路。逻辑门的加法应该是从最低位开始，逐渐往上实现计算的，也许进行深度搜索。从 x0 和 y0 开始，计算所有涉及到 x0 和 y0 的逻辑门，然后得到新的变量 gtb 和 z0  ，判断 z0 是否符合预期，如果不符合预期说明 x0 和 y0 的逻辑门存在错误，尝试调换顺序？&lt;&#x2F;p&gt;
&lt;p&gt;在我的输入中，第 17 位出现了不一致，第十七位应该是受到所有之前位运算的影响的，和 z17 直接相关的有两个变量，两个变量又分别对应一个逻辑门，难道调换这两个逻辑门吗？在考虑通用的方法无果后，我意识到还是要从二进制加法入手：&lt;&#x2F;p&gt;
&lt;p&gt;根据参考，可以确定用逻辑门实现加法主要涉及以下两种结构，半加器：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;- sum = a xor b
&lt;&#x2F;span&gt;&lt;span&gt;- carry = a and b
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;全加器：两个半加器和一个或门&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;- sum = carry_in xor (a xor b) 
&lt;&#x2F;span&gt;&lt;span&gt;- carry_out = (carry_in and (a xor b)) or (a and b)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;题目给出的加法输入逻辑门，刚刚好和一般的逻辑门实现加法一致，从 x 和 y 到 z 中间，除去 x 和 y ，还会会存在一个 carry_in 变量，然后有三个中间变量，以及一个输出的 carry_out 变量，每个中间变量都需要一个逻辑门得出，以及输出的变量也需要一个逻辑门，所以再每一位的计算中，至少存在四个逻辑门。当某一位出现错误时，可能是 carry_in 计算出错，也可能是 x 和 y 半加时的中间变量错误。&lt;&#x2F;p&gt;
&lt;p&gt;我首先实现了所有的逻辑演算，大致如下，对于 z 的任意一位，可以根据逻辑门实现的全加器推导到已知的 y 和 x ，那么我也可以根据输入的逻辑门，也推导出依靠已知 y 和 x 的计算某一位 z 的公式。又因为知道输入的逻辑门程序，其实就是多位全加器，那么理论上这两个公式应该是一致的，接着对 z 的每一位，都通过这两个途径取得公式，根据全加器得出的公式必然正确，而根据输入得出的公式则不一定正确，那么当这两个公式不一致时，就可以确定在计算 z 的这一位时输入的逻辑门（公式）存在问题。&lt;&#x2F;p&gt;
&lt;p&gt;通过实现解析方程，可以确定在第几位的时候，题目给出的逻辑门发生了错误，但是如何调换顺序呢？在我的输入中有 x12 AND y12 -&amp;gt; z12 ，也就是说在第 12 位就不考虑进位了，错误应该就是从这里开始的，虽然实际对应到位的值上，第 12 位的值是正确的。 x12 AND y12 应该是第二十位进位运算的一部分，右值 z12 应该换为其他的变量，已经出现过的变量不应该被替换，而且也不是 x y 和 z 开头的变量，是直接遍历测试吗？对于这个情况一般来说，只需要替换涉及到 z12 的所有逻辑门（包括中间逻辑门）即可，这就涉及到哪些变量和哪些逻辑门相关的问题了，难道要拓扑排序吗。&lt;&#x2F;p&gt;
&lt;p&gt;总感觉自己把问题想的太复杂了，或者是我又想偷懒了，有点犹豫不解。还是回到那个问题，要怎么替换呢，用代码我没想到好的方法，所以我决定那就自己手动推导一下，因为题目中最多只有 8 个逻辑门存在错误，在确定问题的大致范围后，其实手动推导并不困难，事实也是如此，通过手动推导我很容易的就发现了需要调换位置的逻辑门，最后利用 Python 解释器很容易的也得出了正确答案。&lt;&#x2F;p&gt;
&lt;p&gt;在手动推导的过程中，有几个关键的点：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;那就是对于直接得出 z 的某一位的逻辑门，根据全加器的实现，除了最后一位必然是异或逻辑门，在我的输入中，需要调换位置的 3 对逻辑门都是这种情况&lt;&#x2F;li&gt;
&lt;li&gt;同时对于直接得出 z 的某一位的逻辑门，同样根据全加器的实现，其中一个必然是由或门得到，因为是上一位的进位，而另一位则必然是由异或门得到，来自半加器的加和结果。&lt;&#x2F;li&gt;
&lt;li&gt;对于 x 和 y 某一位的异或门和与门，其中异或门必然是参与对应 z 的直接计算的逻辑门（其中一个输入），而与门的结果则必然参与到计算进位的逻辑门（或门）。我的输入中第一个要进行调换的情况就是这个。&lt;&#x2F;li&gt;
&lt;li&gt;与门和异或门总是成对出现，两个输入如果有与门，那么一定有异或门。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;根据这几点，是可以实现代码进行调换的，但是有一个很严格的前提，那就是给定的输入是严格的全加器，当然我也不确定是不是有其他的全加器实现。还有一个前提就是，需要调换的逻辑门数量很少，而且调换不会直接影响到其他位的计算。最终我还是没有实现代码自动替换，一是我感觉这个过程涉及的条件判断有点复杂，二是总感觉自己在做无用功，因为恰好题目和输入是这样，所以我的这些一个个复杂的条件恰好可行，我预见最后我还是不会对得到的代码感到满意。最后就是今天真的很没耐心，说实在的今天我居然能手推出结果，我都已经很满意了，更别提我还详细的知道了全加器的电路逻辑实现，这应该是今天题目的最大收获，所以今天就这样吧，最终还是需要知道全加器才能用我写的辅助程序进行定位，对的我的实现到最后也只能算是辅助程序。&lt;&#x2F;p&gt;
&lt;p&gt;参考：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;bjc.edc.org&#x2F;bjc-r&#x2F;cur&#x2F;programming&#x2F;6-computers&#x2F;optional-projects&#x2F;2-adder.html&quot;&gt;Unit 6 Optional Projects, Page 2&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Adder_(electronics)&quot;&gt;Adder_(electronics)&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;day-25&quot;&gt;Day 25&lt;&#x2F;h2&gt;
&lt;p&gt;今年结束了，与往年一样，最后一天的题目总是让人心满意足，轻松并不随意。相比于往年，今年自己感觉更得心应手了，虽然有几天还是要苦思冥想，但是相比于第一年我遇到基本的算法都要琢磨推敲半天的情况，今年甚至感觉有些轻松，大部分的算法我都理解，除了刚刚开始还没怎么习惯，过去一年自己也基本没写什么代码，更别提看什么算法了，总的来说我对今年的题目很满意，但是对今年的自己和今年自己做的和没做的事情并不满意，加油！！！&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>实现 Neovim 输入法自动切换</title>
        <published>2024-06-07T11:20:38+00:00</published>
        <updated>2024-06-07T12:36:27+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/im-autoswitch/"/>
        <id>https://ghost.livexia.xyz/im-autoswitch/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/im-autoswitch/">&lt;p&gt;如果是只使用 Neovim 写代码，那么 Neovim 的体验很好，因为大部分的输入场景都可以使用英文输入，但是如果要使用 Neovim 来进行记录，也就是在频繁需要混用输入法的场景下，那么 Neovim 的体验就稍差。在 insert 模式下使用中文输入法输入，然后进入 normal 或 visual 模式后由于输入法仍是中文，导致按键无法被 Neovim 获取，这时就需要手动切换输入法到英文，而这并不是很好的体验。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;que-ding-zi-dong-qie-huan-de-fang-fa&quot;&gt;确定自动切换的方法&lt;&#x2F;h2&gt;
&lt;p&gt;在搜索解决方案的时候，发现一篇很不错的文章，介绍了各式各样的解决方案，具体可见 链接 1 。在阅读过文章，以及进入各个方案的具体页面之后，我决定使用 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rlue&#x2F;vim-barbaric&quot;&gt;vim-barbaric&lt;&#x2F;a&gt; ，主要是因为这个插件需要的配置相对少，同时在 Linux 上不需要使用第三方软件（这一点其实是大部分解决方案的共同优点），虽然相较于其他的解决方案，这个方案的适配范围稍小，因为我的主要环境是 macOS 加上少部分的 Linux ，所以这个方法对于我的使用场景是比较充分的。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;an-zhuang-xkbswitch-macosx&quot;&gt;安装 xkbswitch-macosx&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;intel-mac&quot;&gt;intel Mac&lt;&#x2F;h3&gt;
&lt;p&gt;参考 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;myshov&#x2F;xkbswitch-macosx&quot;&gt;myshov&#x2F;xkbswitch-macosx&lt;&#x2F;a&gt; ，总结其实就是复制仓库，然后将 &lt;code&gt;bin&#x2F;xkbswitch&lt;&#x2F;code&gt; 复制到 &lt;code&gt;$PATH&lt;&#x2F;code&gt; 路径即可，也可以不复制仓库，直接运行 &lt;code&gt;curl -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;xkbswitch https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;myshov&#x2F;xkbswitch-macosx&#x2F;master&#x2F;bin&#x2F;xkbswitch&lt;&#x2F;code&gt; 。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;apple-silicon&quot;&gt;Apple Silicon&lt;&#x2F;h3&gt;
&lt;p&gt;需要将仓库 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;xiehuc&#x2F;xkbswitch-macosx&quot;&gt;xiehuc&#x2F;xkbswitch-macosx&lt;&#x2F;a&gt; 复制下来，然后运行 &lt;code&gt;make&lt;&#x2F;code&gt; ，接着将对应的克制文件同样的复制到 &lt;code&gt;$PATH&lt;&#x2F;code&gt; 即可，这个仓库是 [myshov&#x2F;xkbswitch-macosx] 的 Fork 专门为了兼容 Apple Silicon 。
具体步骤：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;git&lt;&#x2F;span&gt;&lt;span&gt; clone https:&#x2F;&#x2F;github.com&#x2F;xiehuc&#x2F;xkbswitch-macosx.git
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;cd&lt;&#x2F;span&gt;&lt;span&gt; xkbswitch-macosx
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;make
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;cp&lt;&#x2F;span&gt;&lt;span&gt; xkbswitch &#x2F;usr&#x2F;local&#x2F;bin&#x2F;xkbswitch
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;只执行 &lt;code&gt;make&lt;&#x2F;code&gt; 会生成包含 x86 和 arm 的通用可执行文件，可以执行 &lt;code&gt;make xkbswitch-x86&lt;&#x2F;code&gt; 或执行 &lt;code&gt;xkbswitch-arm&lt;&#x2F;code&gt; 单独生成对应架构的可执行文件。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;an-zhuang-rlue-vim-barbaric-cha-jian&quot;&gt;安装 rlue&#x2F;vim-barbaric 插件&lt;&#x2F;h2&gt;
&lt;p&gt;我是使用 Lazy.nvim 安装的，具体如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;lua&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-lua &quot;&gt;&lt;code class=&quot;language-lua&quot; data-lang=&quot;lua&quot;&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;  &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;rlue&#x2F;vim-barbaric&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;},
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;对于我的需求，简单这样安装之后即可，安装之后完成了这篇记录内容，使用体验良好，唯一需要注意的是在切换模式后不能非常快的输入按键，因为插件切换输入法到输入法完成切换是存在一点延时的，不过这个问题很轻微，我仅仅遇到一次，即使是遇到的一次也对使用几乎没有任何影响。
在插件的介绍页面，对于配置插件使用的是 Vim Scipt 的语法，如果需要进一步配置，那么可以参考如下的方法对应设置：
&lt;code&gt;let g:barbaric_ime = &#x27;fcitx&#x27;&lt;&#x2F;code&gt; -&amp;gt; &lt;code&gt;vim.g.barbaric_ime = &#x27;fcitx&#x27;&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;lian-jie&quot;&gt;链接&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;jdhao.github.io&#x2F;2021&#x2F;02&#x2F;25&#x2F;nvim_ime_mode_auto_switch&quot;&gt;如何让 Neovim 中文输入时自动切换输入法&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>初试 Neorg</title>
        <published>2024-05-25T18:22:20+00:00</published>
        <updated>2024-05-25T23:10:39+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/trying-neorg/"/>
        <id>https://ghost.livexia.xyz/trying-neorg/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/trying-neorg/">&lt;p&gt;初次尝试 Neorg ，如果顺利预计替换 Notion&lt;&#x2F;p&gt;
&lt;h2 id=&quot;an-zhuang-neorg&quot;&gt;安装 Neorg&lt;&#x2F;h2&gt;
&lt;p&gt;根据官方文档，在macOS 下通过 lazy.vim [安装 Neorg] ，初次启动 nvim 后发现 nvim-treesitter 会自动安装 norg 的 parser ，安装过程中会报编译错误，大概错误是说使用的 cc 编译器不支持 C++11 ，目前 Neorg 已经解决了这个问题，具体见 [fix: TSInstall issues on macOS, hopefully once and for good] ，大致思路就是忽略 TS 的报错，进入 nvim 后手动运行 &lt;code&gt;:Neorg sync-parsers&lt;&#x2F;code&gt; 让 Neorg 来安装 parser 即可。
&lt;del&gt;设置 treesitter 不自动安装 norg parser ，在 lunarvim 的 config.lua 文件中增加 &lt;code&gt;lvim.builtin.treesitter.ignore_install = { &quot;norg&quot; \}&lt;&#x2F;code&gt;&lt;&#x2F;del&gt; 不知道是我设置的问题，总之这个方法并不成功，依旧会尝试安装 norg parser ，最后还是通过官方的方法解决的。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;pei-zhi-neorg-qi-yong-concealer&quot;&gt;配置 Neorg&#x2F;启用 Concealer&lt;&#x2F;h2&gt;
&lt;p&gt;Neorg 的配置是递归的，在 Lazy 的安装配置中修改 config 的值为函数，然后在 load 中增加需要加载的模块，比如要使用 cincealer 那就要 load 的值就应该为：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;lua&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-lua &quot;&gt;&lt;code class=&quot;language-lua&quot; data-lang=&quot;lua&quot;&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;load &lt;&#x2F;span&gt;&lt;span&gt;= {
&lt;&#x2F;span&gt;&lt;span&gt;    [&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;core.defaults&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;] = {},
&lt;&#x2F;span&gt;&lt;span&gt;    [&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;core.concealer&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;] = {},
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;然后如果要对 concealer 模块进行进一步的设置就要在对于模块中增加 config table ，具体需要配置的选项可以在 Neorg 的 wiki 中的具体模块确认，具体可参考 [Setup Guide]。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zi-dong-sheng-cheng-yuan-shu-ju-summary&quot;&gt;自动生成元数据&#x2F;summary&lt;&#x2F;h2&gt;
&lt;p&gt;运行 &lt;code&gt;:Neorg inject-metadata&lt;&#x2F;code&gt; 即可在 norg 文件的顶部生成元数据，具体可见 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;nvim-neorg&#x2F;neorg&#x2F;wiki&#x2F;Metagen&quot;&gt;metagen&lt;&#x2F;a&gt; 。
在配置文件中加载 &lt;code&gt;core.summary&lt;&#x2F;code&gt; 模块，还可以根据 norg 文件生成工作区间的所有链接，可以有效的减少手动在 index.norg 文件中增加一条一条的链接，加载后运行命令 &lt;code&gt;:Neorg generate-workspace-summary&lt;&#x2F;code&gt; 即可在 index 的 heading 下生成，目前我还没找到特别有效的可以自动更新生成结果的方法，具体可见 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;nvim-neorg&#x2F;neorg&#x2F;wiki&#x2F;Summary&quot;&gt;summary&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dao-chu-wei-markdown&quot;&gt;导出为 markdown&lt;&#x2F;h2&gt;
&lt;p&gt;平时在 Notion 上记录之后，如果觉得需要放到个人博客上，往往我需要将内容复制导出为 markdown 文件，然后手动增加元数据，如果要迁移到 Neorg 那么导出为 markdown 格式也是很重要的功能。
直接使用 &lt;code&gt;core.export.markdown&lt;&#x2F;code&gt; 导出即可，在配置中增加 &lt;code&gt;extensions = &quot;all&quot;&lt;&#x2F;code&gt; ，就可以实现包括 Neorg 生成的元数据导出，具体在导出时需要 nvim 中运行 &lt;code&gt;:Neorg export to-file&lt;&#x2F;code&gt;，具体可见 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;nvim-neorg&#x2F;neorg&#x2F;wiki&#x2F;Exporting-Files&quot;&gt;Exporting Files&lt;&#x2F;a&gt; 。
同时我个人使用的博客框架是 zola ，而 zola 需要的 markdown 文件内要包含 &lt;a href=&quot;https:&#x2F;&#x2F;www.getzola.org&#x2F;documentation&#x2F;content&#x2F;page&#x2F;#front-matter&quot;&gt;Front matter&lt;&#x2F;a&gt; ，虽然 zola 推荐这个数据采用 TOML 的格式，但是也支持 YAML 格式，而 Neorg 导出后的元数据正是 YAML 格式，所以只需要很小的改动即可快速的将内容修改至兼容 zola 的格式，其中不同的数据内容理论上可以自动化实现。
虽然相比 Notion 好像是更加方便了，但是因为使用了类似 Anchor 的功能，在导出 markdown 和 zola 构建的过程中，依旧会出现不兼容的情况，markdown 的内部锚点链接不支持中文。而对于 Neorg 简化的锚点链接（只需要在 [] 中输入完整的链接名称即可，会调转到那个完整的链接位置），markdown 好像并不支持，目前这两个问题只能暂时规避。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;yi-xie-wen-ti&quot;&gt;一些问题&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;strikethrough-xuan-ran-bu-cheng-gong&quot;&gt;strikethrough 渲染不成功&lt;&#x2F;h3&gt;
&lt;p&gt;macOS 上我使用的是 iTerm2 在模拟终端中是可以渲染删除线的，但是在 neovim 和 lunarvim 中删除线均不能正常显示，通过修改 term.info 即可实现正常渲染删除线，具体可见&lt;a href=&quot;https:&#x2F;&#x2F;ghost.livexia.xyz&#x2F;trying-neorg&#x2F;#shan-chu-xian-xuan-ran&quot;&gt;删除线渲染&lt;&#x2F;a&gt;。
终端中运行 &lt;code&gt;infocmp $TERM &amp;gt; myterm.info&lt;&#x2F;code&gt; 生成当前终端的信息，然后在 myterm.info 文件末尾加上 &lt;code&gt;smxx=E[9m, rmxx=E[29m,&lt;&#x2F;code&gt; ，最后运行 &lt;code&gt;tic -x myterm.info&lt;&#x2F;code&gt; 将修改后的终端信息写入数据库，具体可见 [Add strikethrough support in terminal] 。
虽然解决了不渲染的问题，但是底层的根本原因我并未弄清楚，留待以后学习吧。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;lian-jie-concealer-xuan-ran&quot;&gt;链接 Concealer 渲染&lt;&#x2F;h3&gt;
&lt;p&gt;默认 &lt;code&gt;conceallevel&lt;&#x2F;code&gt; 为 0 ，设置 conceallevel 为 2 即可实现链接渲染，通过新增文件 &lt;code&gt;~&#x2F;.config&#x2F;lvim&#x2F;after&#x2F;ftplugin&#x2F;norg.lua&lt;&#x2F;code&gt;，并在其中添加 &lt;code&gt;vim.opt_local.conceallevel = 2&lt;&#x2F;code&gt; 实现只针对 norg 文件设置 conceallevel ，具体可见 &lt;code&gt;:h conceallevel&lt;&#x2F;code&gt; 。
链接渲染成功，但是在开启自动换行（line wrap）后出现了大段的空白，这是一个 vim&#x2F;neovim 的遗留问题，目前并没有任何可靠的修复，Neorg 官方给出了一些解决方案但都不完美，具体见 [Ugly line wraps when concealing text]。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;qi-guai-de-zhe-die-biao-xian&quot;&gt;奇怪的折叠表现&lt;&#x2F;h3&gt;
&lt;p&gt;当我第一次使用 nvim 打开文本的时候，折叠并不会发生，但是如果此时再打开一个新的文件，那么折叠就发生了，而且不限制文件类型，例如我第一次打开一个 norg 文件，然后再窗口内打开 lvim 的配置文件 config.lua ，此时这个配置文件就发生了折叠。在 Neorg 的 core.concealer 的配置中设置 folds 为 false 貌似解决了这个问题，因为我并不怎么需要使用折叠，所以目前这个解决方案还行。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zhong-wen-shu-ru-fa-zi-dong-qie-huan&quot;&gt;&lt;del&gt;中文输入法自动切换&lt;&#x2F;del&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;作为文字记录的工具，对于本地输入法的支持就显得尤为重要，这个部分的记录就单独的放在另外的记录中。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jie-lun&quot;&gt;结论&lt;&#x2F;h2&gt;
&lt;p&gt;目前我的 Neorg 体验并不完美，官方的文档显得有些杂乱，仓库内容也很分散，导致在查找的时候要多方搜索，配置 Neorg 最好的地方是在 Neorg 仓库的 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;nvim-neorg&#x2F;neorg&#x2F;wiki&quot;&gt;wiki&lt;&#x2F;a&gt; ，需确认 Neorg 语法最好的是直接在 nvim 中运行 &lt;code&gt;:h neorg&lt;&#x2F;code&gt; 其中也有指向 norg spec 的仓库，然后还有一个非官方的 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;pysan3&#x2F;Norg-Tutorial&quot;&gt;Tutorial&lt;&#x2F;a&gt; 仓库，最后就是作者的 &lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=NnmRVY22Lq8&amp;amp;list=PLx2ksyallYzVI8CN1JMXhEf62j2AijeDa&amp;amp;index=1&quot;&gt;YouTube 视频系列&lt;&#x2F;a&gt; 。即使是不完美的 Neorg 也让我想要将所有 Notion 中的内容进行迁移，Notion 引入了大量的 AI 功能，然后在网速不佳的情况下使用体验实在是太差了，更别提 Notion 的性能了，在我看来 Notion 的缺点远远 Neorg 的缺点，接下来就是慢慢的将 Notion 中的内容逐步进行迁移，并逐渐的扩展 Neorg 和 Neovim 的知识体系。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;pei-zhi-lazy-vim&quot;&gt;配置（lazy.vim）&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;lua&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-lua &quot;&gt;&lt;code class=&quot;language-lua&quot; data-lang=&quot;lua&quot;&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;nvim-neorg&#x2F;neorg&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;dependencies &lt;&#x2F;span&gt;&lt;span&gt;= { &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;luarocks.nvim&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; },
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;lazy &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;false&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- Disable lazy loading as some `lazy.nvim` distributions set `lazy = true` by default
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;version &lt;&#x2F;span&gt;&lt;span&gt;= &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- Pin Neorg to the latest stable release
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;config &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;function&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- setting up Neorg
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;require&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;neorg&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;setup &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;load &lt;&#x2F;span&gt;&lt;span&gt;= {
&lt;&#x2F;span&gt;&lt;span&gt;                [&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;core.defaults&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;] = {},
&lt;&#x2F;span&gt;&lt;span&gt;                [&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;core.concealer&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;] = {
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;config &lt;&#x2F;span&gt;&lt;span&gt;= {
&lt;&#x2F;span&gt;&lt;span&gt;                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;folds &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;false&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;icon_preset &lt;&#x2F;span&gt;&lt;span&gt;= &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;diamond&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;                    },
&lt;&#x2F;span&gt;&lt;span&gt;                },
&lt;&#x2F;span&gt;&lt;span&gt;                [&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;core.export&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;] = {},
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;                [&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;core.completion&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;] = {
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;config &lt;&#x2F;span&gt;&lt;span&gt;= {
&lt;&#x2F;span&gt;&lt;span&gt;                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;engine &lt;&#x2F;span&gt;&lt;span&gt;= &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;nvim-cmp&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;                    },
&lt;&#x2F;span&gt;&lt;span&gt;                },
&lt;&#x2F;span&gt;&lt;span&gt;                [&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;core.summary&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;] = {},
&lt;&#x2F;span&gt;&lt;span&gt;                [&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;core.esupports.indent&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;] = {
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;config &lt;&#x2F;span&gt;&lt;span&gt;= {
&lt;&#x2F;span&gt;&lt;span&gt;                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;format_on_enter &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;format_on_escape &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;                    },
&lt;&#x2F;span&gt;&lt;span&gt;                },
&lt;&#x2F;span&gt;&lt;span&gt;                [&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;core.export.markdown&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;] = {
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;config &lt;&#x2F;span&gt;&lt;span&gt;= {
&lt;&#x2F;span&gt;&lt;span&gt;                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;extensions &lt;&#x2F;span&gt;&lt;span&gt;= &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;all&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;                    },
&lt;&#x2F;span&gt;&lt;span&gt;                },
&lt;&#x2F;span&gt;&lt;span&gt;            },
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;end&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- fix: TS error see: https:&#x2F;&#x2F;github.com&#x2F;nvim-neorg&#x2F;neorg&#x2F;pull&#x2F;891
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- ignore the TS error and run `:Neorg sync-parsers` inside nvim
&lt;&#x2F;span&gt;&lt;span&gt;},
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;links&quot;&gt;Links&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;an-zhuang&quot;&gt;安装&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;nvim-neorg&#x2F;neorg?tab=readme-ov-file#lazynvim&quot;&gt;Installation&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;nvim-neorg&#x2F;neorg&#x2F;pull&#x2F;891&quot;&gt;fix: TSInstall issues on macOS, hopefully once and for good&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;pei-zhi&quot;&gt;配置&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;nvim-neorg&#x2F;neorg&#x2F;wiki&#x2F;Setup-Guide&quot;&gt;Setup Guide&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;line-wrap-with-concealer&quot;&gt;line wrap with concealer&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;nvim-neorg&#x2F;neorg&#x2F;wiki&#x2F;Dependencies#ugly-line-wraps-when-concealing-text&quot;&gt;Ugly line wraps when concealing text&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;shan-chu-xian-xuan-ran&quot;&gt;删除线渲染&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;neovim&#x2F;neovim&#x2F;discussions&#x2F;24346&quot;&gt;Why the strikethrough mark can&#x27;t be rendered?&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;neovim&#x2F;neovim&#x2F;issues&#x2F;3436&quot;&gt;Add strikethrough support in terminal&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;nvim-neorg&#x2F;neorg&#x2F;discussions&#x2F;755#discussioncomment-5052354&quot;&gt;strikethrough does&#x27;t work&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>修复 zsh 启动缓慢</title>
        <published>2024-01-23T00:00:00+00:00</published>
        <updated>2024-01-23T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/fix-zsh-start-slow/"/>
        <id>https://ghost.livexia.xyz/fix-zsh-start-slow/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/fix-zsh-start-slow/">&lt;p&gt;tl;dr: 终端启动缓慢，实际上是 &lt;code&gt;zsh&lt;&#x2F;code&gt; 启动缓慢，通过使用 &lt;code&gt;zprof&lt;&#x2F;code&gt; 确定问题来自 &lt;code&gt;nvm&lt;&#x2F;code&gt; 的初始化，利用 oh-my-zsh 插件实现 &lt;code&gt;nvm&lt;&#x2F;code&gt; 只在使用时进行初始化。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;qi-yin&quot;&gt;起因&lt;&#x2F;h2&gt;
&lt;p&gt;主要使用的环境有 3 个，两个 Linux 一个 MacOS，自己从大学开始就在用 oh-my-zsh ，长久以来都是如此。不知道从何时开始启动终端就特别的缓慢，特别是在 Linux 的环境上，因为 Linux 环境上我用的是 Alacritty 而 MacOS 上用的则是 iterm2 ，所以最初我以为是终端的问题，因为问题并不是很大，特别是涉及到的两个环境的机器并不高，所以我并没有想要查清问题。昨天晚上太冷了，在冰冷的笔记本上等待终端启动让我觉得很有必要解决这个问题。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;que-ding-wen-ti&quot;&gt;确定问题&lt;&#x2F;h2&gt;
&lt;p&gt;终端启动缓慢有两种可能：一是终端模拟器启动缓慢，二是 &lt;code&gt;zsh&lt;&#x2F;code&gt; 启动缓慢。当前点击 Alacritty 时，终端窗口出现并不慢，而 shell 环境仍未出现，所以更可能是 &lt;code&gt;zsh&lt;&#x2F;code&gt; 的问题。通过启动系统自带的终端模拟器，发现启动依旧缓慢，所以并不是终端模拟器的问题。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zsh-de-qi-dong-shi-jian&quot;&gt;zsh 的启动时间&lt;&#x2F;h3&gt;
&lt;p&gt;使用 &lt;code&gt;time&lt;&#x2F;code&gt; 命令测试 &lt;code&gt;zsh&lt;&#x2F;code&gt; 启动时间 &lt;code&gt;time zsh -i -c exit&lt;&#x2F;code&gt; 命令会在启动 &lt;code&gt;zsh&lt;&#x2F;code&gt; 后立即退出，所以可以估算 &lt;code&gt;zsh&lt;&#x2F;code&gt; 的启动时间，运行结果为 &lt;code&gt;zsh -i -c exit  0.95s user 1.26s system 106% cpu 2.075 total&lt;&#x2F;code&gt; 可见启动时间在一秒左右，这是很明显感到启动缓慢的原因。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;qi-yong-zsh-profiling&quot;&gt;启用 zsh profiling&lt;&#x2F;h3&gt;
&lt;p&gt;参考 &lt;a href=&quot;https:&#x2F;&#x2F;pickard.cc&#x2F;posts&#x2F;why-does-zsh-start-slowly&#x2F;&quot;&gt;why does zsh start so slowly?&lt;&#x2F;a&gt; 和 &lt;a href=&quot;https:&#x2F;&#x2F;stevenvanbael.com&#x2F;profiling-zsh-startup&quot;&gt;Profiling zsh startup time&lt;&#x2F;a&gt; 对 &lt;code&gt;zsh&lt;&#x2F;code&gt; 的启动进行采样，具体操作是在 &lt;code&gt;~&#x2F;. zshrc&lt;&#x2F;code&gt; 的顶部增加 &lt;code&gt;zmodload zsh&#x2F;zprof&lt;&#x2F;code&gt; 和在最底部增加 &lt;code&gt;zprof&lt;&#x2F;code&gt; ，然后重新启动 &lt;code&gt;zsh&lt;&#x2F;code&gt; 即可取得 profiling 的结果。&lt;&#x2F;p&gt;
&lt;p&gt;重启 &lt;code&gt;zsh&lt;&#x2F;code&gt; 后取得 profiling 结果如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;num&lt;&#x2F;span&gt;&lt;span&gt;  calls                time                       self            name
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;-----------------------------------------------------------------------------------
&lt;&#x2F;span&gt;&lt;span&gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;         804.38   804.38   89.73%    436.31   436.31   48.67%  nvm_auto
&lt;&#x2F;span&gt;&lt;span&gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;         368.07   184.03   41.06%    206.64   103.32   23.05%  nvm
&lt;&#x2F;span&gt;&lt;span&gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;         146.69   146.69   16.36%    122.63   122.63   13.68%  nvm_ensure_version_installed
&lt;&#x2F;span&gt;&lt;span&gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;)   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;21&lt;&#x2F;span&gt;&lt;span&gt;          43.31     2.06    4.83%     34.24     1.63    3.82%  _omz_source
&lt;&#x2F;span&gt;&lt;span&gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;          24.06    24.06    2.68%     24.06    24.06    2.68%  nvm_is_version_installed
&lt;&#x2F;span&gt;&lt;span&gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;6&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;          21.35    10.68    2.38%     21.35    10.68    2.38%  compaudit
&lt;&#x2F;span&gt;&lt;span&gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;7&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;          14.63    14.63    1.63%     14.47    14.47    1.61%  nvm_die_on_prefix
&lt;&#x2F;span&gt;&lt;span&gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;          11.41    11.41    1.27%     11.41    11.41    1.27%  (anon) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;[&#x2F;home&#x2F;livexia&#x2F;.oh-my-zsh&#x2F;tools&#x2F;check_for_upgrade.sh:155]
&lt;&#x2F;span&gt;&lt;span&gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;9&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;           8.27     8.27    0.92%      8.27     8.27    0.92%  zrecompile
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;          25.99    25.99    2.90%      4.64     4.64    0.52%  compinit
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;11&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;          13.74    13.74    1.53%      2.33     2.33    0.26%  handle_update
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;12&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;           1.91     1.91    0.21%      1.91     1.91    0.21%  test-ls-args
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;13&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;           1.88     0.38    0.21%      1.88     0.38    0.21%  add-zsh-hook
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;14&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;           1.86     1.86    0.21%      1.86     1.86    0.21%  colors
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;15&lt;&#x2F;span&gt;&lt;span&gt;)   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;13&lt;&#x2F;span&gt;&lt;span&gt;           1.54     0.12    0.17%      1.54     0.12    0.17%  compdef
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;16&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;           1.15     0.23    0.13%      1.15     0.23    0.13%  is-at-least
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;17&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;           1.05     1.05    0.12%      1.05     1.05    0.12%  regexp-replace
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;18&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;           0.16     0.04    0.02%      0.16     0.04    0.02%  nvm_npmrc_bad_news_bears
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;19&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;           0.28     0.28    0.03%      0.13     0.13    0.01%  complete
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;20&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;           0.11     0.11    0.01%      0.11     0.11    0.01%  nvm_has
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;21&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;           0.08     0.04    0.01%      0.08     0.04    0.01%  is_plugin
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;22&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;           0.08     0.03    0.01%      0.08     0.03    0.01%  is_theme
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;23&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;           0.06     0.03    0.01%      0.06     0.03    0.01%  bashcompinit
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;24&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;         804.43   804.43   89.73%      0.05     0.05    0.01%  nvm_process_parameters
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;25&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;           0.05     0.02    0.01%      0.05     0.02    0.01%  env_default
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;26&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;           0.01     0.01    0.00%      0.01     0.01    0.00%  nvm_is_zsh
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;根据结果可见&lt;strong&gt;启动过程中因为 &lt;code&gt;nvm&lt;&#x2F;code&gt; 而花费了大量的时间&lt;&#x2F;strong&gt;，并不是很多人遇见的因为 &lt;code&gt;compinit&lt;&#x2F;code&gt; 而导致的启动缓慢，例如 &lt;a href=&quot;https:&#x2F;&#x2F;superuser.com&#x2F;questions&#x2F;236953&#x2F;zsh-starts-incredibly-slowly&quot;&gt;zsh starts incredibly slowly&lt;&#x2F;a&gt; 中的题主。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jie-jue-yin-wei-nvm-dao-zhi-de-qi-dong-huan-man&quot;&gt;解决因为 &lt;code&gt;nvm&lt;&#x2F;code&gt; 导致的启动缓慢&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;code&gt;~&#x2F;.zshrc&lt;&#x2F;code&gt; 文件中涉及 &lt;code&gt;nvm&lt;&#x2F;code&gt; 的部分如下，主要是设定 &lt;code&gt;nvm&lt;&#x2F;code&gt; 主目录，然后加载 &lt;code&gt;nvm&lt;&#x2F;code&gt; ，最后加载 &lt;code&gt;nvm&lt;&#x2F;code&gt; 的 &lt;code&gt;shell&lt;&#x2F;code&gt; 补全，这样三个部分就导致了 &lt;code&gt;zsh&lt;&#x2F;code&gt; 的启动缓慢&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;export &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;NVM_DIR&lt;&#x2F;span&gt;&lt;span&gt;=&amp;quot;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;HOME&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;.config&#x2F;nvm&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;[ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;-s &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;NVM_DIR&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;nvm.sh&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;] &lt;&#x2F;span&gt;&lt;span&gt;&amp;amp;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\. &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;NVM_DIR&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;nvm.sh&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# This loads nvm
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;[ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;-s &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;NVM_DIR&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;bash_completion&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;] &lt;&#x2F;span&gt;&lt;span&gt;&amp;amp;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\. &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;NVM_DIR&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;bash_completion&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# This loads nvm bash_completion
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;nvm&lt;&#x2F;code&gt; 是 Nodejs 的版本管理器，我实际上并不直接使用 Nodejs ，但是在 LunarVim 中安装插件需要，所以直接删除 &lt;code&gt;~&#x2F;.zshrc&lt;&#x2F;code&gt; 中涉及 nvm 的部分可能会导致问题。&lt;&#x2F;p&gt;
&lt;p&gt;在搜索过程中发现通过跳过初始化 &lt;code&gt;zsh&lt;&#x2F;code&gt; 时跳过加载 &lt;code&gt;nvm&lt;&#x2F;code&gt; 解决的&lt;a href=&quot;https:&#x2F;&#x2F;superuser.com&#x2F;a&#x2F;1611283&quot;&gt;方法&lt;&#x2F;a&gt;，这个方法通过设置别名只在运行 &lt;code&gt;nvm&lt;&#x2F;code&gt; 时进行加载，这个方法无法实现在使用 &lt;code&gt;node&lt;&#x2F;code&gt; 或 &lt;code&gt;npm&lt;&#x2F;code&gt; 以及一系列其他程序时自动加载 &lt;code&gt;nvm&lt;&#x2F;code&gt;。但是后续发现了更好的解决方法，那就是通过使用 oh-my-zsh 的 &lt;code&gt;nvm&lt;&#x2F;code&gt; 插件实现类似的方法，只在需要时初始化 &lt;code&gt;nvm&lt;&#x2F;code&gt; 。&lt;&#x2F;p&gt;
&lt;p&gt;根据 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ohmyzsh&#x2F;ohmyzsh&#x2F;tree&#x2F;master&#x2F;plugins&#x2F;nvm&quot;&gt;nvm plugin&lt;&#x2F;a&gt; 在 &lt;code&gt;~&#x2F;.zshrc&lt;&#x2F;code&gt; 中启用 &lt;code&gt;nvm&lt;&#x2F;code&gt; 插件，然后设置 &lt;code&gt;nvm&lt;&#x2F;code&gt; 启动状态为 &lt;code&gt;lazy&lt;&#x2F;code&gt; 。&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;启用 &lt;code&gt;nvm&lt;&#x2F;code&gt; 插件 &lt;code&gt;plugins=(... nvm)&lt;&#x2F;code&gt; ，在 &lt;code&gt;~&#x2F;.zshrc&lt;&#x2F;code&gt; 文件中搜索 &lt;code&gt;plugins&lt;&#x2F;code&gt; 可以发现默认就启用了 &lt;code&gt;git&lt;&#x2F;code&gt; 插件，所以直接在原有的基础上增加 &lt;code&gt;nvm&lt;&#x2F;code&gt; 即可，直接加上文档中的 &lt;code&gt;plugins=(... nvm)&lt;&#x2F;code&gt; 这一句会覆盖 &lt;code&gt;git&lt;&#x2F;code&gt; 插件。例如 &lt;code&gt;plugins=(git nvm)&lt;&#x2F;code&gt;****&lt;&#x2F;li&gt;
&lt;li&gt;在 &lt;code&gt;~&#x2F;.zshrc&lt;&#x2F;code&gt; 中增加 &lt;code&gt;zstyle &#x27;:omz:plugins:nvm&#x27; lazy yes&lt;&#x2F;code&gt; 实现只有在需要时才加载 &lt;code&gt;nvm&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;删除 &lt;code&gt;~&#x2F;.zshrc&lt;&#x2F;code&gt; 中原有的两行加载 nvm 和 nvm shell 补全的部分，要保留设定 nvm 目录的部分，因为 &lt;code&gt;nvm&lt;&#x2F;code&gt; 插件默认 &lt;code&gt;~&#x2F;.nvm&lt;&#x2F;code&gt; 为主目录，具体可见 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ohmyzsh&#x2F;ohmyzsh&#x2F;tree&#x2F;master&#x2F;plugins&#x2F;nvm#settings&quot;&gt;nvm&#x2F;settings&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;最初这么操作之后，发现启动中依旧加载了 &lt;code&gt;nvm&lt;&#x2F;code&gt; ，的确 &lt;code&gt;nvm&lt;&#x2F;code&gt; 插件替换了 &lt;code&gt;nvm&lt;&#x2F;code&gt; 的两条初始化语句，但是在 profiling 中依旧加载了 &lt;code&gt;nvm&lt;&#x2F;code&gt; ，也就是说 &lt;code&gt;nvm&lt;&#x2F;code&gt; 依旧在 &lt;code&gt;zsh&lt;&#x2F;code&gt; 初始化时启动了。&lt;&#x2F;p&gt;
&lt;p&gt;测试后发现 &lt;code&gt;plugins=(git nvm)&lt;&#x2F;code&gt; 和 &lt;code&gt;zstyle &#x27;:omz:plugins:nvm&#x27; lazy yes&lt;&#x2F;code&gt; 的语句顺序导致了这样的问题，&lt;code&gt;zstyle &#x27;:omz:plugins:nvm&#x27; lazy yes&lt;&#x2F;code&gt; 要在 &lt;code&gt;plugins=(git nvm)&lt;&#x2F;code&gt; 之前，否则 &lt;code&gt;zsh&lt;&#x2F;code&gt; 依旧会自动初始化 &lt;code&gt;nvm&lt;&#x2F;code&gt; 。正确的是在 &lt;code&gt;~&#x2F;.zshrc&lt;&#x2F;code&gt; 最初位置就设定 &lt;code&gt;nvm&lt;&#x2F;code&gt; 主目录和增加 &lt;code&gt;zstyle &#x27;:omz:plugins:nvm&#x27; lazy yes&lt;&#x2F;code&gt; ，&lt;code&gt;~&#x2F;.zshrc&lt;&#x2F;code&gt; 头部示例如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# profiling zsh
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;zmodload&lt;&#x2F;span&gt;&lt;span&gt; zsh&#x2F;zprof
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# nvm lazy load
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;export &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;NVM_DIR&lt;&#x2F;span&gt;&lt;span&gt;=&amp;quot;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;HOME&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;.config&#x2F;nvm&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;zstyle &lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:omz:plugins:nvm&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39; lazy yes
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;bu-cheng-gong-de-chang-shi&quot;&gt;不成功的尝试&lt;&#x2F;h3&gt;
&lt;p&gt;上面的方法可以实现预期，但是分离了配置，一般来说我喜欢将新增&#x2F;修改的配置放在配置文件的末尾，这个方法对配置进行了分裂。&lt;code&gt;plugins&lt;&#x2F;code&gt; 是 &lt;code&gt;bash&lt;&#x2F;code&gt; 的 &lt;code&gt;array&lt;&#x2F;code&gt; 数据类型，应该可以通过附加操作增加元素，因为 &lt;code&gt;zstyle&lt;&#x2F;code&gt; 设置 &lt;code&gt;nvm&lt;&#x2F;code&gt; 插件语句只需要在插件启用之前之前即可。所以可以将所有 &lt;code&gt;nvm&lt;&#x2F;code&gt; 相关的语句集合在一起，同时可以在配置文件的最后实现 nvm 的按需加载。具体如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# nvm plugin lazy load
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;export &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;NVM_DIR&lt;&#x2F;span&gt;&lt;span&gt;=&amp;quot;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;HOME&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;.config&#x2F;nvm&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;zstyle &lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:omz:plugins:nvm&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39; lazy yes
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;plugins&lt;&#x2F;span&gt;&lt;span&gt;+=(nvm)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;但是这个方法依旧存在问题，&lt;code&gt;plugins&lt;&#x2F;code&gt; 需要在 &lt;code&gt;source $ZSH&#x2F;oh-my-zsh.sh&lt;&#x2F;code&gt; 之前进行设置，如果放在配置文件末尾，将导致 &lt;code&gt;nvm&lt;&#x2F;code&gt; 不可用。所以我希望将所有新增配置都放在配置文件末尾的希望落空了，最后仍旧是按照最初的方式，将设置 &lt;code&gt;nvm&lt;&#x2F;code&gt; 主目录和 &lt;code&gt;zstyle&lt;&#x2F;code&gt; 设置 &lt;code&gt;nvm&lt;&#x2F;code&gt; 插插件的语句放在配置文件的头部，同时新增 &lt;code&gt;plugins&lt;&#x2F;code&gt; 变量为 &lt;code&gt;plugins=(git nvm)&lt;&#x2F;code&gt; 。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;que-ding-nvm-ke-yong&quot;&gt;确定 &lt;code&gt;nvm&lt;&#x2F;code&gt; 可用&lt;&#x2F;h3&gt;
&lt;p&gt;使用 &lt;code&gt;nvm&lt;&#x2F;code&gt; 插进后运行 &lt;code&gt;nvm&lt;&#x2F;code&gt; &lt;code&gt;node&lt;&#x2F;code&gt; 或者 &lt;code&gt;npm&lt;&#x2F;code&gt; 都可以成功，同时启动终端模拟器和 zsh 几乎是瞬时的，毫无停滞的感觉。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zai-ci-ce-shi&quot;&gt;再次测试&lt;&#x2F;h2&gt;
&lt;p&gt;再次 profiling 结果如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;❯&lt;&#x2F;span&gt;&lt;span&gt; zsh
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;num&lt;&#x2F;span&gt;&lt;span&gt;  calls                time                       self            name
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;-----------------------------------------------------------------------------------
&lt;&#x2F;span&gt;&lt;span&gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;21&lt;&#x2F;span&gt;&lt;span&gt;          31.85     1.52   41.86%     24.68     1.18   32.44%  _omz_source
&lt;&#x2F;span&gt;&lt;span&gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;          24.05    12.02   31.60%     24.05    12.02   31.60%  compaudit
&lt;&#x2F;span&gt;&lt;span&gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;           8.25     8.25   10.85%      8.25     8.25   10.85%  (anon) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;[&#x2F;home&#x2F;livexia&#x2F;.oh-my-zsh&#x2F;tools&#x2F;check_for_upgrade.sh:155]
&lt;&#x2F;span&gt;&lt;span&gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;          29.06    29.06   38.20%      5.02     5.02    6.59%  compinit
&lt;&#x2F;span&gt;&lt;span&gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;           3.57     3.57    4.69%      3.57     3.57    4.69%  zrecompile
&lt;&#x2F;span&gt;&lt;span&gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;6&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;          11.15    11.15   14.66%      2.90     2.90    3.81%  handle_update
&lt;&#x2F;span&gt;&lt;span&gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;7&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;           1.97     1.97    2.59%      1.97     1.97    2.59%  test-ls-args
&lt;&#x2F;span&gt;&lt;span&gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;           1.25     0.25    1.64%      1.25     0.25    1.64%  add-zsh-hook
&lt;&#x2F;span&gt;&lt;span&gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;9&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;           1.22     1.22    1.61%      1.22     1.22    1.61%  colors
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span&gt;)   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;12&lt;&#x2F;span&gt;&lt;span&gt;           1.22     0.10    1.60%      1.22     0.10    1.60%  compdef
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;11&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;           1.13     0.23    1.48%      1.13     0.23    1.48%  is-at-least
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;12&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;           0.59     0.59    0.77%      0.59     0.59    0.77%  regexp-replace
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;13&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;           0.13     0.06    0.17%      0.13     0.06    0.17%  is_plugin
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;14&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;           0.08     0.03    0.10%      0.08     0.03    0.10%  is_theme
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;15&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;           0.03     0.01    0.04%      0.03     0.01    0.04%  env_default
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;16&lt;&#x2F;span&gt;&lt;span&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;           0.02     0.02    0.03%      0.02     0.02    0.03%  bashcompinit
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;禁用 profiling 测试启动时间：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;❯&lt;&#x2F;span&gt;&lt;span&gt; time zsh&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -i -c&lt;&#x2F;span&gt;&lt;span&gt; exit
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;zsh -i -c&lt;&#x2F;span&gt;&lt;span&gt; exit  0.19s user 0.22s system 117% cpu 0.348 total
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以发现启动时间从最初的 &lt;code&gt;2.075&lt;&#x2F;code&gt; 减少到 &lt;code&gt;0.348&lt;&#x2F;code&gt; ，实际的使用体验也反映了这一提升，终端启动几乎是即时没有延迟感。在我的 &lt;code&gt;~&#x2F;.zshrc&lt;&#x2F;code&gt; 文件中，除了初始化 &lt;code&gt;nvm&lt;&#x2F;code&gt; 还初始化了 &lt;code&gt;zoxide&lt;&#x2F;code&gt; &lt;code&gt;starship&lt;&#x2F;code&gt; 和 &lt;code&gt;pyenv&lt;&#x2F;code&gt; ，虽然在测试中并未发现这些初始化占用了大量的启动时间，但并不代表未来不会有这样的问题，后续再遇到也许也可以通过这个方法解决，使用插件。虽然在这些插件的页面并不涉及可能的加速方法，因此在此并不将原有初始化方法修改为使用配置。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;can-kao&quot;&gt;参考&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;dev.to&#x2F;thraizz&#x2F;fix-slow-zsh-startup-due-to-nvm-408k&quot;&gt;Fix slow ZSH startup due to NVM&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;pickard.cc&#x2F;posts&#x2F;why-does-zsh-start-slowly&#x2F;&quot;&gt;why does zsh start so slowly?&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;stevenvanbael.com&#x2F;profiling-zsh-startup&quot;&gt;Profiling zsh startup time&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;superuser.com&#x2F;questions&#x2F;236953&#x2F;zsh-starts-incredibly-slowly&quot;&gt;zsh starts incredibly slowly&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ohmyzsh&#x2F;ohmyzsh&#x2F;tree&#x2F;master&#x2F;plugins&#x2F;nvm&quot;&gt;nvm plugin&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ohmyzsh&#x2F;ohmyzsh&#x2F;wiki&#x2F;Plugins&quot;&gt;oh-my-zsh&#x2F;Plugins&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>ChromeOS&#x2F;Crostini 安装 mesa virtio-venus-experimental 驱动</title>
        <published>2024-01-17T00:00:00+00:00</published>
        <updated>2024-03-18T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/crostini-with-mesa-driver/"/>
        <id>https://ghost.livexia.xyz/crostini-with-mesa-driver/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/crostini-with-mesa-driver/">&lt;p&gt;tl;dr ：在 ChromeOS&#x2F;Crostini 容器中安装 mesa 驱动，实现 vulkan 在容器中的可用，手动编译安装成功，但 Steam&#x2F;Proton 游戏帧率提升不明显，ChromeOS&#x2F;Crostini 通过 Proton 运行游戏（The Conquest of Go）仍与 Linux 直接 Proton 运行有较大差距。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;qi-yin&quot;&gt;起因&lt;&#x2F;h2&gt;
&lt;p&gt;最近沉迷围棋，Steam 上的游戏 The Conquest of Go 很棒，所以想在每台电脑上都能玩，这个游戏本不需要性能非常好的电脑，这个游戏原生只支持 Windows 和 MacOS ，在 Linux 上运行需要依赖 Steam 的 Proton 运行，我手上的系统为 Fedora 39 的 Surface Go2 运行没问题，可以跑满 60 帧，为了省电运行在 20 帧运行也没问题，毕竟是围棋游戏。根据这一点，我觉得在 ChromeOS 上运行一定没问题，我这台 PixelBook Go 性能应该优于 Surface Go2 ，很可惜并不是这样，在 Crostini 中安装 Steam ，同样利用 Proton 运行游戏，结果不到 10FPS 这就不可玩了，我猜测是驱动的问题，谷歌官方虽然有在对更好的驱动进行试验，可是我的这台并不在测试名单中，具体见：&lt;strong&gt;&lt;a href=&quot;https:&#x2F;&#x2F;support.google.com&#x2F;chromebook&#x2F;answer&#x2F;14220699&quot;&gt;Play Steam for Chromebook（Beta 版）&lt;&#x2F;a&gt;&lt;&#x2F;strong&gt;，最初我也就放弃了，可惜日渐沉迷，于是又在网上查找可能的解决方法，以下就是我的搜索结果，通过安装 mesa 的测试驱动，实现更好的 Vulkan 支持，使得 Proton 可以通过 DXVK 将 d3d 9&#x2F;10&#x2F;11 的 api 转为 Vulkan 。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;yuan-jiao-cheng&quot;&gt;原教程&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;gist.github.com&#x2F;Usulyre&#x2F;bb33f77b225b8d9336c1f9e744114fba&quot;&gt;Debian Bullseye&lt;&#x2F;a&gt; 参与了后续讨论&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;old.reddit.com&#x2F;r&#x2F;chromeos&#x2F;comments&#x2F;uq13t0&#x2F;steam_gaming_by_vulkan_for_crostini_and_this&#x2F;&quot;&gt;Arch&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;初步阅读教程，可以发现大部分的操作并不太可能损害环境，所以我决定直接在原有环境上进行编译，而不新建容器，构建 Arch 虚拟机可能可以让整个流程加快，但是我还是喜欢用统一的环境。&lt;&#x2F;p&gt;
&lt;p&gt;初始时运行 &lt;code&gt;vulkaninfo&lt;&#x2F;code&gt; 和 &lt;code&gt;vkcube&lt;&#x2F;code&gt; 输出情况，可见是 CPU&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;❯ vulkaninfo | grep driverName
&lt;&#x2F;span&gt;&lt;span&gt;	driverName      = llvmpipe
&lt;&#x2F;span&gt;&lt;span&gt;	driverName                                           = llvmpipe
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;❯ vkcube
&lt;&#x2F;span&gt;&lt;span&gt;Selected GPU 0: llvmpipe (LLVM 15.0.6, 256 bits), type: Cpu
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;qian-zhi-tiao-jian-qi-yong-crostini&quot;&gt;前置条件，启用 crostini&lt;&#x2F;h2&gt;
&lt;p&gt;在 &lt;code&gt;chrome:&#x2F;&#x2F;flags&lt;&#x2F;code&gt; 中：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;使用最新版本的 Debian 我使用的是最新的 Bookworm &lt;code&gt;chrome:&#x2F;&#x2F;flags&#x2F;#crostini-container-install&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;启用 GPU 加速 &lt;code&gt;chrome:&#x2F;&#x2F;flags&#x2F;#crostini-gpu-support&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;ju-ti-cao-zuo&quot;&gt;具体操作&lt;&#x2F;h2&gt;
&lt;p&gt;关闭现有的容器（虚拟机），在 &lt;code&gt;crosh&lt;&#x2F;code&gt; （ctrl + alt + t） 中增加启用 GPU 参数启动容器环境，参数为 &lt;code&gt;--enable-vulkan&lt;&#x2F;code&gt; 例如 &lt;code&gt;vmc start --enable-vulkan termina&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;在 &lt;code&gt;&#x2F;etc&#x2F;apt&#x2F;sources.list&lt;&#x2F;code&gt; 增加源，并更新容器&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;增加源 &lt;code&gt;deb-src [arch=amd64,i386] http:&#x2F;&#x2F;deb.debian.org&#x2F;debian bookworm main&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;注意不需要增加 sid 的源&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;an-zhuang-bian-yi-qu-dong-xu-yao-de-yi-lai-la-qu-dai-ma&quot;&gt;安装编译驱动需要的依赖，拉取代码&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; apt-get build-dep mesa
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; apt-get install libunwind-dev
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; apt-get install libudev-dev
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;git&lt;&#x2F;span&gt;&lt;span&gt; clone https:&#x2F;&#x2F;gitlab.freedesktop.org&#x2F;mesa&#x2F;mesa.git
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;进入目录 &lt;code&gt;cd mesa&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;bian-yi-64-wei-qu-dong&quot;&gt;编译 64 位驱动&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;配置编译&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;meson&lt;&#x2F;span&gt;&lt;span&gt; setup build64&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --libdir&lt;&#x2F;span&gt;&lt;span&gt; &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;	-Ddri3&lt;&#x2F;span&gt;&lt;span&gt;=enabled                              \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;  -Dprefix&lt;&#x2F;span&gt;&lt;span&gt;=&#x2F;usr                               \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;  -Dglx&lt;&#x2F;span&gt;&lt;span&gt;=dri                                   \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;  -Degl&lt;&#x2F;span&gt;&lt;span&gt;=enabled                               \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;  -Dgbm&lt;&#x2F;span&gt;&lt;span&gt;=enabled                               \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;  -Dgallium-vdpau&lt;&#x2F;span&gt;&lt;span&gt;=disabled                    \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;  -Dvalgrind&lt;&#x2F;span&gt;&lt;span&gt;=disabled                         \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;  -Dgallium-drivers&lt;&#x2F;span&gt;&lt;span&gt;=virgl              \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;  -Dvulkan-drivers&lt;&#x2F;span&gt;&lt;span&gt;=virtio              \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;  -Dvulkan-layers&lt;&#x2F;span&gt;&lt;span&gt;=device-select
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;运行命令，未有明显错误输出。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;运行编译 &lt;code&gt;sudo ninja -C build64 install&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt; 。编译的时候，我这台无风扇的电脑 CPU 温度达到 75C 左右，还是比较吃性能和缓慢的，编译成功，在我的机器上运行了 15 分钟不到。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;bian-yi-32-wei-qu-dong-shi-qing-kuang-ke-tiao-guo&quot;&gt;编译 32 位驱动（视情况可跳过）&lt;&#x2F;h3&gt;
&lt;p&gt;并不确定 32 位驱动是否必要，因为在我编译失败后，检测的几个方法都正常通过，我测试的游戏也正确的运行在了 64 位驱动上，原作者也不确定 32 位驱动的必要性，我尝试找到解答，最终大概只能确定的是也许在一些 32 位的游戏上会需要 32 位的驱动，也许是 32 位的 wine 需要 32 位的驱动，所以如果确定自己运行的游戏是 64 位，同时 wine 是 64 位的（大部分新游戏都满足这两个条件），那么这一步实际上是可以跳过的。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;配置 gcc （March 18, 2024 更新）&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;新建文件夹 &lt;code&gt;mkdir -p ~&#x2F;.local&#x2F;share&#x2F;meson&#x2F;cross&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;新增文件 &lt;code&gt;~&#x2F;.local&#x2F;share&#x2F;meson&#x2F;cross&#x2F;gcc-i686&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;内容为：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;# gcc-i686
&lt;&#x2F;span&gt;&lt;span&gt;[binaries]
&lt;&#x2F;span&gt;&lt;span&gt;c = &amp;#39;&#x2F;usr&#x2F;bin&#x2F;gcc&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;cpp = &amp;#39;&#x2F;usr&#x2F;bin&#x2F;g++&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;ar = &amp;#39;&#x2F;usr&#x2F;bin&#x2F;gcc-ar&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;strip = &amp;#39;&#x2F;usr&#x2F;bin&#x2F;strip&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;pkg-config = &amp;#39;&#x2F;usr&#x2F;bin&#x2F;i686-linux-gnu-pkg-config&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;llvm-config = &amp;#39;&#x2F;usr&#x2F;bin&#x2F;llvm-config-15&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[built-in options]
&lt;&#x2F;span&gt;&lt;span&gt;c_args = [&amp;#39;-m32&amp;#39;]
&lt;&#x2F;span&gt;&lt;span&gt;c_link_args = [&amp;#39;-m32&amp;#39;]
&lt;&#x2F;span&gt;&lt;span&gt;cpp_args = [&amp;#39;-m32&amp;#39;]
&lt;&#x2F;span&gt;&lt;span&gt;cpp_link_args = [&amp;#39;-m32&amp;#39;]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[host_machine]
&lt;&#x2F;span&gt;&lt;span&gt;system = &amp;#39;linux&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;cpu_family = &amp;#39;x86&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;cpu = &amp;#39;i686&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;endian = &amp;#39;little&amp;#39;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;注：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;当 &lt;code&gt;meson&lt;&#x2F;code&gt; 版本为 1.4.0 时  &lt;code&gt;pkgconfig&lt;&#x2F;code&gt; 应该是 &lt;code&gt;pkg-config&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;同时 &lt;code&gt;llvm-config&lt;&#x2F;code&gt; 要对齐编译 &lt;code&gt;64&lt;&#x2F;code&gt; 位驱动时使用的 &lt;code&gt;llvm&lt;&#x2F;code&gt; 版本&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;安装编译依赖&lt;&#x2F;strong&gt;，也许非必需，作者并不确定，因为是 bookworm 所以要修改原教程中部分的 sid 安装命令为正常的安装命令。尝试不安装依赖，直接编译测试，编译配置就失败了。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; apt-get install gcc-multilib
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; apt-get install g++-multilib
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; dpkg&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --add-architecture&lt;&#x2F;span&gt;&lt;span&gt; i386
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; apt-get update
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; apt-get install pkg-config:i386
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; apt-get install libdrm-dev:i386
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; apt-get install libwayland-dev:i386
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; apt-get install libwayland-egl-backend-dev:i386
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; apt-get install libxext-dev:i386
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; apt-get install libxfixes-dev:i386
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; apt-get install x11proto-dev:i386
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; apt-get install libxcb-glx0-dev:i386
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; apt-get install libxcb-shm0-dev:i386
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; apt-get install libx11-xcb-dev:i386
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; apt-get install libxcb-dri2-0-dev:i386
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; apt-get install libxcb-dri3-dev:i386
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; apt-get install libxcb-present-dev:i386
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; apt-get install libxshmfence-dev:i386
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; apt-get install libxxf86vm-dev:i386
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; apt-get install libxrandr-dev:i386
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; apt-get install libunwind-dev:i386
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; apt-get install libudev-dev:i386
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; apt-get install libelf-dev:i386
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; apt-get install libzstd-dev:i386
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;配置 32 位编译&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;meson&lt;&#x2F;span&gt;&lt;span&gt; setup build32&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --cross-file&lt;&#x2F;span&gt;&lt;span&gt; gcc-i686&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --libdir&lt;&#x2F;span&gt;&lt;span&gt; &#x2F;usr&#x2F;lib&#x2F;i386-linux-gnu&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;                                                        -Ddri3&lt;&#x2F;span&gt;&lt;span&gt;=enabled                              \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;  -Dprefix&lt;&#x2F;span&gt;&lt;span&gt;=&#x2F;usr                               \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;  -Dglx&lt;&#x2F;span&gt;&lt;span&gt;=dri                                   \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;  -Degl&lt;&#x2F;span&gt;&lt;span&gt;=enabled                               \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;  -Dgbm&lt;&#x2F;span&gt;&lt;span&gt;=enabled                               \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;  -Dgallium-vdpau&lt;&#x2F;span&gt;&lt;span&gt;=disabled                    \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;  -Dvalgrind&lt;&#x2F;span&gt;&lt;span&gt;=disabled                         \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;  -Dgallium-drivers&lt;&#x2F;span&gt;&lt;span&gt;=virgl              \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;  -Dvulkan-drivers&lt;&#x2F;span&gt;&lt;span&gt;=virtio              \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;  -Dvulkan-layers&lt;&#x2F;span&gt;&lt;span&gt;=device-select
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;提示 gcc 的一些参数被弃用，但貌似并不影响最后的编译配置，修改 &lt;code&gt;~&#x2F;.local&#x2F;share&#x2F;meson&#x2F;cross&#x2F;gcc-i686&lt;&#x2F;code&gt; 中 &lt;code&gt;[properties]&lt;&#x2F;code&gt; 为 &lt;code&gt;[built-in options]&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;运行编译 &lt;code&gt;sudo ninja -C build32 install&lt;&#x2F;code&gt; 编译错误，提示&lt;&#x2F;strong&gt;：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;&#x2F;usr&#x2F;bin&#x2F;ld: cannot find -lLLVM-14: No such file or directory&lt;&#x2F;code&gt; 貌似编译过程中配置了错误的 llvm 版本参数&lt;&#x2F;p&gt;
&lt;p&gt;虽然 32 位驱动没能编译成功，但是运行 &lt;code&gt;vulkaninfo&lt;&#x2F;code&gt; 和 &lt;code&gt;vkcube&lt;&#x2F;code&gt; 都能取得预期结果。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;❯&lt;&#x2F;span&gt;&lt;span&gt; vulkaninfo | &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;grep&lt;&#x2F;span&gt;&lt;span&gt; driverName
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;MESA:&lt;&#x2F;span&gt;&lt;span&gt; error: Use of VkSurfacePresentModeCompatibilityEXT without a VkSurfacePresentModeEXT set. This is an application bug.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ERROR&lt;&#x2F;span&gt;&lt;span&gt; while creating surface for extension VK_KHR_wayland_surface : .&#x2F;vulkaninfo&#x2F;vulkaninfo.h:237:vkGetPhysicalDeviceSurfacePresentModesKHR failed with ERROR_SURFACE_LOST_KHR
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;driverName&lt;&#x2F;span&gt;&lt;span&gt;      = venus
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;driverName&lt;&#x2F;span&gt;&lt;span&gt;                                           = venus
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;driverName&lt;&#x2F;span&gt;&lt;span&gt;      = llvmpipe
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;driverName&lt;&#x2F;span&gt;&lt;span&gt;                                           = llvmpipe
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;❯&lt;&#x2F;span&gt;&lt;span&gt; vkcube
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Selected&lt;&#x2F;span&gt;&lt;span&gt; GPU 0: Virtio-GPU Venus (Intel(R) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;UHD&lt;&#x2F;span&gt;&lt;span&gt; Graphics 615 (AML-KBL))&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; type: IntegratedGpu
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;先尝试运行游戏：Steam 客户端一样的卡，但是运行游戏时弹出了配置 Vulkan 着色器的窗口，也许是好迹象，大概 15FPS ，依旧是不可玩的状态，看来是需要 32 位的驱动。因为在 Fedora 上，使用 Proton 7.0 有更好的兼容性，所以更换 Proton 版本再测试一下。测试 ProtonDB 上提到的启动参数 &lt;code&gt;PROTON_USE_WINED3D11=1 %command%&lt;&#x2F;code&gt; 情况依旧。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;不推荐的解决方法：&lt;&#x2F;strong&gt;&lt;del&gt;安装额外的依赖后编译成功 &lt;code&gt;sudo apt install llvm:i386 llvm-dev:i386&lt;&#x2F;code&gt;&lt;&#x2F;del&gt;&lt;&#x2F;p&gt;
&lt;p&gt;反馈给原教程之后，我了解到这个方法会导致&lt;a href=&quot;https:&#x2F;&#x2F;gist.github.com&#x2F;Usulyre&#x2F;bb33f77b225b8d9336c1f9e744114fba?permalink_comment_id=4840165#gistcomment-4840165&quot;&gt;依赖冲突&lt;&#x2F;a&gt;，所以我并不推荐，在我的环境中并不存在依赖冲突，因为我没有对应的依赖软件安装，例如 python3-mako ，可能是因为我的环境并非是新建立的，也可能是我之前对 python 的环境进行了改动，总之我不建议以这样的方式解决，我这样的解决方法应该是错误的，原教程中并没有这样的问题。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zheng-que-de-fang-fa-march-18-2024-xin-zeng&quot;&gt;正确的方法（March 18, 2024 新增）&lt;&#x2F;h3&gt;
&lt;p&gt;在上次编译过后，因为涉及到依赖冲突，所以我最后卸载了之前安装的依赖 &lt;code&gt;llvm:i386 llvm-dev:i386&lt;&#x2F;code&gt; ，不确定是否是这个原因，导致这次再登陆系统，发现 Steam 无法启动了，而后尝试卸载驱动，导致 OpenGL 都不可用，Alacritty 都不可用了，这很麻烦。最后虽然通过重新编译 64 位的驱动，解决了 OpenGL 但问题，但是对于 Steam 依旧是启动错误，为了解决这个问题，我再次尝试编译 32 位驱动，依旧遇到了之前遇到的错误 &lt;code&gt;&#x2F;usr&#x2F;bin&#x2F;ld: cannot find -lLLVM-14: No such file or directory&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;这次我没有尝试安装会造成冲突的依赖，，我决定好好的分析一下，最后发现是没有正确的设置交叉编译，系统默认的 &lt;code&gt;llvm&lt;&#x2F;code&gt; 版本是 &lt;code&gt;llvm-15&lt;&#x2F;code&gt; 但是默认的 &lt;code&gt;llvm-config&lt;&#x2F;code&gt; 却是 &lt;code&gt;llvm-14&lt;&#x2F;code&gt; 版本，导致了在交叉编译过程中寻找不到正确的依赖。之前通过错误的安装了 &lt;code&gt;i386&lt;&#x2F;code&gt; 版本的 &lt;code&gt;llvm-14&lt;&#x2F;code&gt; 补齐了依赖，所以编译安装能够成功，但那其实就不是交叉编译了。理论上 64 位的驱动能用 &lt;code&gt;llvm-15&lt;&#x2F;code&gt; 完成编译，那应该也能通过 &lt;code&gt;llvm-15&lt;&#x2F;code&gt; 完成交叉编译出 32 位驱动。所以通过修改文件 &lt;code&gt;~&#x2F;.local&#x2F;share&#x2F;meson&#x2F;cross&#x2F;gcc-i686&lt;&#x2F;code&gt; 中的 &lt;code&gt;llvm-config&lt;&#x2F;code&gt; 为 &lt;code&gt;llvm-config-15&lt;&#x2F;code&gt; ，再运行 &lt;code&gt;meson&lt;&#x2F;code&gt; 配置，然后进行编译安装，最终实现了 32 位驱动的正确编译。在这之后 Steam 正确的启动，问题解决。我的环境中存在 &lt;code&gt;llvm-14&lt;&#x2F;code&gt; 和 &lt;code&gt;llvm-15&lt;&#x2F;code&gt; ，其中 &lt;code&gt;llvm-14&lt;&#x2F;code&gt; 为默认版本，对于为何在编译 64 位驱动时用了 &lt;code&gt;llvm-15&lt;&#x2F;code&gt; 而不使用 &lt;code&gt;llvm-14&lt;&#x2F;code&gt; 有点让我费解，可能要仔细阅读一下 &lt;code&gt;meson.build&lt;&#x2F;code&gt; 文件才能确定了。&lt;&#x2F;p&gt;
&lt;p&gt;在编译过程中 Debian Bokworm 源内自带的 &lt;code&gt;meson&lt;&#x2F;code&gt; 版本太低，所以我从 Bookworm Sid 源下载了较新版本的 &lt;code&gt;meson&lt;&#x2F;code&gt; ，利用 &lt;code&gt;dpkg&lt;&#x2F;code&gt; 安装 &lt;code&gt;deb&lt;&#x2F;code&gt; 包，最后成功安装。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;meson&lt;&#x2F;code&gt; 这次又提醒交叉编译配置中存在一个弃用的选项，即 &lt;code&gt;pkgconfig&lt;&#x2F;code&gt; 要变更为 &lt;code&gt;pkg-config&lt;&#x2F;code&gt; 。&lt;&#x2F;p&gt;
&lt;p&gt;参考：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;https:&#x2F;&#x2F;docs.mesa3d.org&#x2F;install.html&lt;&#x2F;li&gt;
&lt;li&gt;https:&#x2F;&#x2F;github.com&#x2F;mesonbuild&#x2F;meson&#x2F;issues&#x2F;10483&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;jian-cha-an-zhuang-qing-kuang&quot;&gt;检查安装情况&lt;&#x2F;h2&gt;
&lt;p&gt;安装 vulkan 测试工具 &lt;code&gt;sudo apt-get install vulkan-tools&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;查看安装的驱动版本 &lt;code&gt;ls &#x2F;usr&#x2F;share&#x2F;vulkan&#x2F;icd.d&#x2F;&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;预期：&lt;code&gt;virtio_icd.x86_64.json&lt;&#x2F;code&gt; 和 &lt;code&gt;virtio_icd.i686.json&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;简单测试：&lt;code&gt;VK_ICD_FILENAMES=&#x2F;usr&#x2F;share&#x2F;vulkan&#x2F;icd.d&#x2F;virtio_icd.i686.json:&#x2F;usr&#x2F;share&#x2F;vulkan&#x2F;icd.d&#x2F;virtio_icd.x86_64.json vkcube&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;修改环境变量，令驱动持续生效&lt;&#x2F;p&gt;
&lt;p&gt;编辑 &lt;code&gt;&#x2F;etc&#x2F;environment&lt;&#x2F;code&gt; 文件增加环境变量&lt;code&gt;VK_ICD_FILENAMES=&#x2F;usr&#x2F;share&#x2F;vulkan&#x2F;icd.d&#x2F;virtio_icd.i686.json:&#x2F;usr&#x2F;share&#x2F;vulkan&#x2F;icd.d&#x2F;virtio_icd.x86_64.json&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;运行 &lt;code&gt;vulkaninfo&lt;&#x2F;code&gt; 查看 vulkan 驱动信息&lt;&#x2F;p&gt;
&lt;p&gt;运行 &lt;code&gt;vkcube&lt;&#x2F;code&gt; 输出对应 GPU 信息&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;❯&lt;&#x2F;span&gt;&lt;span&gt; vulkaninfo | &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;grep&lt;&#x2F;span&gt;&lt;span&gt; driverName
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;WARNING: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span&gt;Loader Message&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;]&lt;&#x2F;span&gt;&lt;span&gt; Code 0 : env var &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;VK_INSTANCE_LAYERS&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39; defined and adding layers &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;VK_LAYER_MESA_overlay&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;WARNING: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span&gt;Loader Message&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;]&lt;&#x2F;span&gt;&lt;span&gt; Code 0 : env var &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;VK_INSTANCE_LAYERS&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39; defined and adding layers &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;VK_LAYER_MESA_overlay&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;MESA:&lt;&#x2F;span&gt;&lt;span&gt; error: Use of VkSurfacePresentModeCompatibilityEXT without a VkSurfacePresentModeEXT set. This is an application bug.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ERROR&lt;&#x2F;span&gt;&lt;span&gt; while creating surface for extension VK_KHR_wayland_surface : .&#x2F;vulkaninfo&#x2F;vulkaninfo.h:237:vkGetPhysicalDeviceSurfacePresentModesKHR failed with ERROR_SURFACE_LOST_KHR
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;driverName&lt;&#x2F;span&gt;&lt;span&gt;      = venus
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;driverName&lt;&#x2F;span&gt;&lt;span&gt;                                           = venus
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;~
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;❯&lt;&#x2F;span&gt;&lt;span&gt; vkcube
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Selected&lt;&#x2F;span&gt;&lt;span&gt; GPU 0: Virtio-GPU Venus (Intel(R) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;UHD&lt;&#x2F;span&gt;&lt;span&gt; Graphics 615 (AML-KBL))&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; type: IntegratedGpu
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;hou-xu&quot;&gt;后续&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;在 &lt;code&gt;chrome:&#x2F;&#x2F;flags&lt;&#x2F;code&gt; 中有用的选项 &lt;code&gt;chrome:&#x2F;&#x2F;flags&#x2F;#exo-ordinal-motion&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;如果驱动存在问题，可以尝试拉取最新代码，重新编译安装，再进行测试&lt;&#x2F;li&gt;
&lt;li&gt;增加 vulkan 程序 FPS 计数器，在 &#x2F;etc&#x2F;environment 文件中添加环境变量  &lt;code&gt;VK_INSTANCE_LAYERS=VK_LAYER_MESA_overlay&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;qian-hou-you-xi-zheng-shu-dui-bi&quot;&gt;前后游戏帧数对比&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;The Conquest of Go&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;默认：不到 10 FPS 不可玩&lt;&#x2F;p&gt;
&lt;p&gt;Vulkan：在 Steam 中增加游戏运行参数 &lt;code&gt;DXVK_HUD=devinfo,fps %command%&lt;&#x2F;code&gt; 可见游戏已经运行在正确的 Vulkan 驱动下，但是游戏帧数在 18FPS 左右，稍微好点，但是游玩依旧难受，至少要 20 FPS 才行。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>参加2023年Advent of Code</title>
        <published>2023-12-27T00:00:00+00:00</published>
        <updated>2023-12-27T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/adventofcode2023/"/>
        <id>https://ghost.livexia.xyz/adventofcode2023/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/adventofcode2023/">&lt;ul&gt;
&lt;li&gt;https:&#x2F;&#x2F;adventofcode.com&#x2F;&lt;&#x2F;li&gt;
&lt;li&gt;https:&#x2F;&#x2F;github.com&#x2F;livexia&#x2F;advent-of-code-2023&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;[toc]&lt;&#x2F;p&gt;
&lt;h2 id=&quot;rust-hints&quot;&gt;Rust Hints&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;https:&#x2F;&#x2F;github.com&#x2F;dtolnay&#x2F;anyhow This library provides &lt;code&gt;[anyhow::Error](https:&#x2F;&#x2F;docs.rs&#x2F;anyhow&#x2F;1.0&#x2F;anyhow&#x2F;struct.Error.html)&lt;&#x2F;code&gt;, a trait object based error type for easy idiomatic error handling in Rust applications.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;flat_map(|n| n.parse())&lt;&#x2F;code&gt; 会忽略 &lt;code&gt;Err&lt;&#x2F;code&gt; 保留 &lt;code&gt;Ok&lt;&#x2F;code&gt; 中的结果。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;things-to-learn&quot;&gt;Things to Learn&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;Dynamic programming&lt;&#x2F;li&gt;
&lt;li&gt;Dijkstra&#x27;s algorithm&lt;&#x2F;li&gt;
&lt;li&gt;Shortest path problem&lt;&#x2F;li&gt;
&lt;li&gt;Cycle detection
&lt;ul&gt;
&lt;li&gt;Floyd&#x27;s tortoise and hare&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Shoelace formula&lt;&#x2F;li&gt;
&lt;li&gt;Pick’s theorem&lt;&#x2F;li&gt;
&lt;li&gt;Purne graph
&lt;ul&gt;
&lt;li&gt;Edge contraction&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Longest path problem&lt;&#x2F;li&gt;
&lt;li&gt;Linear algebra&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-1&quot;&gt;Day 1&lt;&#x2F;h2&gt;
&lt;p&gt;Part 2 一些特别的思路&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;通过替换 zero 为 zero0zero 将字母串替换为包含数字字符的新字符串，巧妙的实现字母串转换为数字字符，同时又避免因为替换而导致其他可能的字母串被修改 https:&#x2F;&#x2F;old.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;1883ibu&#x2F;2023_day_1_solutions&#x2F;kbikddg&#x2F; advent-of-code-2023
Advent of Code 2023&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-2&quot;&gt;Day 2&lt;&#x2F;h2&gt;
&lt;p&gt;所耗时间均在对输入的处理上，解决问题的思路直截了当。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;day-3&quot;&gt;Day 3&lt;&#x2F;h2&gt;
&lt;p&gt;依旧需要小心的处理输入，涉及到二维的矩阵，往往有两种方法：一是利用二维 Vec 进行表示，二则是利用 HashMap 进行表示。如果利用 Vec 那么在涉及到对周边节点遍历时，在 Rust 中要注意对 usize 数据类型可能的 underflow ，利用 HashMap 则可以利用 i32 作为矩阵的坐标数据类型。&lt;&#x2F;p&gt;
&lt;p&gt;在具体的算法上，我选择利用深度优先搜索，进行解决，具体思路如下：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;从矩阵的右下角开始进行深度优先搜索，从右到左，从上到下的顺序分别进行dfs。&lt;&#x2F;li&gt;
&lt;li&gt;如果当前元素是数字，那么这个数字必然是一个数字的组成部分，同时也是这个数字的最低位，这样的搜索顺序可以方便的对最终结果进行结合。&lt;&#x2F;li&gt;
&lt;li&gt;同样的如果当前元素是数字，那么可以对这个数字的邻接元素（8个）进行判断，如果其中存在一个符号，设标识，表示当前数字同一个符号相邻。&lt;&#x2F;li&gt;
&lt;li&gt;除了对邻接元素进行判断，同时要对当前元素的左侧元素进行递归的深度优先搜索，深度优先返回得到整个数字除了最低位的部分，对这个结果乘 10 加上当前元素的数字，即是完整的数字。&lt;&#x2F;li&gt;
&lt;li&gt;同样的一个数字任意位的邻接是符号，则整个数字都与符号邻接，于是需要在深度优先的搜索过程中保留标识，每次都对标识进行或运算。&lt;&#x2F;li&gt;
&lt;li&gt;在深度优先搜索中引入 visited ，确保元素不被重复搜索。&lt;&#x2F;li&gt;
&lt;li&gt;总结：深度优先搜索是从一个数字开始，在一行中向左继续搜索，搜索过程中取得一个完整的数字，并确认整个数字是否存在部分与符号邻接。&lt;&#x2F;li&gt;
&lt;li&gt;第一部分的方法即是如此，第二部分则稍有不同，但整体思路是一致的，在深度优先搜索中，要判断数字的组成部分是否与齿轮符号邻接，并保留数字每个组成部分对应的齿轮符号坐标（一个齿轮可能与多个数字邻接，同时一个数字也可能与多个符号邻接）。&lt;&#x2F;li&gt;
&lt;li&gt;在每一次深度优先搜索后，就得到了数字与邻接齿轮的对应关系，在这个基础上再对问题进行解答即可。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;day-4&quot;&gt;Day 4&lt;&#x2F;h2&gt;
&lt;p&gt;这个问题的输入并不复杂，每一行输入包含了两个数组，第一部分要求计算第二个数组中的数字在第一个数组中出现的次数，直接暴力匹配实现即可。第二部分需要在这个基础上再进一步的计算，在此以示例输入为例进行阐述：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;依旧是对输入进行暴力匹配，计算每一行输入中第二个数组中的数字在第一个数组中出现的次数，对于示例输入可得 &lt;code&gt;[4, 2, 2, 1, 0, 0]&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;当前所有的 Card 数量均为 &lt;code&gt;[1, 1, 1, 1, 1, 1]&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;根据题意，因为 Card 1 中重复的数字有 4 个，则会获得 Card 2、3、4、5 各一张&lt;&#x2F;li&gt;
&lt;li&gt;此时各 Card 数量为 &lt;code&gt;[1, 2, 2, 2, 2, 1]&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;因为 Card 2 有两张，同时 Card 2 中重复的数字有 2 个，则会 Card 3、4 各两张&lt;&#x2F;li&gt;
&lt;li&gt;此时各 Card 数量为 &lt;code&gt;[1, 2, 2 + 2, 2 + 2, 2, 1]&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;依次类推&lt;&#x2F;li&gt;
&lt;li&gt;刮完所有的 Card 3后，Card 数量为 &lt;code&gt;[1, 2, 2 + 2, 2 + 2 + 4, 2 + 4, 1]&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;刮完所有的 Card 4后，Card 数量为 &lt;code&gt;[1, 2, 2 + 2, 2 + 2 + 4, 2 + 4 + 8, 1]&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;最后的 Crad 总数即为 &lt;code&gt;1 + 2 + 4 + 8 + 14 + 1 = 30&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;性能优化？&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;避免暴力匹配，选用更好的匹配算法，计算两个数组的重叠元素个数。&lt;strong&gt;实际上在这个问题中，需要匹配的两个数组大小都较小，暴力匹配并不会影响性能。&lt;&#x2F;strong&gt;
&lt;ul&gt;
&lt;li&gt;https:&#x2F;&#x2F;afteracademy.com&#x2F;blog&#x2F;find-the-intersection-of-two-unsorted-arrays&#x2F;&lt;&#x2F;li&gt;
&lt;li&gt;对其中一个数组进行排序，在二分查找另一个数组的元素&lt;&#x2F;li&gt;
&lt;li&gt;对两个数组都进行排序，双指针进行对比 &lt;a href=&quot;https:&#x2F;&#x2F;afteracademy.com&#x2F;blog&#x2F;find-the-intersection-of-two-unsorted-arrays&#x2F;#:~:text=Return%20answer%20list.-,Solution%20Visualization,-Pseudo%2DCode&quot;&gt;https:&#x2F;&#x2F;afteracademy.com&#x2F;blog&#x2F;find-the-intersection-of-two-unsorted-arrays&#x2F;#:~:text=Return answer list.-,Solution Visualization,-Pseudo-Code&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;存储其中一个数组为 HashSet ，在对另一个数组进行 HashSet 查找&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;Rust Tips&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;You can use &lt;code&gt;split_whitespace()&lt;&#x2F;code&gt; to avoid the &lt;code&gt;.filter(|n| !n.is_empty())&lt;&#x2F;code&gt;. Good job!
&lt;ul&gt;
&lt;li&gt;https:&#x2F;&#x2F;old.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;18actmy&#x2F;2023_day_4_solutions&#x2F;kbx5j4v&#x2F;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-5&quot;&gt;Day 5&lt;&#x2F;h2&gt;
&lt;p&gt;输入稍显麻烦，并不是特别的困难，对每行进行循环处理即可。问题中的 Map 其实就是对应关系，每一条 Map 由三个部分组成分别是 &lt;code&gt;dest&lt;&#x2F;code&gt; &lt;code&gt;src&lt;&#x2F;code&gt; 和 &lt;code&gt;length&lt;&#x2F;code&gt; ，可以将 Map 表示为函数，对于范围在 &lt;code&gt;[src, src+length)&lt;&#x2F;code&gt; 的输入数字 &lt;code&gt;input&lt;&#x2F;code&gt; ，可以通过如下计算得到转化后的 &lt;code&gt;result = dest - src + input&lt;&#x2F;code&gt; ，第一部分就是对输入的 &lt;code&gt;seed&lt;&#x2F;code&gt; 不断的进行计算最后得到 &lt;code&gt;location&lt;&#x2F;code&gt; ，选取其中最小值即可。&lt;&#x2F;p&gt;
&lt;p&gt;第二部分在第一部分的基础上进行扩展，每两个输入的 &lt;code&gt;seeds&lt;&#x2F;code&gt; 表示 &lt;code&gt;seed&lt;&#x2F;code&gt; 的区间，同样需要计算所有区间内 &lt;code&gt;seed&lt;&#x2F;code&gt; 经过转化最后得到的 &lt;code&gt;loaction&lt;&#x2F;code&gt; 中的最小值。首先尝试直接对区间内的每一个 &lt;code&gt;seed&lt;&#x2F;code&gt; 进行暴力求解，但是因为的实际输入范围较大，运行时间较慢，所以很快的放弃，在完成后阅读 Reddit 社区的解答后发现，实际上暴力求解虽然慢，但是并不是需要几天的那种，如果让它跑完，也许在十分钟内也能取得结果。&lt;&#x2F;p&gt;
&lt;p&gt;既然不选择使用暴力，实际上这个问题就是涉及区间的问题，如果能够对整个输入的 &lt;code&gt;seed&lt;&#x2F;code&gt; 区间，进行转换，那就减少了大量的计算，对一个输入 &lt;code&gt;input&lt;&#x2F;code&gt; 区间作用某一 &lt;code&gt;Map&lt;&#x2F;code&gt; 转换逻辑如下：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;将 &lt;code&gt;Map&lt;&#x2F;code&gt; 转为区间转换的表示方式：&lt;code&gt;[src, src + length)&lt;&#x2F;code&gt; ，同时 &lt;code&gt;offset = dest - src&lt;&#x2F;code&gt; ，那么就有 &lt;code&gt;[src, src + length) -&amp;gt; [src + offset, src + length + offset)&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;设输入区间 &lt;code&gt;input&lt;&#x2F;code&gt; 为 &lt;code&gt;[start, end)&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;那么只需要计算 &lt;code&gt;[start, end)&lt;&#x2F;code&gt; 和 &lt;code&gt;[src, src + length)&lt;&#x2F;code&gt; 的重叠区间 &lt;code&gt;overlaps&lt;&#x2F;code&gt; ，再加上 &lt;code&gt;offset&lt;&#x2F;code&gt; 即可得到输入区间 &lt;code&gt;input&lt;&#x2F;code&gt; 经过 &lt;code&gt;Map&lt;&#x2F;code&gt; 转换后的部分区间&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;根据题意，如果一个 &lt;code&gt;seed&lt;&#x2F;code&gt;  无法被同一阶段的任意 &lt;code&gt;Map&lt;&#x2F;code&gt; 进行转换对应，那么就直接进行转换 （&lt;code&gt;10 → 10&lt;&#x2F;code&gt;）&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;所以仅仅得到 &lt;code&gt;input&lt;&#x2F;code&gt; 和某一个 &lt;code&gt;Map&lt;&#x2F;code&gt; 的重叠区间仍旧不够，仍旧需要判断除重叠区间外的 &lt;code&gt;input&lt;&#x2F;code&gt; 区间是否能够被同一阶段的其他 &lt;code&gt;Map&lt;&#x2F;code&gt; 进行转换，也就是需要依次对剩余的 &lt;code&gt;input&lt;&#x2F;code&gt; 区间和剩余的同一阶段的 &lt;code&gt;Map&lt;&#x2F;code&gt; 进行转换，当所有同一阶段的 &lt;code&gt;Map&lt;&#x2F;code&gt; 都完成了转换后，如果 &lt;code&gt;input&lt;&#x2F;code&gt; 区间还剩下，那么依旧需要将剩下的区间保留到下一阶段，具体代码如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;convert_range&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;: Range,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;dest&lt;&#x2F;span&gt;&lt;span&gt;: Number,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;src&lt;&#x2F;span&gt;&lt;span&gt;: Number,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;length&lt;&#x2F;span&gt;&lt;span&gt;: Number,
&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; (Vec&amp;lt;Range&amp;gt;, Option&amp;lt;Range&amp;gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; src range: src..src+length
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; src and dest offset is: dest - src
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; then: dest = src + offset
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; offset = dest - src;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; src_end = src + length;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;(start, end) = input;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; end &amp;lt;= src || src_end &amp;lt;= start {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;(vec![input], None);
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; overlaps = Some((start.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;max&lt;&#x2F;span&gt;&lt;span&gt;(src) + offset, end.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;min&lt;&#x2F;span&gt;&lt;span&gt;(src_end) + offset));
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; input range overlaps with range Number::MIN..src and range src_end..Number::MAX
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; is the remain range of input
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; remain_range: Vec&amp;lt;Range&amp;gt; = [(start, end.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;min&lt;&#x2F;span&gt;&lt;span&gt;(src)), (start.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;max&lt;&#x2F;span&gt;&lt;span&gt;(src_end), end)]
&lt;&#x2F;span&gt;&lt;span&gt;            .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;into_iter&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;            .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;filter&lt;&#x2F;span&gt;&lt;span&gt;(|(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;)| a &amp;lt; b)
&lt;&#x2F;span&gt;&lt;span&gt;            .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;collect&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;        (remain_range, overlaps)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;convert_range_with_maps&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;range&lt;&#x2F;span&gt;&lt;span&gt;: Range, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;maps&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;[SingleMap], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;converted&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span&gt;Vec&amp;lt;Range&amp;gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; maps.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;is_empty&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;        converted.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;(range);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;(dest, src, length) = maps[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;(r_ranges, overlaps) = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;convert_range&lt;&#x2F;span&gt;&lt;span&gt;(range, dest, src, length);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Some(overlaps) = overlaps {
&lt;&#x2F;span&gt;&lt;span&gt;        converted.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;(overlaps);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; r in r_ranges {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;convert_range_with_maps&lt;&#x2F;span&gt;&lt;span&gt;(r, &amp;amp;maps[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;..], converted);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;根据输入，对每个阶段都进行同一阶段的 Maps 转化和对应，不断得到新的输入区间，直到完成所有的转换对应阶段，对最后得到的所有区间的起点取最小值即是第二部分的解&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;性能优化&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;采用 interval 区间重叠的方法可以视作是对暴力计算的一种性能优化&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;也可以在暴力计算的过程中改变每次循环的间隔进行逼近求解，当然这不是一种特别系统的方法&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;在利用 interval 求解的过程中依旧存在可能的性能优化，那就是对于每一个阶段输出的区间列表进行合并，减少下一个阶段的输入，涉及到区间合并的算法。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;首先按照区间起点对区间列表进行排序&lt;&#x2F;li&gt;
&lt;li&gt;考虑两个&lt;strong&gt;有序区间&lt;&#x2F;strong&gt;合并的算法，即 &lt;code&gt;merge_range&lt;&#x2F;code&gt;，设区间：&lt;code&gt;[a_start, a_end)&lt;&#x2F;code&gt; 和 &lt;code&gt;[b_start, b_end)&lt;&#x2F;code&gt; 且 &lt;code&gt;a_start &amp;lt; b_start&lt;&#x2F;code&gt;
&lt;ul&gt;
&lt;li&gt;如果 &lt;code&gt;a_end &amp;lt; b_start&lt;&#x2F;code&gt; 那么两个区间不存在重叠，区间 &lt;code&gt;a&lt;&#x2F;code&gt; 和 &lt;code&gt;b&lt;&#x2F;code&gt; 不需要合并&lt;&#x2F;li&gt;
&lt;li&gt;反之，两个区间存在重叠，那么合并后的区间就是 &lt;code&gt;(a_start, a_end.max(b_end))&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;对于有序区间列表的合并只需要在这个基础上进行扩展即可，见 &lt;code&gt;merge_ranges&lt;&#x2F;code&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;首先对第一个和第二个区间进行合并，如果不存在重叠，那么第一个区间已完成了所有的合并，第二个区间再对第三个区间进行合并。&lt;&#x2F;li&gt;
&lt;li&gt;反之如果存在重叠，那么合并后的区间，再对第三个区间进行合并。&lt;&#x2F;li&gt;
&lt;li&gt;以此类推就可以对有序区间列表完成合并，具体代码如下：&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; this funtion only works when a.0 &amp;lt;= b.0
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;merge_range&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;: Range, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;: Range) -&amp;gt; (Option&amp;lt;Range&amp;gt;, Range) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;(a_start, a_end) = a;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;(b_start, b_end) = b;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; a_end &amp;lt; b_start {
&lt;&#x2F;span&gt;&lt;span&gt;        (Some(a), b)
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        (None, (a_start, a_end.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;max&lt;&#x2F;span&gt;&lt;span&gt;(b_end)))
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;merge_ranges&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ranges&lt;&#x2F;span&gt;&lt;span&gt;: Vec&amp;lt;Range&amp;gt;) -&amp;gt; Vec&amp;lt;Range&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; ranges.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;() &amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; ranges;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    ranges.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;sort&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; merged_ranges = vec![];
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; next = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; remain = ranges[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;while&lt;&#x2F;span&gt;&lt;span&gt; next &amp;lt; ranges.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;(merged, remain_temp) = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;merge_range&lt;&#x2F;span&gt;&lt;span&gt;(remain, ranges[next]);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Some(merged) = merged {
&lt;&#x2F;span&gt;&lt;span&gt;            merged_ranges.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;(merged);
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        next += &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        remain = remain_temp;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    merged_ranges.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;(remain);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    merged_ranges
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-6&quot;&gt;Day 6&lt;&#x2F;h2&gt;
&lt;p&gt;输入的处理很简单，第一部分将两行输入转换为数组，第二部分则将两个数组分别组成一个大数。直接根据题意进行了暴力解答，题意理解如下：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;对于给定的最大时间 &lt;code&gt;t&lt;&#x2F;code&gt; ，和给定最小距离 &lt;code&gt;d&lt;&#x2F;code&gt; ，求满足不等式 $(t - x)*x&amp;gt;d$ 的 &lt;code&gt;x&lt;&#x2F;code&gt; （按按钮的时间） 所有整数解&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;因为涉及的不等式并不复杂，而且第一第二部分给定的输入都并非超级巨大，所以暴力求解也可以轻松完成。但是既然涉及不等式，那么就可以简单的对不等式进行求解，取得答案，思路如下（虽然是初中数学，但是依旧进行了搜索，根本记不住公式，记住的部分也是错的，数学都还给老师了）：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对不等式进行转换 $-x^2 + tx - d &amp;gt; 0$&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;del&gt;继续转换 $x^2 - tx + d &amp;lt;= 0$&lt;&#x2F;del&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;不等式两侧乘负数变号规则错误&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;正确的方程为 $x^2 - tx + d &amp;lt; 0$&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;可以发现，实际上要求的就是二次函数 $f(x) = x^2 - tx + d$ 在 &lt;del&gt;x 轴和&lt;&#x2F;del&gt;轴下方时，x 的整数范围&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;同时也可以发现该二次函数在 x = 0 和 x = t 出是对称的，那么也可以通过计算当 $f(x) = 0$ 时 x 距离 0 或 t 的距离进行求解&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;当然最简单的方法就是直接计算一元二次方程 $x^2 - tx + d = 0$ 的两个解，求解公式为 $x = (t \pm \sqrt{t^2 - 4d}) &#x2F; 2$&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;因为要求的是两个解的距离，就有以下方程 $(t + \sqrt{t^2-4d})&#x2F;2-(t-\sqrt{t^2-4d})&#x2F;2$ 化简后可得距离为 $\sqrt{t^2 - 4d}$&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;del&gt;同时需要包含两侧的解，所以最后结果需要加一&lt;&#x2F;del&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;因为需要计算的区间内的所有整数的数量，而直接接计算距离将无法考虑到这一点&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;设两个解为 &lt;code&gt;x1&lt;&#x2F;code&gt; 和 &lt;code&gt;x2&lt;&#x2F;code&gt; 且 &lt;code&gt;x1 ≤ x2&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果 &lt;code&gt;x1.ceil() == x1&lt;&#x2F;code&gt; 为真则需要从 &lt;code&gt;x1 + 1&lt;&#x2F;code&gt; ，反之则需要从 &lt;code&gt;x1.ceil()&lt;&#x2F;code&gt; （包含）开始&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果 &lt;code&gt;x2.floor() == x2&lt;&#x2F;code&gt; 为真则需要从 &lt;code&gt;x2 - 1&lt;&#x2F;code&gt;, 反之所有的整数直到 &lt;code&gt;x2.floor()&lt;&#x2F;code&gt;（包含）为止&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;具体代码如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; start = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; x1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;ceil&lt;&#x2F;span&gt;&lt;span&gt;() == x1 {
&lt;&#x2F;span&gt;&lt;span&gt;    (x1 + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1.0&lt;&#x2F;span&gt;&lt;span&gt;) as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize
&lt;&#x2F;span&gt;&lt;span&gt;} &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    x1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;ceil&lt;&#x2F;span&gt;&lt;span&gt;() as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; end = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; x2.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;floor&lt;&#x2F;span&gt;&lt;span&gt;() == x2 {
&lt;&#x2F;span&gt;&lt;span&gt;    (x2 - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1.0&lt;&#x2F;span&gt;&lt;span&gt;) as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize
&lt;&#x2F;span&gt;&lt;span&gt;} &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    x2.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;floor&lt;&#x2F;span&gt;&lt;span&gt;() as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;end - start + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;也可以从 x1.floor() + 1.0 开始到 x2.ceil() - 1.0 为止，两侧都包含 &lt;code&gt;(x2.ceil() - 1.0 - x1.floor() - 1.0) as usize + 1&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-7&quot;&gt;Day 7&lt;&#x2F;h2&gt;
&lt;p&gt;题目并不难，为了构造正确的数据类型而花费了大量的时间，思路如下：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每一行输入包含 &lt;code&gt;Hand&lt;&#x2F;code&gt; 和 &lt;code&gt;bid&lt;&#x2F;code&gt; 两个部分，&lt;code&gt;Hand&lt;&#x2F;code&gt; 由五个字符即五张手牌组成，&lt;code&gt;bid&lt;&#x2F;code&gt; 为数字&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;根据组成 &lt;code&gt;Hand&lt;&#x2F;code&gt; 中手牌重复情况，存在七种可能的手牌组类型 &lt;code&gt;HandKind&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;七种 &lt;code&gt;HandKind&lt;&#x2F;code&gt; 存在大小顺序，同时每一张牌也存在大小关系&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;第二个部分调整了部分牌的大小顺序&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;在确定手牌 &lt;code&gt;Hand&lt;&#x2F;code&gt; 的大小时，首先考虑 &lt;code&gt;HandKind&lt;&#x2F;code&gt; 大小，再考虑牌的大小&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;第一部分需要对所有输入的手牌进行排序，从小到大依次乘上当前手牌的位置，再累加即可&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;第二部分引入小丑规则，即 &lt;code&gt;J&lt;&#x2F;code&gt; 牌为小丑，可以替代任何的牌，已达成更好的 &lt;code&gt;HandKind&lt;&#x2F;code&gt; ，但是 J 牌变为最小的牌&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;因为涉及到大小和排序，所以最简单的方法就是实现 &lt;code&gt;HandKind&lt;&#x2F;code&gt; 的大小比较，再实现牌的大小比较，最后再实现 &lt;code&gt;Hand&lt;&#x2F;code&gt; 的大小比较&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;HandKind&lt;&#x2F;code&gt; 可以使用 &lt;code&gt;enum&lt;&#x2F;code&gt; 表示，比较大小时则可以直接转为对应的数字进行比较&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;牌的大小比较也类似，首先字符转为对应顺序的数字，再对数字进行比较即可&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;确定 &lt;code&gt;HandKind&lt;&#x2F;code&gt; 的思路如下：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;利用 &lt;code&gt;HashMap&lt;&#x2F;code&gt; 统计手牌中每个牌的数量&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;HashMap.into_values().collect()&lt;&#x2F;code&gt; 取得数量的数组，对数组进行排序&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;values.iter().fold(0, |sum, i| sum * 10 + *i)&lt;&#x2F;code&gt; 将排序后的数组，转换为数字&lt;&#x2F;li&gt;
&lt;li&gt;因为题意中的牌组类型较少，每一个 &lt;code&gt;HandKind&lt;&#x2F;code&gt; 通过这样转换后都能得到对应的唯一数字，一对一的关系，所以可以利用这个数字确定 &lt;code&gt;HandKind&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;然后就是利用 &lt;code&gt;sort()&lt;&#x2F;code&gt; 对 &lt;code&gt;Vec&amp;lt;Hand&amp;gt;&lt;&#x2F;code&gt; 进行排序，并根据题意计算结果即可&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;第二部分稍微复杂点，相比于修改第一部分处理好的 &lt;code&gt;Vec&amp;lt;Hand&amp;gt;&lt;&#x2F;code&gt; 不如重新对输入进行处理，将牌 &lt;code&gt;J&lt;&#x2F;code&gt; 的大小置为最小，而用 J 牌替换其他牌构成更好的 &lt;code&gt;HashMap&lt;&#x2F;code&gt; 逻辑如下：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;依旧是利用 &lt;code&gt;HashMap&lt;&#x2F;code&gt; 统计手牌中每个牌的数量&lt;&#x2F;li&gt;
&lt;li&gt;通过 &lt;code&gt;HashMap&lt;&#x2F;code&gt; ，如果 &lt;code&gt;Hand&lt;&#x2F;code&gt; 中 &lt;code&gt;J&lt;&#x2F;code&gt; 的数量介于 1 到 4 张（均包含），那么需要将 J 牌的数量从 &lt;code&gt;HashMap&lt;&#x2F;code&gt; 中移除，同时将对应 &lt;code&gt;J&lt;&#x2F;code&gt; 牌数量加到剩余牌数量最大的牌之上，实现的时候我是很自然的这样操作，但是实际上这是题目恰好的安排，如果改变了 &lt;code&gt;HandKind&lt;&#x2F;code&gt; 的大小顺序那么这样也许不可行。假设 &lt;code&gt;Hand&lt;&#x2F;code&gt; 中包含 &lt;code&gt;J&lt;&#x2F;code&gt; 牌，分析如下：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;14&lt;&#x2F;code&gt; 对应 &lt;code&gt;Four&lt;&#x2F;code&gt; ，无论 &lt;code&gt;J&lt;&#x2F;code&gt; 是一张还是四张，最后都能构成更大的 &lt;code&gt;Five&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;23&lt;&#x2F;code&gt; 对应 &lt;code&gt;Full&lt;&#x2F;code&gt; ，无论 &lt;code&gt;J&lt;&#x2F;code&gt; 是两张还是三张，最后都能构成更大的 &lt;code&gt;Five&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;113&lt;&#x2F;code&gt; 对应 &lt;code&gt;Three&lt;&#x2F;code&gt; ，无论 &lt;code&gt;J&lt;&#x2F;code&gt; 是一张还是三张，最后都能构成更大的 &lt;code&gt;Five&lt;&#x2F;code&gt; ，而不是变成 &lt;code&gt;23&lt;&#x2F;code&gt; 的 &lt;code&gt;Full&lt;&#x2F;code&gt; 这不是最优解&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;122&lt;&#x2F;code&gt; &lt;code&gt;1112&lt;&#x2F;code&gt; 和 &lt;code&gt;11111&lt;&#x2F;code&gt; 都是同样的&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;依旧可以在处理输入时就对引入小丑规则的 &lt;code&gt;Hand&lt;&#x2F;code&gt; 和 &lt;code&gt;HandKind&lt;&#x2F;code&gt; 进行处理&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;花了大量的时间在输入处理上，第一部分因为细节上有错误，找了半天，第二部分则是因为一个可恶的生命周期问题，花费了太多时间，最后只好用不那么优雅的方法实现&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;部分代码如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;new&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;count&lt;&#x2F;span&gt;&lt;span&gt;: HashMap&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i8&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; j_count = count.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;remove&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap_or&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; values: Vec&amp;lt;_&amp;gt; = count.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;into_values&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;collect&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    values.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;sort&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; count_number = values.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;iter&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;fold&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, |&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sum&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;i&lt;&#x2F;span&gt;&lt;span&gt;| sum * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10 &lt;&#x2F;span&gt;&lt;span&gt;+ *i) + j_count;
&lt;&#x2F;span&gt;&lt;span&gt;    Ok(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; count_number {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5 &lt;&#x2F;span&gt;&lt;span&gt;=&amp;gt; HandKind::Five,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;14 &lt;&#x2F;span&gt;&lt;span&gt;=&amp;gt; HandKind::Four,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;23 &lt;&#x2F;span&gt;&lt;span&gt;=&amp;gt; HandKind::Full,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;113 &lt;&#x2F;span&gt;&lt;span&gt;=&amp;gt; HandKind::Three,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;122 &lt;&#x2F;span&gt;&lt;span&gt;=&amp;gt; HandKind::Two,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1112 &lt;&#x2F;span&gt;&lt;span&gt;=&amp;gt; HandKind::One,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;11111 &lt;&#x2F;span&gt;&lt;span&gt;=&amp;gt; HandKind::High,
&lt;&#x2F;span&gt;&lt;span&gt;        _ =&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;err!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Wrong hand: {:?}&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, values),
&lt;&#x2F;span&gt;&lt;span&gt;    })
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-8-todo&quot;&gt;Day 8（TODO）&lt;&#x2F;h2&gt;
&lt;p&gt;第一部分直接按照题意思路求解即可，第二部分有以下几种思路。&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;暴力&lt;&#x2F;strong&gt;
&lt;ul&gt;
&lt;li&gt;取得以 A 结尾的所有起始节点，在取得所有以 B 结尾的所有结尾节点&lt;&#x2F;li&gt;
&lt;li&gt;每一次都按照指令对所有当前节点进行遍历，直到当前的所有节点与所有结尾节点相同&lt;&#x2F;li&gt;
&lt;li&gt;但是实际输入巨大，而导致几乎不可能在有限时间内取得结果&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;提前计算&lt;&#x2F;strong&gt;
&lt;ul&gt;
&lt;li&gt;按照第一部分的方法计算出所有的一个启示节点到一个结尾节点需要几步&lt;&#x2F;li&gt;
&lt;li&gt;假如一个起始节点只能到达一个唯一的结尾节点，同时一个结尾节点也只能由一个唯一的起始节点到达，那么第二部分所求的就是这些路径长度的最小公倍数 lcm&lt;&#x2F;li&gt;
&lt;li&gt;题目并未明确的指出起点和结尾是一一对应的，所以理论上是可能存在多种方式达成题意要求，而最后的结果则是这多种方式的最小值&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;huan-jian-ce-suan-fa&quot;&gt;环检测算法&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cycle_detection#Floyd&#x27;s_tortoise_and_hare&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;dfs&quot;&gt;DFS&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;xing-neng-you-hua&quot;&gt;性能优化&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;在环检测时，我直接使用了 HashMap 判断当前节点和指令是否出现过，可以采用环检测算法直接确定环的大小和起点
&lt;ul&gt;
&lt;li&gt;环检测算法实际比 HashMap 的方法要进行更多遍历&lt;&#x2F;li&gt;
&lt;li&gt;环检测算法节省了 HashMap 所需要的内存空间&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;以 HashMap 存储节点的左右节点，这影响了后续对节点路径的搜索的性能。用 Vec 替代 HashMap 存储 NetWork 最后 Debug 的运行时间从 1xx ms → 20ms&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-9&quot;&gt;Day 9&lt;&#x2F;h2&gt;
&lt;p&gt;题目很简单，输入并不复杂，按行解析为数组即可，第一部分直接按照题目要求进行解答即可。第一部分思路如下：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;迭代计算数组相邻两个元素差，将结果存入新的数组，直到新的数组全为 0
&lt;ul&gt;
&lt;li&gt;计算过程中保留每一个数组的最后一个元素到 &lt;code&gt;last&lt;&#x2F;code&gt; 数组&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;当数组全为 &lt;code&gt;0&lt;&#x2F;code&gt; 时，反向计算上一层数组的最后一个元素，直到得到输入数组的最后一个元素
&lt;ul&gt;
&lt;li&gt;设所有每一层数组的预测最后一个元素的数组为 predict 那么有:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;predict[0] - last[0] = predict[1]&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;predict[1] - last[1] = predict[2]&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;直到 &lt;code&gt;predict[n] - last[n] = predict[n + 1]&lt;&#x2F;code&gt;，且 &lt;code&gt;predict[n + 1] = 0&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;将所有等式两边相加得到： &lt;code&gt;(predict[0] + predict[1] + … + predict[n]) -  (last[0] + last[1] + … + last[n]) =  (predict[1] + predict[2] + … + predict[n+1])&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;化简可得 &lt;code&gt;predict[0] = Sum{ last } + predict[n + 1]&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;所以 &lt;code&gt;predict[0] = Sum{ last }&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;可以直接对 &lt;code&gt;last&lt;&#x2F;code&gt; 数组进行求和&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;第二部分要预测输入数组的第一个元素：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;迭代计算数组相邻两个元素差，将结果存入新的数组，直到新的数组全为 0
&lt;ul&gt;
&lt;li&gt;计算过程中保留每一个数组的第一个元素到 &lt;code&gt;first&lt;&#x2F;code&gt; 数组&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;当数组全为 &lt;code&gt;0&lt;&#x2F;code&gt; 时，反向计算上一层的数组的第一个元素，直到得到输入数组的第一个元素
&lt;ul&gt;
&lt;li&gt;设所有每一层数组的预测第一个一个元素的数组为 predict 那么有:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;first[0] - predict[0] = predict[1]&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;first[1] - predict[1] = predict[2]&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;直到 &lt;code&gt;first[n] - predict[n] = predict[n + 1]&lt;&#x2F;code&gt;，且 &lt;code&gt;predict[n + 1] = 0&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;为了避免计算每一个 predict 值，可以每隔一个等式改变等式两边的符号，再对所有等式进行累加&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;(first[0] - predict[0]) + (first[1] - predict[1]) = predict[1] - predict[2]&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;化简可得 &lt;code&gt;first[0] - first[1] = predict[0] - predict[1]&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;依次类推可得 &lt;code&gt;first[0] - first[1] + first[2] -first[3] + … + fisrt[n-1] - first[n] = predict[0] - predict[n + 1]&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;实际上第二部分存在一种取巧的方法，可以将输入的每一个数组都进行倒序，然后按照第一部分方法计算即可。&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;day-10&quot;&gt;Day 10&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;brute-force-and-bfs-code&quot;&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;Brute Force and BFS [&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;livexia&#x2F;advent-of-code-2023&#x2F;blob&#x2F;51559bfee7d0b08eccb3ca62c77e078c6ca4d583&#x2F;aoc10&#x2F;src&#x2F;main.rs&quot;&gt;code&lt;&#x2F;a&gt;]&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;并没有按照方向前进&lt;&#x2F;li&gt;
&lt;li&gt;而是遍历当前 &lt;code&gt;Pipe&lt;&#x2F;code&gt; 四周所有的 &lt;code&gt;Pipe&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;根据两个 &lt;code&gt;Pipe&lt;&#x2F;code&gt; 的链接情况确定下一个 &lt;code&gt;Pipe&lt;&#x2F;code&gt; 的位置&lt;&#x2F;li&gt;
&lt;li&gt;递归遍历&lt;strong&gt;没有访问（搜索）过的位置&lt;&#x2F;strong&gt;，直到无法确定下一个 &lt;code&gt;Pipe&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;因为不确定起始点的 &lt;code&gt;Pipe&lt;&#x2F;code&gt; 类型，起始点的 &lt;code&gt;Pipe&lt;&#x2F;code&gt; 可与邻接的四个 &lt;code&gt;Pipe&lt;&#x2F;code&gt; 都连通&lt;&#x2F;li&gt;
&lt;li&gt;使用 &lt;code&gt;BFS&lt;&#x2F;code&gt; ，确定 &lt;code&gt;BFS&lt;&#x2F;code&gt; 最长路径长度，第一部分的结果是最长路径长度的一半&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;move-along-and-dfs-bfs-dfs-bfs&quot;&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;Move along and DFS&#x2F;BFS [&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;livexia&#x2F;advent-of-code-2023&#x2F;blob&#x2F;74afe4cc89c7fcb143d1c9da6da1c93e53eb06ab&#x2F;aoc10&#x2F;src&#x2F;main.rs&quot;&gt;DFS&lt;&#x2F;a&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&#x2F;BFS]&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;根据水管的方向进行移动&lt;&#x2F;li&gt;
&lt;li&gt;初始时同样存在四种可能的移动方向&lt;&#x2F;li&gt;
&lt;li&gt;根据移动方向计算下一个位置坐标&lt;&#x2F;li&gt;
&lt;li&gt;取得下一个位置坐标处的水管类型，确定移动方向是否能与该水管连通&lt;&#x2F;li&gt;
&lt;li&gt;如果无法连通，则当前最初的移动方向存在错误&lt;&#x2F;li&gt;
&lt;li&gt;如果可以连通，则更新当前坐标，同时根据水管类型更新移动方向
&lt;ul&gt;
&lt;li&gt;第一部分可以只计算路径长度，也可以保留所有连通水管的坐标，第二部分实际上是需要所有连通水管的坐标的&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;直到回到原点&lt;&#x2F;strong&gt;，表明初始的移动方向正确，结合最后的移动方向，可以确定初始水管的类型&lt;&#x2F;li&gt;
&lt;li&gt;可以用 BFS 或者 DFS 实现，不过 DFS 可能会栈溢出&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;第一部分上述两种思路和方法都可以得出正确的解，但是对于第二部分，实际上第二种方法更加合理，从思路和逻辑上看也是第二种方法更加清晰，更容易理解题意。尝试在第一种方法的基础上实现第二部分，耗费了我大量的时间，同时因为这种方法存在混乱，使得迟迟无法对第二部分作出有效的解答，所以狠下心来重新按照第二种方法解决了第一部分，也较容易得处了第二部分所需要的循环路径上的节点，当然第二部分也依旧没有因此而快速解决，&lt;strong&gt;以下几种解决第二部分的方法，我只实现了第一种 Double Resolution &#x2F; Flood Fill ，其余的方法都来自 Reddit ，我认为都是要优于我自己想到的方法。&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;double-resolution-flood-fill-code&quot;&gt;&lt;strong&gt;Double Resolution&lt;&#x2F;strong&gt; &#x2F; &lt;strong&gt;Flood Fill [&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;livexia&#x2F;advent-of-code-2023&#x2F;blob&#x2F;6a43dbb06d8346383f1d85f887dd4ba42221927e&#x2F;aoc10&#x2F;src&#x2F;main.rs#L187-L253&quot;&gt;code&lt;&#x2F;a&gt;]&lt;&#x2F;strong&gt;&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;利用上述第一部分的第二种方法，计算循环的路径保存为 &lt;code&gt;loop_path&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;两倍放大网格，在原由的每一个&lt;code&gt;Tile&lt;&#x2F;code&gt; 四周填入新的 &lt;code&gt;Tile&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;构造二维数组表示网格，为 &lt;code&gt;expand_map&lt;&#x2F;code&gt; ，元素为 &lt;code&gt;1&lt;&#x2F;code&gt; 表示处于循环，元素为 &lt;code&gt;0&lt;&#x2F;code&gt; 表示被循环包含，元素为 &lt;code&gt;2&lt;&#x2F;code&gt; 则表示不被循环包含
&lt;ul&gt;
&lt;li&gt;也可以使用 &lt;code&gt;false&lt;&#x2F;code&gt; 表示不被包含，&lt;code&gt;true&lt;&#x2F;code&gt; 表示被包含，但是在判断过程中，要将补齐的 &lt;code&gt;Pipe&lt;&#x2F;code&gt; 间的节点加入到所有的循环节点中，再确定当前的搜索节点是是否处于循环中&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;因为网格被放大了，在初始化 &lt;code&gt;expand_map&lt;&#x2F;code&gt; 时，要注意 &lt;code&gt;Pipe&lt;&#x2F;code&gt; 的坐标需要两倍放大
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;expand_map[x1 as usize * 2][y1 as usize * 2] = 1&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;同时需要补齐 Pipe 间的连接
&lt;ul&gt;
&lt;li&gt;依次比较循环路径 &lt;code&gt;loop_path&lt;&#x2F;code&gt; 中的前后水管&lt;&#x2F;li&gt;
&lt;li&gt;如果水管处于同一行，那么需要补齐左右两个水管间的节点&lt;&#x2F;li&gt;
&lt;li&gt;如果水管处于同一列，那么需要补齐上下两个水管间的节点&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;同时要对 &lt;code&gt;expand_map&lt;&#x2F;code&gt; 的四边进行初始化，四个边上所有不是循环路径（补齐后）的元素都应当为 &lt;code&gt;2&lt;&#x2F;code&gt; ，即未被循环包含&lt;&#x2F;li&gt;
&lt;li&gt;完成了 &lt;code&gt;expand_map&lt;&#x2F;code&gt; 的初始化后，可以从四边未被循环包含的节点开始搜索，当前搜索节点的四个邻接节点中为 &lt;code&gt;0&lt;&#x2F;code&gt; 的节点置为 &lt;code&gt;2&lt;&#x2F;code&gt; 即可，利用 BFS 或者 DFS 完全全部搜索&lt;&#x2F;li&gt;
&lt;li&gt;最后将 &lt;code&gt;expand_map&lt;&#x2F;code&gt; 缩小，去除所有奇数行和奇数列的节点，统计所有为 &lt;code&gt;0&lt;&#x2F;code&gt; 的节点数量即是第二部分的解&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;line-crossing-ray-casting-shoelace-theorem-code&quot;&gt;Line Crossing (&lt;strong&gt;Ray Casting) &#x2F; Shoelace Theorem? [&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;livexia&#x2F;advent-of-code-2023&#x2F;blob&#x2F;9bb4e26da49eece00fccc432614d83b886cac76e&#x2F;aoc10&#x2F;src&#x2F;main.rs#L287-L322&quot;&gt;code&lt;&#x2F;a&gt;]&lt;&#x2F;strong&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;这个方法我根本没想到，记忆里往年也是有用这个方法的，这个方法不算是平时算法练习里会出现的，感觉上这个方法是正确的，但是并没有阅读过完整的证明，即我&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;只知其然，不知其所以然&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;参，考链接如下：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;https:&#x2F;&#x2F;old.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;18evyu9&#x2F;2023_day_10_solutions&#x2F;kcr28lt&#x2F;&lt;&#x2F;li&gt;
&lt;li&gt;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ray_casting&lt;&#x2F;li&gt;
&lt;li&gt;https:&#x2F;&#x2F;gamedev.stackexchange.com&#x2F;questions&#x2F;141460&#x2F;how-can-i-fill-the-interior-of-a-closed-loop-on-a-tile-map&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;算法概述&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;想象从闭合曲线外的一个点发射一条直线与曲线相交&lt;&#x2F;li&gt;
&lt;li&gt;当直线与曲线未相交时，直线的所有部分都在闭合曲线外&lt;&#x2F;li&gt;
&lt;li&gt;当直线与曲线相交一次，发射点到交点部分都在闭合曲线外，而交点到当前直线末端的部分在闭合曲线内&lt;&#x2F;li&gt;
&lt;li&gt;当直线与曲线相交两次时，第一个交点到第二个交点部分都在闭合曲线内，而第二个交点到当前直线末端的部分在闭合曲线外&lt;&#x2F;li&gt;
&lt;li&gt;以此类推，可以发现对于所有的&lt;strong&gt;奇数 N ，第 N 个交点到第 N + 1 个交点间的直线线段都在曲线内&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;li&gt;也可以换一种思路&lt;&#x2F;li&gt;
&lt;li&gt;想象从闭合曲线外的一个点发射一条直线与曲线相交，初始闭合曲线入度为 0，出度为 0&lt;&#x2F;li&gt;
&lt;li&gt;当直线与曲线第一次相交时，闭合曲线的入度加 1 ，为 1&lt;&#x2F;li&gt;
&lt;li&gt;当直线与曲线第二次相交时，闭合曲线的出度加 1 ，为 1&lt;&#x2F;li&gt;
&lt;li&gt;即每当奇数次相交时，入度加 1 ，而偶数次相交时，出度加 1&lt;&#x2F;li&gt;
&lt;li&gt;当入度和出度相同的时候，直线的这部分不被曲线包含&lt;&#x2F;li&gt;
&lt;li&gt;当入度比出度大一的时候，直线的这部分被曲线包含&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;具体思路&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;依旧利用上述第一部分的第二种方法，计算循环的路径保存为 &lt;code&gt;loop_path&lt;&#x2F;code&gt; ，结果保存在 &lt;code&gt;result&lt;&#x2F;code&gt; 中&lt;&#x2F;li&gt;
&lt;li&gt;按行遍历网格，即从当前行的最左侧向右发射直线，默认相交计数为 0 ，即 &lt;code&gt;crossing_count = 0&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;依次按行向右判断，如果当前节点为 &lt;code&gt;Pipe&lt;&#x2F;code&gt; ，说明当前行与循环相交或者相切&lt;&#x2F;li&gt;
&lt;li&gt;如果当前 &lt;code&gt;Pipe&lt;&#x2F;code&gt; 为 &lt;code&gt;-&lt;&#x2F;code&gt; 那么就是相切，不必考虑&lt;&#x2F;li&gt;
&lt;li&gt;如果当前 &lt;code&gt;Pipe&lt;&#x2F;code&gt; 为 &lt;code&gt;|&lt;&#x2F;code&gt; 那么必然相交，相交计数加一 &lt;code&gt;crossing_count += 1&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;当 &lt;code&gt;Pipe&lt;&#x2F;code&gt; 为弯角即 &lt;code&gt;F J L 7&lt;&#x2F;code&gt; 的一种时，需要考虑上一次遇见的弯角水管 &lt;code&gt;last_corner&lt;&#x2F;code&gt;
&lt;ul&gt;
&lt;li&gt;如果&lt;code&gt;last_corner == F &amp;amp;&amp;amp; pipe == J&lt;&#x2F;code&gt; ，是竖着的折现，那么是相交的情况 &lt;code&gt;crossing_count += 1&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;如果&lt;code&gt;last_corner == F &amp;amp;&amp;amp; pipe == 7&lt;&#x2F;code&gt; ，是 U 型管，可以想象当前行实际上是跟着水管走了，那么是相切的情况，不必考虑&lt;&#x2F;li&gt;
&lt;li&gt;如果&lt;code&gt;last_corner == L &amp;amp;&amp;amp; pipe == 7&lt;&#x2F;code&gt; ，是竖着的折现，那么是相交的情况 &lt;code&gt;crossing_count += 1&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;如果&lt;code&gt;last_corner == L &amp;amp;&amp;amp; pipe == J&lt;&#x2F;code&gt; ，是倒的 U 型管，可以想象当前行实际上是跟着水管走了，那么是相切的情况，不必考虑&lt;&#x2F;li&gt;
&lt;li&gt;对四种情况进行分析，可以发现只需要在当前水管是 7 或 J 的时候对相交计数加一 &lt;code&gt;crossing_count += 1&lt;&#x2F;code&gt; 即可，无需记录上次遇见的弯角水管&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;more-solutions&quot;&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;More Solutions&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;计算机图像处理?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https:&#x2F;&#x2F;old.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;18evyu9&#x2F;2023_day_10_solutions&#x2F;kcqufnn&#x2F;&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;PaigePalisade&#x2F;AdventOfCode2023&#x2F;blob&#x2F;main&#x2F;Solutions&#x2F;day10part2.c&quot;&gt;Part 2&lt;&#x2F;a&gt; was a bit of a struggle for me. At some point I figured that the best way of solving it was to print the path with box building unicode characters, put a screenshot of it into gimp, fill the inside of the path with the fill tool, and then count the number of periods in the filled region. For some reason, this didn&#x27;t work and I&#x27;m not going to debug that janky solution.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;标记循环移动方向同一侧邻接节点（未实现）&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;从循环起点顺时针或者逆时针前进时，前进方向同一侧（右侧或左侧）的所有节点要么被循环包含，要么不被循环包含&lt;&#x2F;li&gt;
&lt;li&gt;标记前进方向同一侧（右侧或左侧）的节点&lt;&#x2F;li&gt;
&lt;li&gt;对这些标记节点进行 BFS 或 DFS 对所有邻接且不在循环上的节点进行标记，直到完成所有节点的遍历&lt;&#x2F;li&gt;
&lt;li&gt;判断左上角第一个节点是否被标记
&lt;ul&gt;
&lt;li&gt;如果被标记则意味着该节点不在循环上，同时该节点接墙，那么所有标记的节点都不被循环包含，所有节点数减去循环节点数再减去标记节点数，即是被循环包含的节点&lt;&#x2F;li&gt;
&lt;li&gt;如果不被标记，那么该节点原来应当是 Pipe ，同时也处于循环，那么所有标记的节点都应当被循环包含，直接统计标记节点数即可&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;https:&#x2F;&#x2F;old.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;18evyu9&#x2F;2023_day_10_solutions&#x2F;kcqnr5i&#x2F;
&lt;ul&gt;
&lt;li&gt;https:&#x2F;&#x2F;github.com&#x2F;yangdanny97&#x2F;advent-of-code-2023-rust&#x2F;blob&#x2F;main&#x2F;src&#x2F;day10&#x2F;mod.rs&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;day-11-code&quot;&gt;Day 11 [&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;livexia&#x2F;advent-of-code-2023&#x2F;blob&#x2F;main&#x2F;aoc11&#x2F;src&#x2F;main.rs&quot;&gt;code&lt;&#x2F;a&gt;]&lt;&#x2F;h3&gt;
&lt;p&gt;今天的题目思路简单明了，输入为网格，记录其中字符为 &lt;code&gt;#&lt;&#x2F;code&gt; 的位置，第一部分要求将网格的中不包含任何的行和列都翻倍，而第二部分则是将这个倍数增加到 &lt;code&gt;1000000&lt;&#x2F;code&gt; 倍，要求计算翻倍后每一对唯一的 &lt;code&gt;#&lt;&#x2F;code&gt; 间的最短距离。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;网格翻倍：&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;

- 第一第二部分仅有扩张倍率不同，设变量 &lt;code&gt;expansion_rate&lt;&#x2F;code&gt; 表示&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;可以先考虑对行进行翻倍，再以同样的方式考虑列&lt;&#x2F;li&gt;
&lt;li&gt;初始 &lt;code&gt;empty_row = 0&lt;&#x2F;code&gt; 即当前未遇到任何不包含 &lt;code&gt;#&lt;&#x2F;code&gt; 的行&lt;&#x2F;li&gt;
&lt;li&gt;遍历每一行&lt;&#x2F;li&gt;
&lt;li&gt;对当前行上所有的 &lt;code&gt;#&lt;&#x2F;code&gt; 的坐标进行扩大， &lt;code&gt;(x, y) → (x * empty_row * (expansion_rate - 1))&lt;&#x2F;code&gt;
&lt;ul&gt;
&lt;li&gt;要注意要对 &lt;code&gt;expansion_rate - 1&lt;&#x2F;code&gt; ，因为是变为 &lt;code&gt;expansion_rate&lt;&#x2F;code&gt; 倍，而不是增加&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;如果当前行上没有任何的 &lt;code&gt;#&lt;&#x2F;code&gt; 则对空行计数加一， &lt;code&gt;empty_row += 1&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;最短距离&lt;&#x2F;strong&gt;：因为是网格，同时网格间并不存在任何阻碍，所以直接计算曼哈顿距离即可 $D=∣x1​−x2​∣+∣y1​−y2​∣$&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;性能优化&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;：利用 &lt;code&gt;HashSet&lt;&#x2F;code&gt; 保存 &lt;code&gt;#&lt;&#x2F;code&gt; 的坐标，固然可以在查找时避免麻烦，但是在这个问题中完全没有必要，可以直接用 &lt;code&gt;Vec&lt;&#x2F;code&gt; 保存。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;day-12-todo&quot;&gt;Day 12 (TODO)&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;dfs-with-cache-code-dp&quot;&gt;&lt;strong&gt;DFS with Cache [&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;livexia&#x2F;advent-of-code-2023&#x2F;blob&#x2F;cb7133436a0e11be14d1e5a299024265af503ba6&#x2F;aoc12&#x2F;src&#x2F;main.rs&quot;&gt;code&lt;&#x2F;a&gt;] =&lt;&#x2F;strong&gt; DP ?&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;https:&#x2F;&#x2F;old.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;18ge41g&#x2F;2023_day_12_solutions&#x2F;kd0um89&#x2F;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;if springs[i] == ‘.’ dp[i] = dp[i - 1]&lt;&#x2F;p&gt;
&lt;p&gt;if springs[i] ≠ ‘.’ count += 1&lt;&#x2F;p&gt;
&lt;h3 id=&quot;rust&quot;&gt;Rust @&lt;&#x2F;h3&gt;
&lt;p&gt;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch18-03-pattern-syntax.html#-bindings&lt;&#x2F;p&gt;
&lt;h2 id=&quot;day-13&quot;&gt;Day 13&lt;&#x2F;h2&gt;
&lt;p&gt;题意要求查找矩阵的对称轴，题目并不难，逻辑很简单，因为对称轴可能是出现在行上也可能是出现在列上，可以先计算一个方向上的对称轴，再将矩阵转置在重复计算即可，直接暴力实现。&lt;&#x2F;p&gt;
&lt;p&gt;虽然题目的输入处理很简单，同时逻辑也不复杂，输入的数据量也不大，所以理论上应该是很容易的题目，但是我在第二部分卡了很长时间，原因就是在第二部分题意的理解上，第二部分有一句题目描述为 “you discover that every mirror has &lt;strong&gt;exactly&lt;&#x2F;strong&gt; one smudge” ，我没能注意到其中的关键词 &lt;strong&gt;exactly&lt;&#x2F;strong&gt; 以致于浪费了太多的时间，具体思路[&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;livexia&#x2F;advent-of-code-2023&#x2F;blob&#x2F;e512830206b964989fcafc9127effd2746b436c9&#x2F;aoc13&#x2F;src&#x2F;main.rs&quot;&gt;code&lt;&#x2F;a&gt;]如下：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;以查找垂直方向（列）的对称轴为例，遍历所有可能的对称轴位置 &lt;code&gt;i&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;因为对称轴一定位于两个元素之间，而不在矩阵上，则令&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;left = i - 1&lt;&#x2F;code&gt; 和 &lt;code&gt;right = i&lt;&#x2F;code&gt; 同时不同计数器 &lt;code&gt;diff_cnt=0&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;对于每一对 &lt;code&gt;left&lt;&#x2F;code&gt; 和 &lt;code&gt;right&lt;&#x2F;code&gt; 遍历每一行，如果当前行上 left 和 right 位置处元素不同&lt;&#x2F;li&gt;
&lt;li&gt;对计数器 &lt;code&gt;diff_cnt&lt;&#x2F;code&gt; 加一
&lt;ul&gt;
&lt;li&gt;第一部分：此时表示当前对位置 &lt;code&gt;i&lt;&#x2F;code&gt; 一定不可能时对称轴，可以直接检测 &lt;code&gt;i + 1&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;直到 &lt;code&gt;left&lt;&#x2F;code&gt; 或者 &lt;code&gt;right&lt;&#x2F;code&gt; 到达边界&lt;&#x2F;li&gt;
&lt;li&gt;第一部分要求查找对称轴左侧（上方）的列（行）的数量，结果即是对于对称轴 &lt;code&gt;i&lt;&#x2F;code&gt; ，最终 &lt;code&gt;diff_cnt&lt;&#x2F;code&gt; 为 &lt;code&gt;0&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;第二部分要求在矩阵中允许&lt;strong&gt;有且仅有一对元素不对称&lt;&#x2F;strong&gt;，计算此时的对称轴 &lt;code&gt;i&lt;&#x2F;code&gt; ，思路和第一部分一致，结果即是对于对称轴 &lt;code&gt;i&lt;&#x2F;code&gt; ，最终 &lt;code&gt;diff_cnt&lt;&#x2F;code&gt; 为 &lt;code&gt;1&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;xing-neng-you-hua-1&quot;&gt;性能优化&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;利用数字表示矩阵的每一行和每一列，同时用位运算进对称比较 [&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;livexia&#x2F;advent-of-code-2023&#x2F;blob&#x2F;8857d18cedb88ae689b00f48bee082797e86a8f5&#x2F;aoc13&#x2F;src&#x2F;main.rs&quot;&gt;code&lt;&#x2F;a&gt;]&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;输入的矩阵只包含两种不同的字符，同时输入矩阵的长和宽的大小均在数字可表示的范围内&lt;&#x2F;li&gt;
&lt;li&gt;二进制数字每一位表示该行（列）在该位置上的字符&lt;&#x2F;li&gt;
&lt;li&gt;对比两行本来需要遍历两行，进行元素的一一比对，统计不同的数量，而利用数字表示之后&lt;&#x2F;li&gt;
&lt;li&gt;只需要对两个数字进行异或运算，结果的二进制表示中 1 的数量即是不同的数量&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-14-code&quot;&gt;Day 14 [&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;livexia&#x2F;advent-of-code-2023&#x2F;blob&#x2F;main&#x2F;aoc14&#x2F;src&#x2F;main.rs&quot;&gt;code&lt;&#x2F;a&gt;]&lt;&#x2F;h2&gt;
&lt;p&gt;第二部分涉及环检测，使用了第八天里也用到的环检测算法，计算环的起始点和大小，再取得最后结果，题目并不难，但最后我对性能并不是特别的满意，所以在具体平台倾斜的实现上进行了优化。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;huan-jian-ce-suan-fa-code&quot;&gt;环检测算法 [&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;livexia&#x2F;advent-of-code-2023&#x2F;blob&#x2F;aff91ffe7fa0ec97538af098d6a791babe078f95&#x2F;aoc14&#x2F;src&#x2F;main.rs#L111-L134&quot;&gt;code&lt;&#x2F;a&gt;]&lt;&#x2F;h3&gt;
&lt;p&gt;往年我都是要用哈希表进行环检测，今年遇到环的问题，我都选择用快慢指针算法实现，相比于哈希表，两种方法的对比：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;哈希表进行环检测时，要确保键值的设置合理，在这个问题里如果只将计算出的 load 值作为键值，会错误的检测到环，而如果用平台当前的状态（Vec）作为键值则又要考虑可能的内存消耗。如果循环较小这个问题还不严重，但是如果循环较大，那么利用哈希表也许就不可行。&lt;&#x2F;li&gt;
&lt;li&gt;用 Floyd 的快慢指针算法，虽然在检测的过程中，需要使用两个指针进行移动，也许检测中所需的指令较多，但是检测过程中最多只需要保存两个状态（如果算上初始状态，那么就是三个状态），内存消耗较少。&lt;&#x2F;li&gt;
&lt;li&gt;哈希表环检测使用空间换时间，而快慢指针算法则是用时间换空间&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;Floyd 快慢指针&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;虽然是快慢指针，但是这个算法适用于所有的环检测，而不仅限于链表，指针指代的是状态转换，以下用乌龟表示慢指针，兔子表示快指针&lt;&#x2F;li&gt;
&lt;li&gt;算法概述：龟兔赛跑，分成三个部分：检测环，确定环入口，确定环大小&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;检测环&lt;&#x2F;strong&gt;
&lt;ul&gt;
&lt;li&gt;乌龟，以正常的速度跳转到下一个状态&lt;&#x2F;li&gt;
&lt;li&gt;兔子，以两倍的速度跳转&lt;&#x2F;li&gt;
&lt;li&gt;如果过程中两个状态相同，那么说明存在环&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;确定环入口&lt;&#x2F;strong&gt;
&lt;ul&gt;
&lt;li&gt;此时将乌龟放回起点，兔子和乌龟都以正常的速度跳转到下一个状态&lt;&#x2F;li&gt;
&lt;li&gt;当乌龟和兔子再次相遇，此时兔子的位置就是环的入口&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;确定环大小&lt;&#x2F;strong&gt;
&lt;ul&gt;
&lt;li&gt;兔子不动，乌龟以正常速度跳转&lt;&#x2F;li&gt;
&lt;li&gt;再次相遇时，兔子跳转的距离即是环的大小&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;这个算法只属于能用的情况，具体的证明还需要进一步学习&lt;&#x2F;li&gt;
&lt;li&gt;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cycle_detection#Floyd&#x27;s_tortoise_and_hare&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;xing-neng-you-hua-2&quot;&gt;性能优化&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当前倾斜平台的实现是按照模拟的方式，矩阵平台倾斜的情况&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;**代码重构：**第二部分需要向四个方向倾斜，最初我直接复制黏贴实现了四个函数，可以将四个函数进行合并，合并之后性能有所下降 &lt;strong&gt;700ms → 1s&lt;&#x2F;strong&gt; 。[&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;livexia&#x2F;advent-of-code-2023&#x2F;commit&#x2F;f13789ce924e2d3452d4c0baac92fa6470885d23&quot;&gt;code&lt;&#x2F;a&gt;]&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;倾斜过程中圆石没有一次移动到位，而是一个位置一个位置的移动，可以直接一步到位，避免不必要的修改，性能提升不明显 &lt;strong&gt;1s → 900ms&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;考虑一行石头滚到右侧的情况，当前的逻辑是从最右侧的圆石开始移动，计算新的位置，虽然不是一个位置一个位置的移动，但是依旧是一个位置一个位置的比较，应当有更优解：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;以行 &lt;code&gt;OOOO…#&lt;&#x2F;code&gt;  为例初始时位置为各个位置 0 1 2 3 4 5 6 7&lt;&#x2F;li&gt;
&lt;li&gt;最右侧的第一个圆石位置为 3 ，右侧与它最近的石头位置为 7，移动后圆石新的位置为 6&lt;&#x2F;li&gt;
&lt;li&gt;移动右侧第二个圆石时，理他最近的石头位置为 6 ，所以它新的位置为 5，依次类推&lt;&#x2F;li&gt;
&lt;li&gt;代码如下&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;tilt_north&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;platform&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; [Vec&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;char&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;]) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; j in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;..platform[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;].&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; last_possible = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; i in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;..platform.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; platform[i][j] == &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;#&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39; {
&lt;&#x2F;span&gt;&lt;span&gt;                last_possible = i + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;            } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else if&lt;&#x2F;span&gt;&lt;span&gt; platform[i][j] == &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;O&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39; {
&lt;&#x2F;span&gt;&lt;span&gt;                platform[i][j] = &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;;
&lt;&#x2F;span&gt;&lt;span&gt;                platform[last_possible][j] = &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;O&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;;
&lt;&#x2F;span&gt;&lt;span&gt;                last_possible += &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;在四个方向上应用新的移动算法，虽然需要在四个方向上分别存在以一个函数，但是性能提升明显 &lt;strong&gt;900ms → 500ms&lt;&#x2F;strong&gt; 。[&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;livexia&#x2F;advent-of-code-2023&#x2F;commit&#x2F;2279c94738b3e9134d33da64d77f842a5c9bd551&quot;&gt;code&lt;&#x2F;a&gt;]&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;也许可以使用数字代表平台的每一行？&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;矩阵每一个位置有3种情况：圆石 &lt;code&gt;O&lt;&#x2F;code&gt;、方石 &lt;code&gt;#&lt;&#x2F;code&gt; 和空地 &lt;code&gt;.&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;如果 1 表示当前位为石头，0 表示空地，那么就需要额外维护一个列表记录所有圆石的位置
&lt;ul&gt;
&lt;li&gt;某种程度上而言，这又是二维？&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;也许可以优化环检测中的状态对比？当前是直接比较两个 Vec ，好在 Vec 并不大&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-15&quot;&gt;Day 15&lt;&#x2F;h2&gt;
&lt;p&gt;第一部分需要实现哈希，第二部分则需要实现类似于哈希表。第一部分按照题意实现即可，第二部分的题意有点复杂，但是理解题意之后其实也是很简单的。输入的数据量也不大，直接实现即可。第一部分不需要说明，简单说明第二部分：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;输入字符串由逗号隔开分成一个一个部分&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;每一个部分由两到三个部分组成，初始连续的字符为镜头的标识符 &lt;code&gt;label&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;紧接着是 &lt;code&gt;=&lt;&#x2F;code&gt; 或 &lt;code&gt;-&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;=&lt;&#x2F;code&gt; 对应增加或更新操作&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;-&lt;&#x2F;code&gt; 对应删操作&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;focal length 在最后的结果计算中需要&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;将每个部分的字符串转为 &lt;code&gt;ascii&lt;&#x2F;code&gt; 码，然后进行分割，分割实现如下：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;直接根据是否能够从中解析出 focal length 来确定当前操作是 &lt;code&gt;=&lt;&#x2F;code&gt; 还是 &lt;code&gt;-&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;step_to_instr&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;step&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;]) -&amp;gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;, Option&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; i = step.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;iter&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;position&lt;&#x2F;span&gt;&lt;span&gt;(|&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;c&lt;&#x2F;span&gt;&lt;span&gt;| c == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39; || c == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;-&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; k = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;hash&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;step[..i]);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; v = step.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;get&lt;&#x2F;span&gt;&lt;span&gt;(i + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;map&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;n&lt;&#x2F;span&gt;&lt;span&gt;| (n - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;) as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    assert!(i &amp;lt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span&gt;); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; usize is u64, max lable length is 8
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; label = step[..i].&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;iter&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;fold&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, |&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;l&lt;&#x2F;span&gt;&lt;span&gt;, &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;| l * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;256 &lt;&#x2F;span&gt;&lt;span&gt;+ b as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    (k, label, v)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;label&lt;&#x2F;code&gt; 字符串的哈希值表示当前镜头需要放置哪一个 &lt;code&gt;box&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;=&lt;&#x2F;code&gt; 之后还有一个数字，表示镜头的 focal length&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;=&lt;&#x2F;code&gt; 代表需要将对应镜头和对应的 focal length值放到对应的 &lt;code&gt;box&lt;&#x2F;code&gt; 中
&lt;ul&gt;
&lt;li&gt;如果对应镜已经存在，那么修改原有 focal length 为新的值&lt;&#x2F;li&gt;
&lt;li&gt;如果不存在则将当前镜头放置到最末端&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-&lt;&#x2F;code&gt; 之后则什么都没有&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-&lt;&#x2F;code&gt; 表示需要从对应的 &lt;code&gt;box&lt;&#x2F;code&gt; 中移除对应镜头&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;用二维 &lt;code&gt;Vec&amp;lt;Vec&amp;lt;(label, focal legth)&amp;gt;&amp;gt;&lt;&#x2F;code&gt; 表示所有的 &lt;code&gt;box&lt;&#x2F;code&gt; 和其中的镜头&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;我的实现中 &lt;code&gt;label&lt;&#x2F;code&gt; 的数据类型是 &lt;code&gt;usize&lt;&#x2F;code&gt; ，避免了构造 String 但是同样的镜头标识长度不能超过 8 。&lt;code&gt;let label = step[..i].iter().fold(0, |l, &amp;amp;b| l * 256 + b as usize);&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;利用 position 确定当前镜头标识是否已经在 box 中，如果在取得索引值，再根距对应的 &lt;code&gt;=&lt;&#x2F;code&gt; 和 &lt;code&gt;-&lt;&#x2F;code&gt; 进行更新&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;部分处理代码如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; map = vec![vec![]; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;256&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; step in steps {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;(k, l, v) = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;step_to_instr&lt;&#x2F;span&gt;&lt;span&gt;(step);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; p = map[k].&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;iter&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;position&lt;&#x2F;span&gt;&lt;span&gt;(|(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;i&lt;&#x2F;span&gt;&lt;span&gt;, _)| i == &amp;amp;l);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match &lt;&#x2F;span&gt;&lt;span&gt;(v, p) {
&lt;&#x2F;span&gt;&lt;span&gt;        (Some(f), None) =&amp;gt; map[k].&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;((l, f)),
&lt;&#x2F;span&gt;&lt;span&gt;        (Some(f), Some(i)) =&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;            map[k][i] = (l, f);
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        (None, Some(i)) =&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;            map[k].&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;remove&lt;&#x2F;span&gt;&lt;span&gt;(i);
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        _ =&amp;gt; (),
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;day-16&quot;&gt;Day 16&lt;&#x2F;h2&gt;
&lt;p&gt;今天的问题并不难，光线按照方向移动，根据新位置处可能的镜子调整移动方向，计算光线移动的路径，除了方向的改变，光线在遇到特定的镜子时还会产生分裂，我通过利用 BFS 实现了第一部分。第二部分是在第一部分之上计算从四周发出光线，每个位置发出光线移动路径的最大值。唯一需要注意的点就是光线的起始点，如果光线在起始点就遇到了镜子，那就需要根据镜子先调整方向。这点可以通过在平台外设置一个虚拟的起点解决，也可以首先对起点和起点处的镜子计算下一个可能的方向。代码的实现很简单，可是性能却并不好，第二部分主要的运行时间都是在 BFS 中对当前状态的访问情况进行检查上，而我在尝试提升性能时引入了错误的逻辑，导致性能提升，但是结果错误。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;错误&lt;&#x2F;strong&gt;的调整：&lt;strong&gt;&lt;del&gt;调整了 BFS 中 visited 的检测位置，代码运行时间从 4s → 80ms [&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;livexia&#x2F;advent-of-code-2023&#x2F;commit&#x2F;2d21d515193a26817ee6f237e4f89d474a65654f&quot;&gt;code&lt;&#x2F;a&gt;]&lt;&#x2F;del&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;出队检测&lt;&#x2F;strong&gt;：左侧代码先将下一个状态推入队列，等到再次从队列中取出时再检测状态是否在 &lt;code&gt;visited&lt;&#x2F;code&gt;
&lt;ul&gt;
&lt;li&gt;因为是出队时检测，那么队列中就会存在多个重复的状态&lt;&#x2F;li&gt;
&lt;li&gt;https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;45643883&lt;&#x2F;li&gt;
&lt;li&gt;https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;25992077&lt;&#x2F;li&gt;
&lt;li&gt;https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;63322362&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;入队检测&lt;&#x2F;strong&gt;：右侧则是确定&lt;strong&gt;下一个状态&lt;&#x2F;strong&gt;不在 &lt;code&gt;visited&lt;&#x2F;code&gt; 中后，再推入队列
&lt;ul&gt;
&lt;li&gt;右侧代码保证队列中的每一个状态都是未被访问过的，队列中重复的元素更少，这控制了队列的大小，相应的也就减少了 &lt;code&gt;insert&lt;&#x2F;code&gt; 的操作次数&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;对左右两种实现统计 visited 的大小，可以发现左侧代码中 visited 大小可以比右侧 visited 大百倍 (11117 vs 57)，&lt;strong&gt;如果仅仅是因为检测时机的问题不应该会导致 visited 大小有剧烈的变化&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;右侧的代码理论上应该是错误，实际上右侧代码的 for 循环是没有必要的，它只将其中一个状态加入队列，实际上是减少了遍历的分支。&lt;del&gt;理论上这是错误的，但是为何运行结果是对的？&lt;&#x2F;del&gt;&lt;&#x2F;strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;visited.insert((pos, dir))&lt;&#x2F;code&gt; 应该是 &lt;code&gt;visited.insert((next, n_d))&lt;&#x2F;code&gt; 才对&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;理论上一个状态经过反弹最多存在两种状态，当光线是向左或向右遇到 &lt;code&gt;|&lt;&#x2F;code&gt; 时会产生两种新的状态，或者是当光线是向上或向下遇到 &lt;code&gt;-&lt;&#x2F;code&gt; 时也会产生两种新的状态。右侧错误的代码实际上之旅两种状态中的第一种，直接忽略了可能的第二种情况。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;livexia&#x2F;advent-of-code-2023&#x2F;assets&#x2F;15051530&#x2F;3ba76f7f-21b5-4bd1-9f3f-da247ea8584f&quot; alt=&quot;image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;xing-neng-ti-sheng&quot;&gt;性能提升&lt;&#x2F;h3&gt;
&lt;p&gt;因为主要的时间损耗是在 BFS 中的访问检测上，那么就要考虑从这个方面入手。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;del&gt;第二部分中也许可以在所有起点的 &lt;code&gt;BFS&lt;&#x2F;code&gt; 中应用同一个 &lt;code&gt;visited&lt;&#x2F;code&gt; ，这个方法会在不同的 BFS 见产生干扰，导致结果错误&lt;&#x2F;del&gt;&lt;&#x2F;li&gt;
&lt;li&gt;使用 with_capacity 创建 visited 和 energized 可以一定的提升效率 [&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;livexia&#x2F;advent-of-code-2023&#x2F;commit&#x2F;5c6aec68747a91557032a244894bd67c32aec921&quot;&gt;code&lt;&#x2F;a&gt;]
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;let mut visited = HashSet::with_capacity(20_000);&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;let mut energized = HashSet::with_capacity(10_000);&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;cargo r&lt;&#x2F;code&gt; 4s → 2.8s release 500ms → 300ms&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;使用更好的 &lt;code&gt;HashSet&lt;&#x2F;code&gt; 实现或者 &lt;code&gt;Vec&lt;&#x2F;code&gt;
&lt;ul&gt;
&lt;li&gt;hashbrown 并没有明显的性能提升&lt;&#x2F;li&gt;
&lt;li&gt;Vec 需要使用三维数组才行&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-17-todo&quot;&gt;Day 17 (TODO)&lt;&#x2F;h2&gt;
&lt;p&gt;实现的思路并不复杂，但是求解空间巨大，无论用何种方法都需要剪枝，动态规划虽然不需要剪枝，但是因为路径选择存在前后依赖关系，需要保存的状态几乎等同于求解空间，也不现实。位置的移动并不是简单的上下左右移动一个，第一部分要求最长的同一方向移动距离为三，也就是说以一个方向移动三次必须要转向，那么对于当前位置最多存在六种可能的状态。这个地方存在两种处理，一就是只关心这六种可能的状态，省略中间状态，这个方法的好处是不需要考虑连续移动的次数，也一定程度减少了求解空间，&lt;del&gt;但是却也影响了剪枝的范围&lt;&#x2F;del&gt;（剪枝时依旧需要考虑当前连续移动的距离）。最后通过剪枝的 BFS 取得两个部分的解，但是应该可以用最短路径的算法进行求解。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;bfs&quot;&gt;BFS&lt;&#x2F;h3&gt;
&lt;p&gt;尝试通过 BFS 实现，但是在节点的访问状态判断上 BFS 并不正确，如果应用一个 visited 到整体的 BFS 会导致搜索路径的不完全，虽然节点是完全访问了，但是却无法取得所有的搜索路径，自然也就无法取得最终的结果，应该使用 DFS。&lt;&#x2F;p&gt;
&lt;p&gt;如果不使用 Visited 那么就要进行剪枝，引入 HashMap 记录当前位置和移动方向的最小 loss ，当遇到同样的状态时，判断当前 loss 是否小于记录值，如果不小于记录值，那么就不入队，实现剪枝。运行速度依旧堪忧，release 版本，运行需要 3s。第二部分和第一部分完全一致，引入节点的移动范围参数即可。&lt;&#x2F;p&gt;
&lt;p&gt;虽然没有对单条路径使用 Visited ，但是实际上如果在一条路径中，以同样的方向进入同一个节点两次，那么第二次的 loss 一定大于第一次，这样也就组织了可能的重复访问。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;如果能够证明在一条路径中，无论以何种方向进入同一个节点两次，第二次的 loss 一定大于第一次，那么就能进一步剪枝。&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;dfs-1&quot;&gt;DFS&lt;&#x2F;h3&gt;
&lt;p&gt;可能的路径太多，需要剪枝，&lt;del&gt;引入缓存&lt;&#x2F;del&gt;。应该可以用同 BFS 一样的方法进行剪枝。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;&lt;del&gt;BFS + 最小堆&lt;&#x2F;del&gt;：依旧需要剪枝，子问题的最优解之和并不等同于最优解。&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;dong-tai-gui-hua&quot;&gt;动态规划&lt;&#x2F;h3&gt;
&lt;p&gt;前一次选择的路径会影响到下一次的路径选择，dp 应该是不能用的，(0, 0) 到 (1, 2) 的最短路径应该是 3 ，但是(0, 0) 到 (4, 6) 的最短路径中(0, 0) 到 (1, 2) 的路径长度应该是 5， 也就是说部分的最优解并不等同于最终最优解&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1111999
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;9911999
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;9919999
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;9911199
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;9999111
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;dijkstra-s-algorithm-todo&quot;&gt;&lt;strong&gt;Dijkstra&#x27;s algorithm&lt;&#x2F;strong&gt; (TODO)&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dijkstra%27s_algorithm&quot;&gt;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dijkstra&#x27;s_algorithm&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;考虑输入 &lt;code&gt;abcde&lt;&#x2F;code&gt; 从 &lt;code&gt;a&lt;&#x2F;code&gt; 出发存在三条路径 &lt;code&gt;ab&lt;&#x2F;code&gt; &lt;code&gt;ac&lt;&#x2F;code&gt; &lt;code&gt;ad&lt;&#x2F;code&gt;
&lt;ul&gt;
&lt;li&gt;如果选择了 &lt;code&gt;ad&lt;&#x2F;code&gt; 那么就不存在从 &lt;code&gt;d&lt;&#x2F;code&gt; 出发的路径&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-18-todo&quot;&gt;Day 18 (TODO)&lt;&#x2F;h2&gt;
&lt;p&gt;问题的输入处理并不复杂，第一部分根据输入首先构造边，再利用 Ray Cast 算法计算被边包含的大小即可。第二部分对输入的变化依旧不复杂，但是每一条边的长度都被放大，再用第一部分的方法，求解空间将会变得巨大，简单的将所有边包含的位置记录在 HashSet 中就需要及其长的时间，更别提在 Ray Cast 中需要遍历的一个一个位置了。&lt;&#x2F;p&gt;
&lt;p&gt;鞋带定理&lt;&#x2F;p&gt;
&lt;p&gt;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Shoelace_formula&lt;&#x2F;p&gt;
&lt;p&gt;皮克定理&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Pick%27s_theorem&quot;&gt;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Pick&#x27;s_theorem&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;day-19-code&quot;&gt;Day 19 [&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;livexia&#x2F;advent-of-code-2023&#x2F;blob&#x2F;main&#x2F;aoc19&#x2F;src&#x2F;main.rs&quot;&gt;code&lt;&#x2F;a&gt;]&lt;&#x2F;h2&gt;
&lt;p&gt;今天的题目依旧不算特别难，但是我在输入的处理上花费了太多的时间，第一部分的排名并不优秀，第一部分的实现根据题意实现模拟即可，注意细节即可。第二部分扩大了第一部分的求解空间，如果依旧按照第一部分的模拟实现，那么程序将无法完成运行，第二部分要求 &lt;code&gt;x m a s&lt;&#x2F;code&gt; 在 &lt;code&gt;[1, 4000]&lt;&#x2F;code&gt; 的范围内进行组合，计算所有组合中会被工作流接收的个数。如果构造组合，再根据第一部分实现的模拟一一判断，这是不现实的，所以需要另辟蹊径。问题太大的时候首先考虑对问题进行分解，初始问题描述如下：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;对于 &lt;code&gt;x m a s&lt;&#x2F;code&gt; 在 &lt;code&gt;[1, 4000]&lt;&#x2F;code&gt; 的所有组合，从工作流 &lt;code&gt;in&lt;&#x2F;code&gt; 开始最后能被接收的组合个数&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;分解问题：以工作流 &lt;code&gt;in{s&amp;lt;1351:px,qqz}&lt;&#x2F;code&gt; 为例&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;经过 &lt;code&gt;in&lt;&#x2F;code&gt; 工作流的输入存在两种可能：
&lt;ul&gt;
&lt;li&gt;如果 &lt;code&gt;s &amp;lt; 1351&lt;&#x2F;code&gt; 进入工作流 &lt;code&gt;px&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;否则进入工作流 &lt;code&gt;qqz&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;那么原问题就变成，两个子问题：
&lt;ul&gt;
&lt;li&gt;计算 &lt;code&gt;s&lt;&#x2F;code&gt; 在 &lt;code&gt;[1, 1350]&lt;&#x2F;code&gt; 和 &lt;code&gt;x m a&lt;&#x2F;code&gt;  在 &lt;code&gt;[1, 4000]&lt;&#x2F;code&gt; 的所有组合，从工作流 &lt;code&gt;px&lt;&#x2F;code&gt; 开始最后能被接收的组合个数&lt;&#x2F;li&gt;
&lt;li&gt;同时计算 &lt;code&gt;s&lt;&#x2F;code&gt; 在 &lt;code&gt;[1351, 4000]&lt;&#x2F;code&gt; 和 &lt;code&gt;x m a&lt;&#x2F;code&gt;  在 &lt;code&gt;[1, 4000]&lt;&#x2F;code&gt; 的所有组合，从工作流 &lt;code&gt;qqz&lt;&#x2F;code&gt; 开始最后能被接收的组合个数&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;两个子问题的和即是原问题的解，同样的也可以对子问题再进行细分&lt;&#x2F;li&gt;
&lt;li&gt;可以&lt;strong&gt;利用动态规划&lt;&#x2F;strong&gt;实现，定义如下：
&lt;ul&gt;
&lt;li&gt;函数 &lt;code&gt;A(wf)&lt;&#x2F;code&gt; 表示有多少 &lt;code&gt;x,m,a,s&lt;&#x2F;code&gt; 的组合经过工作流 &lt;code&gt;wf&lt;&#x2F;code&gt; 后能被接受&lt;&#x2F;li&gt;
&lt;li&gt;转移方程： &lt;code&gt;A(wf) = Sum{A(next(wf))}&lt;&#x2F;code&gt; 其中 &lt;code&gt;next(wf)&lt;&#x2F;code&gt; 表示 &lt;code&gt;wf&lt;&#x2F;code&gt; 的后续工作流&lt;&#x2F;li&gt;
&lt;li&gt;边界：当一个工作流 &lt;code&gt;wf&lt;&#x2F;code&gt; 的下一个状态为 &lt;code&gt;A&lt;&#x2F;code&gt; 时，所有经过 &lt;code&gt;wf&lt;&#x2F;code&gt; 的 &lt;code&gt;x,m,a,s&lt;&#x2F;code&gt; 的组合都被接受&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;定义 &lt;code&gt;possible&lt;&#x2F;code&gt; 表示经过工作流 &lt;code&gt;wf&lt;&#x2F;code&gt; 前所有的输入组合&lt;&#x2F;li&gt;
&lt;li&gt;在 &lt;code&gt;wf&lt;&#x2F;code&gt; 内，根据 &lt;code&gt;wf&lt;&#x2F;code&gt; 所有的可能下一状态进行对 &lt;code&gt;possible&lt;&#x2F;code&gt; 进行分裂&lt;&#x2F;li&gt;
&lt;li&gt;如果下一个可能状态为进入工作流，那么根据进入工作流的条件对 &lt;code&gt;possible&lt;&#x2F;code&gt; 进行分裂为 &lt;code&gt;occupy&lt;&#x2F;code&gt; 和 &lt;code&gt;remain&lt;&#x2F;code&gt;，&lt;code&gt;occupy&lt;&#x2F;code&gt; 为进入新的工作流的所有可能组合，递归求解子问题&lt;&#x2F;li&gt;
&lt;li&gt;剩余的可能组合 &lt;code&gt;remain&lt;&#x2F;code&gt; 成为 &lt;code&gt;possible&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;如果下一个可能的状态为被接收，那么计算 &lt;code&gt;possible&lt;&#x2F;code&gt; 的组合数，输入的所有可能组合完成消耗&lt;&#x2F;li&gt;
&lt;li&gt;累加所有可能状态的被接收组合数&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;livexia&#x2F;advent-of-code-2023&#x2F;blob&#x2F;e8e56f4876c80256b6d91cf1a24efdaaaf4eb1f6&#x2F;aoc19&#x2F;src&#x2F;main.rs#L220-L327&quot;&gt;递归代码实现&lt;&#x2F;a&gt;，也可以用队列迭代实现。&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;day-20&quot;&gt;Day 20&lt;&#x2F;h2&gt;
&lt;p&gt;第一部分根据题意模拟实现即可，求解空间并不大，循环一千次的模拟在可承受范围内。第二部分首先依旧尝试模拟实现，可惜短时间内根本无法取得解，最后得结果数量级是 100千亿 ，这不是模拟能够解决的，需要寻找更好的方法。自己虽然观察了输入，但是却没能想出具体的实现，最后参考了 Reddit 的题解，才终于得处答案。第一部分代码对任何的输入都可行，第二部分则只支持 rx 依赖一个 &lt;em&gt;Conjunction&lt;&#x2F;em&gt; 模块，同时这个 Conjunction 模块又依赖于其他的 Conjunction 模块，同时这些 Conjunction 模块发出高位是存在循环规律的，第二部分会给出每一个模块的可能循环大小，需要手动根据循环计算这些模块的最小公倍数，最后取得结果。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;di-er-bu-fen&quot;&gt;第二部分&lt;&#x2F;h3&gt;
&lt;p&gt;观察给定的输入，可以发现 &lt;code&gt;rx&lt;&#x2F;code&gt; 仅依赖 &lt;code&gt;vd&lt;&#x2F;code&gt; ，而 &lt;code&gt;vd&lt;&#x2F;code&gt; 则依赖于 &lt;code&gt;rd bt fv&lt;&#x2F;code&gt; 和 &lt;code&gt;pr&lt;&#x2F;code&gt; ，&lt;code&gt;vd rd bt fv&lt;&#x2F;code&gt; 和 &lt;code&gt;pr&lt;&#x2F;code&gt; 都为 &lt;em&gt;Conjunction&lt;&#x2F;em&gt; 模块，所以如果 &lt;code&gt;rx&lt;&#x2F;code&gt; 要接收到低位，那么 &lt;code&gt;vd&lt;&#x2F;code&gt; 要发出低位，则 &lt;code&gt;vd&lt;&#x2F;code&gt; 的四个输入模块都必须发出高位，那么当 &lt;code&gt;rd bt fv&lt;&#x2F;code&gt; 和 &lt;code&gt;pr&lt;&#x2F;code&gt; 都发出高位时，&lt;code&gt;rx&lt;&#x2F;code&gt; 就能接收到低位。因为 rx 仅依赖于 &lt;code&gt;vd&lt;&#x2F;code&gt; ，那么求 &lt;code&gt;rx&lt;&#x2F;code&gt; 和求 &lt;code&gt;vd&lt;&#x2F;code&gt; 的求解空间应当是一样大的，所以就需要考虑 &lt;code&gt;vd&lt;&#x2F;code&gt; 依赖的四个模块，如果这四个模块存在一定的规律那么就可以将问题划分，减少求解空间。根据分析输入所得到的依赖关系，&lt;strong&gt;利用代码计算这四个模块发出高位所需要的按键次数&lt;&#x2F;strong&gt;，如果循环出现，那么说明存在规律，最后只需要计算四个模块发出高位次数的最小公倍数即是题解。&lt;&#x2F;p&gt;
&lt;p&gt;虽然第二部分涉及的代码是同第一部分一致的，但是在&lt;strong&gt;利用代码计算这四个模块发出高位所需要的按键次数&lt;&#x2F;strong&gt;的时间点很重要，因为 vd 这四个模块，所以要在经过 vd 模块就检测这四个模块发出的高低位，如果在按完一次按钮的最后，再检测这四个模块，那就可能无法检测到这四个模块的状态变化。这个细节也是为何我虽然知晓求解方法，但是依旧耗费了不少时间的原因。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;day-21-todo&quot;&gt;Day 21(TODO)&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;di-er-bu-fen-1&quot;&gt;第二部分&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;可以从一个位置进行上下左右的移动，要计算从位置 &lt;code&gt;S&lt;&#x2F;code&gt; 开始，经过 &lt;code&gt;step&lt;&#x2F;code&gt; 次移动，可以到达位置的数，令函数 &lt;code&gt;f(step)&lt;&#x2F;code&gt; 表示该问题&lt;&#x2F;li&gt;
&lt;li&gt;同时令 &lt;code&gt;d(step)&lt;&#x2F;code&gt; 表示从从位置 &lt;code&gt;S&lt;&#x2F;code&gt; 开始，经过 &lt;code&gt;step&lt;&#x2F;code&gt; 次不回头的移动，可以到达位置的数
&lt;ul&gt;
&lt;li&gt;即从 &lt;code&gt;S&lt;&#x2F;code&gt; 出发的最短路径长度为 &lt;code&gt;step&lt;&#x2F;code&gt; 的路径数&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;可以发现 &lt;code&gt;f(step) = d(step) + f(step -2)&lt;&#x2F;code&gt;
&lt;ul&gt;
&lt;li&gt;当从 &lt;code&gt;S&lt;&#x2F;code&gt; 出发经过 &lt;code&gt;step - 2&lt;&#x2F;code&gt; 次移动，如果剩余的 &lt;code&gt;2&lt;&#x2F;code&gt; 次移动允许回头，那么两次移动可以被消除（向左，再向右）&lt;&#x2F;li&gt;
&lt;li&gt;所以所有 &lt;code&gt;f(step -2)&lt;&#x2F;code&gt; 的终点都包含在 &lt;code&gt;f(step)&lt;&#x2F;code&gt; 中
&lt;ul&gt;
&lt;li&gt;同样的 &lt;code&gt;f(step - 4)&lt;&#x2F;code&gt; 被 &lt;code&gt;f(step - 2)&lt;&#x2F;code&gt; 包含&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;同时 &lt;code&gt;f(step - 1)&lt;&#x2F;code&gt; 中的任何终点都不可能被 f(step) 包含，因为其中的位置，只需要移动一次就可以成为 &lt;code&gt;f(step)&lt;&#x2F;code&gt; ，而移动一次却不可能实现原地不动&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;如果网格中不存在任何的石头，那么 d(step) 的终点将是以 S 为中心的一个菱形的边，边上的任意位置与 S 的最短距离是曼哈顿距离&lt;&#x2F;li&gt;
&lt;li&gt;根据 &lt;code&gt;f(step) = d(step) + f(step -2)&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;对于任意的偶数 &lt;code&gt;step&lt;&#x2F;code&gt; 有 &lt;code&gt;f(step) = d(step) + d(step - 2) + … + d(0)&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;对于任意的奇数 &lt;code&gt;step&lt;&#x2F;code&gt; 有 &lt;code&gt;f(step) = d(step) + d(step - 2) + … + d(1)&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;第二部分的网格是无限网格，所以就算知道 &lt;code&gt;f(step)&lt;&#x2F;code&gt; 的计算公式也不能减少多少计算量&lt;&#x2F;li&gt;
&lt;li&gt;参考 Reddit 上的解法，通过求解二次函数的系数，确定二次函数，再计算最终结果即可。
&lt;ul&gt;
&lt;li&gt;https:&#x2F;&#x2F;old.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;18nevo3&#x2F;2023_day_21_solutions&#x2F;&lt;&#x2F;li&gt;
&lt;li&gt;实际的输入中，网格的四边都为空，同时起始点 &lt;code&gt;S&lt;&#x2F;code&gt; 位于的行和列都为空，那么从 &lt;code&gt;S&lt;&#x2F;code&gt; 到四边上位置的最短路径长度即是二者之间的曼哈顿距离&lt;&#x2F;li&gt;
&lt;li&gt;同时 &lt;code&gt;S&lt;&#x2F;code&gt; 位于网格的正中央，那么 S 到四角的最短距离长度刚好为网格的边长 &lt;code&gt;width&lt;&#x2F;code&gt;（长宽相等）&lt;&#x2F;li&gt;
&lt;li&gt;所以从一个网格的 &lt;code&gt;S&lt;&#x2F;code&gt; 出发，在上下左右四个方向移动网格边长的距离 &lt;code&gt;width&lt;&#x2F;code&gt;，就会抵达相邻网格的 &lt;code&gt;S&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;当 S 移动 &lt;code&gt;width&lt;&#x2F;code&gt; 时 覆盖了 1 个原始网格&lt;&#x2F;li&gt;
&lt;li&gt;当 S 移动 &lt;code&gt;2 * width&lt;&#x2F;code&gt; 时 覆盖了 5 个原始网格&lt;&#x2F;li&gt;
&lt;li&gt;当 S 移动 &lt;code&gt;3 * width&lt;&#x2F;code&gt; 时 覆盖了 13 个原始网格&lt;&#x2F;li&gt;
&lt;li&gt;当 S 移动 &lt;code&gt;4 * width&lt;&#x2F;code&gt; 时 覆盖了 25 个原始网格
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.wolframalpha.com&#x2F;input?i=quadratic+fit+%7B%7B1%2C+1%7D%2C+%7B2%2C+5%7D%2C+%7B3%2C+13%7D%2C+%7B4%2C+25%7D%7D&quot;&gt;https:&#x2F;&#x2F;www.wolframalpha.com&#x2F;input?i=quadratic+fit+{{1%2C+1}%2C+{2%2C+5}%2C+{3%2C+13}%2C+{4%2C+25}}&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;网格的覆盖是随着移动的距离二次增长的&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;第二部分要求计算移动距离 &lt;code&gt;26501365&lt;&#x2F;code&gt; 的位置个数&lt;&#x2F;li&gt;
&lt;li&gt;输入网格边长为 &lt;code&gt;131&lt;&#x2F;code&gt;，恰好 &lt;code&gt;26501365 = 131 * 202300 + 65&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;可以计算出 65 次， 65 + 131 次 和 65 + 131 * 2 次移动距离时到达的位置数&lt;&#x2F;li&gt;
&lt;li&gt;假设二次函数为 $f(x) = ax^2 + bx +c$ 且 $x = (step - 65) &#x2F; 131$&lt;&#x2F;li&gt;
&lt;li&gt;那么得到 f(0) , f(1) 和 f(2) 的值就可以计算出系数 a b c&lt;&#x2F;li&gt;
&lt;li&gt;再计算 f(202300) 即是结果&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-22-code&quot;&gt;Day 22[&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;livexia&#x2F;advent-of-code-2023&#x2F;blob&#x2F;main&#x2F;aoc22&#x2F;src&#x2F;main.rs&quot;&gt;code&lt;&#x2F;a&gt;]&lt;&#x2F;h2&gt;
&lt;p&gt;今天的题目并不难，核心的问题就是砖块掉落，是否会和下方的砖块产生碰撞。第一部分第二部分都是在这个基础之上进行求解。我首先就想到砖块实际上就是两个线段，是否会产生碰撞，那么只需要计算线段是否存在交点即可，参考了几个 stackover flow 的解法，可惜最后的答案不对。最后用了笨办法，那就是记录砖块占据的所有网格位置，碰撞时统计各自占据的网格位置是否存在重叠即可，笨办法替换了线性代数之后可以顺利解决两个部分，虽然运行速度不快。对比两个检测碰撞的方法，发现在两个线段存在重叠时，线性代数的方法会得出错误的结果，可惜我的线性代数学不到家，只看数学我是根本不知道问题何在。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;线性代数检测线段相交[&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;livexia&#x2F;advent-of-code-2023&#x2F;commit&#x2F;fdb5d7cccfb93ee2c75de1382dde44b74238d6d0&quot;&gt;code&lt;&#x2F;a&gt;,&lt;&#x2F;strong&gt; &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;livexia&#x2F;advent-of-code-2023&#x2F;commit&#x2F;10a2bb9480697a3a5ed8e26e179a436945aefb1d&quot;&gt;fixed code&lt;&#x2F;a&gt;&lt;strong&gt;]&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;5666222&#x2F;3d-line-plane-intersection&lt;&#x2F;li&gt;
&lt;li&gt;https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;55220355&#x2F;how-to-detect-whether-two-segments-in-3d-space-intersect&lt;&#x2F;li&gt;
&lt;li&gt;https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;2316490&#x2F;the-algorithm-to-find-the-point-of-intersection-of-two-3d-line-segment&lt;&#x2F;li&gt;
&lt;li&gt;当两个线段位于同一条直线上时，实现代码计算出的 s 和 t 都为 Nan ，于是被认定线段一定不存在交点（重叠）&lt;&#x2F;li&gt;
&lt;li&gt;增加线段重叠检测之后，运行结果正确，运行时间是 HashSet 方法的一半&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;性能优优化[&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;livexia&#x2F;advent-of-code-2023&#x2F;commit&#x2F;93c6f76316c688720026cb35380ffd4af26eb848&quot;&gt;code&lt;&#x2F;a&gt;]&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;无论是用 Set 还是线性代数判断线段是否相交时，可以先判断两个砖块在 Z 轴方向上是否存在重叠，如果不存在重叠，那么一定不可能相交，通过这一个判断可以将 Debug 编译的第一部分运行时间从 10s 降低至 3s  ，第二部分则从 18 s 降低至 6s。&lt;&#x2F;li&gt;
&lt;li&gt;当前的 HashSet 是存储在 Struct 中，每一个砖块都有自己的 HashSet ，在测试掉落时，也需要构造新的 HashSet ，也许可以使用一份 HashSet 记录所有砖块已经占据的位置。
&lt;ul&gt;
&lt;li&gt;Debug: 第一部分 3s → 2s&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;构造支撑图[&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;livexia&#x2F;advent-of-code-2023&#x2F;commit&#x2F;f1fecd6014c902769779cc9084eafd7c38bb7829&quot;&gt;code&lt;&#x2F;a&gt;]&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;根据初始完全落下所有砖块，构造砖块与砖块之间的支撑关系&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;第一部分要计算移除某一砖块（节点），图不被断开&lt;&#x2F;li&gt;
&lt;li&gt;第二部分则要计算移除某一砖块（节点），当图断开时剩余图的长度&lt;&#x2F;li&gt;
&lt;li&gt;主要的时间耗费应该是在最初的落下砖块和构造支撑图，第一第二部分的具体计算只占用很小一部分的运行时间&lt;&#x2F;li&gt;
&lt;li&gt;对比利用线性代数或者 HashSet 在第一第二部分都模拟消除砖块再检测下落，Debug 下的运行时间从 2s → 1s ，release 则是从 400ms → 120ms&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-23-code&quot;&gt;Day 23[&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;livexia&#x2F;advent-of-code-2023&#x2F;blob&#x2F;main&#x2F;aoc23&#x2F;src&#x2F;main.rs&quot;&gt;code&lt;&#x2F;a&gt;]&lt;&#x2F;h2&gt;
&lt;p&gt;需要计算最长路径，第一部分限制了部分节点的移动可能，于是很容易的利用 DFS 求解即可。第二部分则无法这样简单的实现，因为涉及到大量的可能路径，求解空间巨大，于是用 DFS 首先可能会栈溢出，然后就是运行时间过久，无法得出结果。即然简单的 DFS 不行，那么是不是可以引入缓存呢？可惜还是不行，缓存只记录在某一个路径中的最长部分，但是这个最长并不适用于另一个路径，也就无法正确的得出结果。通过搜索我发现还存在一种方法就是利用拓扑排序确定最长路径，拓扑排序要求是有向无环图，实现之后依旧无法计算出最长路径，原因就是在网格中移动的路径的确是有向无环图，但是如果把所有的可能路径都考虑到，那么实际上题目给出的网格是有环图，所以拓扑排序依旧不可行。&lt;&#x2F;p&gt;
&lt;p&gt;不优化的 DFS 方法 release 编译运行了 1268s 得出正确的解&lt;&#x2F;p&gt;
&lt;p&gt;可行的缓存：缓存需要记录的状态，当前经过的所有路径，这样可以确保不同路径之间不会产生干扰，可是需要记录的状态太大，不太现实？&lt;&#x2F;p&gt;
&lt;h3 id=&quot;jiang-wang-ge-zhuan-hua-wei-tu-bing-dui-tu-jin-xing-he-bing-jian-zhi-code&quot;&gt;将网格转化为图，并对图进行合并（剪枝）[&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;livexia&#x2F;advent-of-code-2023&#x2F;commit&#x2F;1e0a24fdc04d821dece0e6e0d6be809dbb8e2a44&quot;&gt;code&lt;&#x2F;a&gt;]&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;根据网格构造图&lt;&#x2F;li&gt;
&lt;li&gt;只记录邻接节点构成的长度为 1 的边，遍历网格中每一个不为 &lt;code&gt;#&lt;&#x2F;code&gt; 的位置，判断当前位置的所有邻接位置是否能够构成边&lt;&#x2F;li&gt;
&lt;li&gt;对图进行剪枝当一个节点只存在两个边时，可以删除当前节点并合并两个边，直到图中不存在只有两个边的节点
&lt;ul&gt;
&lt;li&gt;经过剪枝，图的长度从 9412 减少为 36&lt;&#x2F;li&gt;
&lt;li&gt;那么经过剪枝，最多只有 36 * 4 的边，求解空间大大减少&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;再对图进行 DFS 遍历
&lt;ul&gt;
&lt;li&gt;release 运行时间从 1268s 减少到 4s&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;除了因为边的合并的性能提升，相比于直接网格的 DFS 在对于邻接节点确定上也有一定的性能提升，700s → 600s&lt;&#x2F;li&gt;
&lt;li&gt;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Edge_contraction&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;xing-neng-you-hua-code&quot;&gt;性能优化[&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;livexia&#x2F;advent-of-code-2023&#x2F;commit&#x2F;94a763044a57a4120b230947095c30ff5efc1133&quot;&gt;code&lt;&#x2F;a&gt;]&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;visited 不使用 HashSet 而使用 Vec ，运行时间：4s → 1s
&lt;ul&gt;
&lt;li&gt;直接 dfs 的方法 1200s → 700s&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-24&quot;&gt;Day 24&lt;&#x2F;h2&gt;
&lt;p&gt;今天的题目不是编程题，更像是数学题，第一部分要求二元一次方程组，第二部分要求九元九次方程组。第一部分因为涉及到的方程组数量较少，所以我手动推导出求解过程，代码中再进行计算。第二部分我则代码打印出方程，寻找到在线求解方程组的网站进行求解，第二部分这样居然进了前一千。&lt;strong&gt;今天的问题主要就是需要计算直线相交的，这和第 22 天计算线段相交的问题实际上是一模一样的。涉及到数学和线性代数，我并不是完全理解，但是没办法，也就是这样了。&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;题意分析：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;所有的石头有一个初始位置，同时有一个速度，按照一定的时间间隔根据速度改变位置&lt;&#x2F;li&gt;
&lt;li&gt;第一部分需要计算两两石头的运行路径相交的次数，只要计算路径的相交，而不是石头产生碰撞，即相交不需要石头同时抵达。&lt;&#x2F;li&gt;
&lt;li&gt;第二部分则要想象一个新的石头，这个石头和所有输入的石头同时以各自的速度前进，而且这个石头会和输入的所有石头碰撞，计算这个石头的初始坐标和。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;求解思路&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;令石头的初始位置为 p0 速度为 v ，运行时间为 t ，那么就有石头在 t 时的位置 $p = p0 + v*t$&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;第一部分判断两两石头路径是否相交，要注意的是相交的位置可能并不是正好处于整数的位置，所以第一部分的计算最好&lt;strong&gt;使用浮点数作为计算类型&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;令石头 a 的路径函数为 $pa = pa0 + va * ta$&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;令石头 b 的路径函数为 $pb = pb0 + vb * tb$&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;当路径相交时，即 pa = pb，所以就有 $pa0 + va*ta = pb0 + vb * tb$&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;第一部分只考虑 x 和 y ，所以自然的就存在两条方程&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;$xa0 + vxa * ta = xb0 + vxb * tb$&lt;&#x2F;li&gt;
&lt;li&gt;$ya0 + vya * ta = yb0 + vyb * tb$&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;因为 xa0 vxa xb0 vxb ya0 vya yb0 vyb 都是输入已知，那么只有 ta 和 tb 未知，同时有两条方程组，那么就可以通过消元法分别求解 ta 和 tb&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果计算出的 ta 和 tb 小于 0 那么说明石头a 和 b 的路径在他们还没移动前就相交了，不合题意&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果 ta 和 tb 是无穷，说明计算中存在除 0 的情况，那么石头 a 和 b 的路径应该是平行了，也就不可能相交&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;根据无穷的 ta 和 tb 计算相交的位置，可以发现位置是在无限远的位置相交，实际上也就是不相交&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;计算出 ta 和 tb 之后，就可以确定路径相交的位置，判断相交位置是否位于输入给定的范围内即可&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;[&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;livexia&#x2F;advent-of-code-2023&#x2F;commit&#x2F;d1c9163f827d6926ef21c7a06b73f5f96574f69d&quot;&gt;code&lt;&#x2F;a&gt;]第二部分需要计算当一个石头与所有输入石头都存在某一时刻直接相交，计算这个石头的位置&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;令这个石头的位置为 p 同时速度为 v&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;第二部分不仅需要考虑 x 和 y 也要考虑 z&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;令输入石头的位置和速度为 pn 和 vn ，n为输入的石头数，那么就有以下方程&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;$p + v*t1 = p1 + v1 * t1$&lt;&#x2F;li&gt;
&lt;li&gt;$p + v*t2 = p2 + v2 * t2$&lt;&#x2F;li&gt;
&lt;li&gt;$p + v*t3 = p3 + v3 * t3$&lt;&#x2F;li&gt;
&lt;li&gt;…&lt;&#x2F;li&gt;
&lt;li&gt;$p + v*tn = pn + vn * tn$&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;暂时先将 p 和 v 都视为一个变量（不是自然数，而是向量&#x2F;矩阵）&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;首先存在 n 条方程，每一条方程引入一个新的未知量 tn&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;那么总共的未知量个数就是 n + 2&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;一次方程的数量要和未知量的数量一致才能求解未知量，可是总共只有 n 条方程&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;方程并不是一次的，而是二次方程，这会影响结果吗？&lt;&#x2F;strong&gt;
&lt;ul&gt;
&lt;li&gt;改变方程的位置可以得到 $p - pn = tn(vn - v)$&lt;&#x2F;li&gt;
&lt;li&gt;p 和 v 实际上都是矩阵，所以在两侧叉乘上 $v - vn$ 得到&lt;&#x2F;li&gt;
&lt;li&gt;$(p-pn) \times (v-vn) = tn(vn -v)\times(v - vn)$&lt;&#x2F;li&gt;
&lt;li&gt;同时有平行的向量叉乘为0， $(vn -v)\times(v - vn) = 0$ 即有&lt;&#x2F;li&gt;
&lt;li&gt;$(p-pn) \times (v-vn) = 0$&lt;&#x2F;li&gt;
&lt;li&gt;p 和 v 是未知数，同时 $p \times v$ 是每一个方程中可得到的共同部分，于是可以被消去，所以这个方程组虽然看似是二次的，可是实际上最后依旧是线性的&lt;&#x2F;li&gt;
&lt;li&gt;因为这个原因所以就算不用第三方的求解工具，依旧可以手动推导求解&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;https:&#x2F;&#x2F;old.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;18pptor&#x2F;2023_day_24_part_2java_is_there_a_trick_for_this&#x2F;kepvp8j&#x2F;&lt;&#x2F;li&gt;
&lt;li&gt;https:&#x2F;&#x2F;old.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;18pnycy&#x2F;2023_day_24_solutions&#x2F;kepu26z&#x2F;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;不过因为需要考虑三个方向上的情况，那么实际上一条方程是等同于三个方向上的方程&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;所以在考虑三个方向上后，p 和 v 实际上是总共 6 个位置了&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;未知量个数就是 n + 6，方程个数就是 3 * n&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;实际上时间 t 可以被消去，当然 v 的三个未知量也可以被消去，不过这就要自己实现消元法了，头疼放弃。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;满足未知量个数等于方程个数的最小 n 实际上是 3&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;所以理论上只需要计算 9 个方程，也就是输入中的 3 个石头就能计算出解，剩余的石头&#x2F;方程是没有用的&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;如果计算出的石头和剩余石头相交情况不满足题意，那么实际上输入是存在问题的，也就是说这样的输入是无法计算出可能的石头满足题意&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;九元九次方程如果直接用消元法手动推导求解，估计眼睛会看不过来，我用 Rust 生产了 9 条方程，再偷懒直接找了网站计算&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;quickmath.com&#x2F;webMathematica3&#x2F;quickmath&#x2F;equations&#x2F;solve&#x2F;advanced.jsp#c=solve_solveequationsadvanced&amp;amp;v1=x%2Ba*t%253D262130794315133%2B57*t%250Ay%2Bb*t%253D305267994111063%2B-252*t%250Az%2Bc*t%253D163273807102793%2B150*t%250Ax%2Ba*q%253D290550702673836%2B-74*q%250Ay%2Bb*q%253D186986670515285%2B19*q%250Az%2Bc*q%253D231769402282435%2B-219*q%250Ax%2Ba*w%253D275698513286341%2B-59*w%250Ay%2Bb*w%253D162656001312879%2B-24*w%250Az%2Bc*w%253D183065006152383%2B-225*w&amp;amp;v2=x%250Ay%250Az%250Aa%250Ab%250Ac%250At%250Aq%250Aw&quot;&gt;https:&#x2F;&#x2F;quickmath.com&#x2F;webMathematica3&#x2F;quickmath&#x2F;equations&#x2F;solve&#x2F;advanced.jsp#c=solve_solveequationsadvanced&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;得出正确答案后，我尝试从 bard 和 cahtgpt 处取得正确答案，可惜 bard 不够聪明，chatgpt 倒是给出了一份 python 的代码，本地运行也的确计算出了正确答案。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;from &lt;&#x2F;span&gt;&lt;span&gt;sympy &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;import &lt;&#x2F;span&gt;&lt;span&gt;symbols, solve
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 定义符号变量
&lt;&#x2F;span&gt;&lt;span&gt;x, y, z, vx, vy, vz, t0, t1, t2 = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;symbols&lt;&#x2F;span&gt;&lt;span&gt;(&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;x y z vx vy vz t0 t1 t2&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 定义方程组
&lt;&#x2F;span&gt;&lt;span&gt;equations = [
&lt;&#x2F;span&gt;&lt;span&gt;    x + vx * t0 - (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;262130794315133 &lt;&#x2F;span&gt;&lt;span&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;57 &lt;&#x2F;span&gt;&lt;span&gt;* t0),
&lt;&#x2F;span&gt;&lt;span&gt;    y + vy * t0 - (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;305267994111063 &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;252 &lt;&#x2F;span&gt;&lt;span&gt;* t0),
&lt;&#x2F;span&gt;&lt;span&gt;    z + vz * t0 - (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;163273807102793 &lt;&#x2F;span&gt;&lt;span&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;150 &lt;&#x2F;span&gt;&lt;span&gt;* t0),
&lt;&#x2F;span&gt;&lt;span&gt;    x + vx * t1 - (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;290550702673836 &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;74 &lt;&#x2F;span&gt;&lt;span&gt;* t1),
&lt;&#x2F;span&gt;&lt;span&gt;    y + vy * t1 - (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;186986670515285 &lt;&#x2F;span&gt;&lt;span&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;19 &lt;&#x2F;span&gt;&lt;span&gt;* t1),
&lt;&#x2F;span&gt;&lt;span&gt;    z + vz * t1 - (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;231769402282435 &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;219 &lt;&#x2F;span&gt;&lt;span&gt;* t1),
&lt;&#x2F;span&gt;&lt;span&gt;    x + vx * t2 - (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;275698513286341 &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;59 &lt;&#x2F;span&gt;&lt;span&gt;* t2),
&lt;&#x2F;span&gt;&lt;span&gt;    y + vy * t2 - (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;162656001312879 &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;24 &lt;&#x2F;span&gt;&lt;span&gt;* t2),
&lt;&#x2F;span&gt;&lt;span&gt;    z + vz * t2 - (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;183065006152383 &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;225 &lt;&#x2F;span&gt;&lt;span&gt;* t2)
&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 解方程组
&lt;&#x2F;span&gt;&lt;span&gt;solutions = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;solve&lt;&#x2F;span&gt;&lt;span&gt;(equations, (x, y, z, vx, vy, vz, t0, t1, t2))
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 打印结果
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;print&lt;&#x2F;span&gt;&lt;span&gt;(solutions)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 计算 x + y + z
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;sum&lt;&#x2F;span&gt;&lt;span&gt;(solutions[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;][:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;])
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;shi-yong-solver-qiu-jie-fang-cheng&quot;&gt;使用 Solver 求解方程&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;z3 [&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;livexia&#x2F;advent-of-code-2023&#x2F;commit&#x2F;fd68fc663e721ce1f5f13599a481a09857fedb30&quot;&gt;code&lt;&#x2F;a&gt;]&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;https:&#x2F;&#x2F;docs.rs&#x2F;z3&#x2F;latest&#x2F;z3&#x2F;&lt;&#x2F;li&gt;
&lt;li&gt;https:&#x2F;&#x2F;github.com&#x2F;Z3Prover&#x2F;z3&#x2F;wiki#background&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;brew install z3&lt;&#x2F;code&gt; 之后依旧无法正确的找到 z3.h 应该是路径问题，不想排查，换一个 Solver&lt;&#x2F;li&gt;
&lt;li&gt;官方的文档不是很简洁明了，所以参考了社区的实现，最后的运行速度没有想象中的快
&lt;ul&gt;
&lt;li&gt;https:&#x2F;&#x2F;github.com&#x2F;AxlLind&#x2F;AdventOfCode2023&#x2F;blob&#x2F;main&#x2F;src&#x2F;bin&#x2F;24.rs&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;第二部分的题目要求 Rock 和输入的石头只会在一定的时间间隔内和输入的石头产生碰撞，而输入石头的位置和速度都是整数，所以最后碰撞的位置也一定是整数，那么求解的时候只需要考虑整数即可&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;good_lp&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;good_lp&lt;&#x2F;li&gt;
&lt;li&gt;方程式存在两个变量相乘的情况，无法求解，back to z3&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-25&quot;&gt;Day 25&lt;&#x2F;h2&gt;
&lt;p&gt;以为今天的题目会很简单，结果是我不熟悉的题目。给定的输入构成一个无向有环图，需要求解断开哪三个边可以使得图产生分裂，计算分裂后图的节点数乘积。因为不知道解决这个问题有什么特定的算法，所以我决定直接直接暴力遍历所有的可能边的组合，很可惜暴力是跑不出什么结果的。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;从所有的边中选择三个删除总共存在 254960703480 这么多的可能&lt;&#x2F;li&gt;
&lt;li&gt;检测 100000000 个可能需要 2131.196800375s&lt;&#x2F;li&gt;
&lt;li&gt;预估时间：62 天&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;dui-bian-jin-xing-pai-xu-ti-sheng-bao-li-sou-suo-de-xiao-lu-code&quot;&gt;对边进行排序，提升暴力搜索的效率 [&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;livexia&#x2F;advent-of-code-2023&#x2F;blob&#x2F;main&#x2F;aoc25&#x2F;src&#x2F;main.rs&quot;&gt;code&lt;&#x2F;a&gt;]&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;已知图在删除特定的三条边之后，图会被分成两个新的图&lt;&#x2F;li&gt;
&lt;li&gt;可以想象这两个新的图是由这三条边相连的&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;左边图中的节点和右边图的节点相连，那么至少要从这三条边中经过一次&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;li&gt;如果不断开任何边，那么从一个节点出发，通过 BFS 和 DFS 可以对其他所有的节点进行一次搜索（不重复访问节点）&lt;&#x2F;li&gt;
&lt;li&gt;在搜索过程中记录所有边的出现次数，当只从一个节点出发时，所有边的出现次数只会是 1&lt;&#x2F;li&gt;
&lt;li&gt;那么可以对图中所有的节点都进行单独的 BFS&#x2F;DFS 搜索，并在过程中记录所有边出现的次数&lt;&#x2F;li&gt;
&lt;li&gt;同时在记录边出现的次数时，要对边进行统一化，即 (a → b) 和 (b → a) 应当记录在同一个边下&lt;&#x2F;li&gt;
&lt;li&gt;假设左图有 L 条边，右图有 R 条边，同左图和右图通过 3 条边相连&lt;&#x2F;li&gt;
&lt;li&gt;左图内的节点访问其他左图内的节点理论上不需要经过中间的 3 条边和右图的边&lt;&#x2F;li&gt;
&lt;li&gt;而如果左图的节点需要访问右图的节点，那么必然会经过中间 3 条边的某一条&lt;&#x2F;li&gt;
&lt;li&gt;在 BFS &#x2F; DFS 的过程中不允许重复访问，那么每一次搜索一条边最多只会经过一次，同时有的边则会被忽略不访问（因为节点已经访问过）&lt;&#x2F;li&gt;
&lt;li&gt;但是每一次搜索一定至少会经过两个图之间三条边其中一条，如果没有经过，说明左图和右图的节点没有产生连通的路径，这和题意不符&lt;&#x2F;li&gt;
&lt;li&gt;虽然知道这样是可行的，但是我却没法明确的说出为什么，哎一知半解。&lt;&#x2F;li&gt;
&lt;li&gt;根据边出现的频率对边进行排序，那么出现次数前三的边就应该是需要被删除的边&lt;&#x2F;li&gt;
&lt;li&gt;暴力时可以优先删除出现频率高的边，判断是否可以分割图，直到分割&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;li-yong-graphviz-sheng-cheng-tu-de-ke-shi-hua-pic&quot;&gt;利用 Graphviz 生成图的可视化 [&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;livexia&#x2F;advent-of-code-2023&#x2F;tree&#x2F;main&#x2F;aoc25&#x2F;graphviz&quot;&gt;pic&lt;&#x2F;a&gt;]&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;将 input.txt 修改为 input.dot&lt;&#x2F;li&gt;
&lt;li&gt;利用 graphviz 的 neato 或者 spdf 生成图的可视化
&lt;ul&gt;
&lt;li&gt;可以将图按照集群进行展示&lt;&#x2F;li&gt;
&lt;li&gt;neato https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Spring_system&lt;&#x2F;li&gt;
&lt;li&gt;spdf https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Force-directed_graph_drawing&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;根据可视化确定需要删除的边&lt;&#x2F;li&gt;
&lt;li&gt;将边删除，利用代码计算分裂的图节点数的乘积&lt;&#x2F;li&gt;
&lt;li&gt;这个方法太取巧，不是一个适用的方法&lt;&#x2F;li&gt;
&lt;li&gt;https:&#x2F;&#x2F;graphviz.org&#x2F;doc&#x2F;info&#x2F;lang.html&lt;&#x2F;li&gt;
&lt;li&gt;https:&#x2F;&#x2F;graphviz.org&#x2F;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>扩展 LUKS&#x2F;Btrfs 主分区</title>
        <published>2023-12-27T00:00:00+00:00</published>
        <updated>2023-12-27T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/expand-luks-btrfs/"/>
        <id>https://ghost.livexia.xyz/expand-luks-btrfs/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/expand-luks-btrfs/">&lt;p&gt;tl;dr ：这么复杂的操作是没法长话短说，长话短说容易进不了系统。&lt;&#x2F;p&gt;
&lt;p&gt;设备环境：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;硬盘总大小 128G&lt;&#x2F;li&gt;
&lt;li&gt;原始分配情况：Windows 占用 80G ，Fedora 占用 38G&lt;&#x2F;li&gt;
&lt;li&gt;目标分配情况：Windows 占用 55G ，Fedora 占用 63G&lt;&#x2F;li&gt;
&lt;li&gt;实际分配情况：Windows 占用 64G ，Fedora 占用 54G&lt;&#x2F;li&gt;
&lt;li&gt;初始时硬盘分区大概的情况：从左到右
&lt;ul&gt;
&lt;li&gt;FAT 分区，200MB ，Fedora 下挂载为 &#x2F;boot&#x2F;efi 实际上就是 EFI 分区&lt;&#x2F;li&gt;
&lt;li&gt;Windows 主分区&lt;&#x2F;li&gt;
&lt;li&gt;Ext4 分区，Fedora 的 boot 分区&lt;&#x2F;li&gt;
&lt;li&gt;LUKS + Btrfs 分区，Fedora 主分区&lt;&#x2F;li&gt;
&lt;li&gt;在这些分区间散落着其他各种Windows需要的分区（恢复分区）&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;qing-li-windows-11-yu-liu-kong-jian&quot;&gt;清理 Windows 11 预留空间&lt;&#x2F;h3&gt;
&lt;p&gt;利用 &lt;a href=&quot;https:&#x2F;&#x2F;windirstat.net&#x2F;&quot;&gt;WinDirStat&lt;&#x2F;a&gt; 扫描硬盘，删除不必要的文件，最初我能将 Windows 的主分区减少到 55G，可是为了确保 Windows 的系统可用，我又更新了系统，最初在设置的更新中更新了多次，都提示空间不足，所以我努力的清理空间，几乎将主分区占用下降到 40G ，剩余就有 15G 可惜安装依旧一直失败，即时在过程中根据提示插入外置硬盘用作存放临时文件，依旧是不断的失败。经过简单的搜索，才发现因为是大版本更新，所以更新需要满足一定的系统要求，这个要求就是硬盘空间至少 64G，所以并不是因为剩余空间不够才失败的，而是分配的空间太小了。最后重新将硬盘空间调整到 64G，同时用 Windows 11 升级助手直接升级到最新的大版本，最后终于成功。&lt;&#x2F;p&gt;
&lt;p&gt;潜在的问题，更新完之后主分区的空间从 64G 变成了 63G ，因为有 1G 被划分作为新的恢复分区了，这也许会导致下一次的大版本更新失败。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;diao-zheng-fedora-fen-qu-da-xiao&quot;&gt;调整 Fedora 分区大小&lt;&#x2F;h3&gt;
&lt;p&gt;因为 Windows 更新完有了新的恢复分区，所以我删除在分区表末尾的原有恢复分区，这部分的为分配空间也可以并入 Fedora 的分区。缩小了 Windows 主分区后，有大概 16G 的为分配空间，这部分的空间是在 Ext4 的 boot 分区前的，我利用 Aomei 的硬盘分区工具，将 Ext4 分区移动到未分配空间的最左侧，紧接着 Windows 的主分区和恢复分区。这时未分配空间依旧位于 Fedora 的左侧，Fedora 的主分区是利用 LUKS 加密的分区，同时文件系统是 Btrfs，Aomei 硬盘工具虽然显示这有一个分区，但是却没能识别出具体是什么文件系统，同时也显示空间全部可用，所以不敢直接在 Windows 下移动，实际上这个凑巧的谨慎而是很有必要的，后续尝试中我也在 USB live 的环境中使用 GParted ，同样的也是不能直接移动分区，再扩容。&lt;&#x2F;p&gt;
&lt;p&gt;到现在为止，扩张 Fedora 的分区，需要合并 Fedora 主分区前后的未分配空间，合并主分区右侧的未分配空间较为容易，而合并左侧的空间则更加麻烦和困难，也正是这个原因我才决定写这样一篇东西，先从简单的合并开始。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;he-bing-you-ce-de-wei-fen-pei-kong-jian&quot;&gt;合并右侧的未分配空间&lt;&#x2F;h3&gt;
&lt;p&gt;需要解锁 LUKS 分区，然后利用 Parted 或 GParted 扩展物理分区，最后再扩展 Btrfs 文件系统大小，这些操作最好在另外一个 Linux 环境或者 USB live 的 Linux 环境中操作，因为涉及到调整 root 分区的大小，所以本系统里应该是无法操作的。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;在其他 Linux 系统环境中需要解锁 LUKS 分区 &lt;code&gt;sudo cryptsetup luksOpen &#x2F;dev&#x2F;nvme0n1p6 crypt-volume&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;如果是在另外的环境中，那就要挂载 LUKS 分区 Mapper，以挂载点 ~&#x2F;test 为例 &lt;code&gt;sudo mount &#x2F;dev&#x2F;mapper&#x2F;crypt-volumt ~&#x2F;test&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;调整 Btrfs 文件系统大小 &lt;code&gt;sudo btrfs filesystem resize max &#x2F;&lt;&#x2F;code&gt;
&lt;ul&gt;
&lt;li&gt;如果是在另外的环境中执行 &lt;code&gt;sudo btrfs filesystem resize max ~&#x2F;test&lt;&#x2F;code&gt; 进行调整&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;这样两步就完成了 Fedora 主分区右侧的磁盘扩容&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;he-bing-zuo-ce-de-wei-fen-pei-kong-jian&quot;&gt;合并左侧的未分配空间&lt;&#x2F;h3&gt;
&lt;p&gt;因为未分配空间在左侧，实际上也就没有办法很容易的直接合并，这一点也是在折腾过程中我才意识到的，好像的确是这样，以前如果要合并左侧空间，那就会花很多时间移动数据，我不确定为什么在这个配置下这样做不行，也许是因为 LUKS ，也许是因为 Btrfs ，我不能确定。总之合并左侧的未分配空间并不容易，上面的两步完全没用。在搜索解决方法的过程中，我寻找到了一个可行的方法，大致的步骤如下。同样的这些步骤也可以在另外的 Linux 环境中实现，我推荐在做任何的操作前先准备一个环境，我手头刚好有之前的 Fedora 36 Live USB 的环境，有这个环境可以确保当操作错误时安心的回退操作。&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在未分配空间上新建一个 Btrfs 分区，可以用 Parted 或 GParted&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;新建一个 LUKS 分区，设置加密密钥&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;应该可以跳过，如果不需要加密？但是我也不能确定，因为合并的对象是加密的分区，这会有什么影响我并不确定。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 新建并格式化 LUKS 分区
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; cryptsetup luksFormat &#x2F;dev&#x2F;nvme0n1p7
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 检查分区是否已经 LUKS 加密
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; cryptsetup isLuks &#x2F;dev&#x2F;nvme0n1p7 &amp;amp;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;echo&lt;&#x2F;span&gt;&lt;span&gt; Sucess
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 输出分区 LUKS 信息
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; cryptsetup luksDump &#x2F;dev&#x2F;nvme0n1p7
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;设置分区名，我这里设置为 luks-UUID 实现唯一的名字&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 取得 LUKS UUID
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; cryptsetup luksUUID &#x2F;dev&#x2F;nvme0n1p7
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 设置 LUKS 分区名
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; cryptsetup luksOpen &#x2F;dev&#x2F;nvme0n1p7 luks-84f5172e-c2d6-4651-812f-0d6271be004a
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 检查 LUKS 分区情况
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; dmsetup info luks-84f5172e-c2d6-4651-812f-0d6271be004a
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;设置 tpm2 自动解锁，并不是本文重点，运行命令&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;device&lt;&#x2F;span&gt;&lt;span&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;dev&#x2F;nvme0n1p7
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; systemd-cryptenroll&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --tpm2-device&lt;&#x2F;span&gt;&lt;span&gt;=auto&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --tpm2-pcrs&lt;&#x2F;span&gt;&lt;span&gt;=0+7 $&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;device
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;修改 &lt;code&gt;&#x2F;etc&#x2F;crypttab&lt;&#x2F;code&gt; 确保分区在启动时会被解锁&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;利用编辑器打开 crypttab 新增 LUKS 分区信息 &lt;code&gt;sudo nvim &#x2F;etc&#x2F;crypttab&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;我直接参考原有 LUKS 分区进行新增（黏贴复制，修改名字和 UUID）&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;none&lt;&#x2F;code&gt; 表示不使用密钥文件， &lt;code&gt;tpm2-device=auto&lt;&#x2F;code&gt; 用 tpm 设备解密，&lt;code&gt;discard&lt;&#x2F;code&gt; 用于 SDD 设备&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;luks-3bf2404b-95b5-4c38-b51f-7e8d4611d173&lt;&#x2F;span&gt;&lt;span&gt; UUID=3bf2404b-95b5-4c38-b51f-7e8d4611d173 none tpm2-device=auto,discard
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;luks-84f5172e-c2d6-4651-812f-0d6271be004a&lt;&#x2F;span&gt;&lt;span&gt; UUID=84f5172e-c2d6-4651-812f-0d6271be004a none tpm2-device=auto,discard
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;运行 &lt;code&gt;sudo dracut -f&lt;&#x2F;code&gt; 重新构造 &lt;code&gt;intiramfs&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;修改 &lt;code&gt;&#x2F;etc&#x2F;default&#x2F;grub&lt;&#x2F;code&gt; 增加新的 LUKS 分区到内核启动参数，确保在 Grub 阶段能够解锁分区，我以为是运行 &lt;code&gt;dracut&lt;&#x2F;code&gt; 自动会新增的，可惜并不是，遗漏这一步导致我一直无法成功&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;code&gt;GRUB_CMDLINE_LINUX&lt;&#x2F;code&gt; 字段新增参数 &lt;code&gt;rd.luks.uuid&lt;&#x2F;code&gt;，原有应该就有一个同样的参数，值为原有的 LUKS 分区名，直接将新的 LUKS 分区以同样的形式增加即可&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;根据参考，多个 &lt;code&gt;rd.luks.uuid&lt;&#x2F;code&gt; 和 &lt;code&gt;&#x2F;etc&#x2F;crypttab&lt;&#x2F;code&gt; 将会在系统启动阶段激活其中的设备，如果不修改，那么将无法在启动阶段使用新的分区，自然也就无法启动成功&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;参考：https:&#x2F;&#x2F;www.freedesktop.org&#x2F;software&#x2F;systemd&#x2F;man&#x2F;latest&#x2F;systemd-cryptsetup-generator.html&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;GRUB_CMDLINE_LINUX&lt;&#x2F;span&gt;&lt;span&gt;=&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;rd.luks.uuid=luks-3bf2404b-95b5-4c38-b51f-7e8d4611d173 rd.luks.uuid=luks-84f5172e-c2d6-4651-812f-0d6271be004a rhgb quiet&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;运行 &lt;code&gt;sudo grub2-mkconfig -o &#x2F;etc&#x2F;grub2.cfg&lt;&#x2F;code&gt; 更新 &lt;code&gt;grub2&lt;&#x2F;code&gt; 配置文件&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;我记得以前是要运行 &lt;code&gt;sudo grub2-mkconfig -o &#x2F;boot&#x2F;efi&#x2F;EFI&#x2F;fedora&#x2F;grub.cfg&lt;&#x2F;code&gt; 的，但是在 Fedora 文档中关于更新 Grub 配置的部分提及，在新版本的 Fedora 中，&lt;code&gt;&#x2F;boot&#x2F;efi&#x2F;EFI&#x2F;fedora&#x2F;grub.cfg&lt;&#x2F;code&gt; 只是一个小文件，这个文件简单的指向 &lt;code&gt;&#x2F;boot&#x2F;grub2&#x2F;grub.cfg&lt;&#x2F;code&gt;，同时 &lt;code&gt;&#x2F;etc&#x2F;grub2.cfg&lt;&#x2F;code&gt; 也是这个文件的一个链接&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;将新建的 Btrfs 分区添加到原有的 Btrfs 文件系统中 &lt;code&gt;sudo btrfs device add &#x2F;dev&#x2F;mapper&#x2F;luks-84f5172e-c2d6-4651-812f-0d6271be004a &#x2F;&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;重启验证&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果系统无法启动，说明以上步骤中存在错误或者遗漏，进入准备好的其他 Linux 环境撤销操作，在尝试过程中我一直没有将新的 LUKS 分区增加到内核启动参数中，系统无法启动，准备好的 Linux 环境就救命了。在这里也记录一下我的撤销步骤。&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;进入环境&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;解锁两个 LUKS 分区&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; cryptsetup luksOpen &#x2F;dev&#x2F;nvme0n1p6 origin
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; cryptsetup luksOpen &#x2F;dev&#x2F;nvme0n1p7 new
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;挂载其中一个 Btrfs 分区到文件系统（任意一个都没事，因为之前操作中合并了）&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;mkdir ~&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;test
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; mount &#x2F;dev&#x2F;mapper&#x2F;origin &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;~&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;test
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;从 Btrfs 文件系统中删除新增的 Luks&#x2F;Btrfs 分区&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; btrfs device remove &#x2F;dev&#x2F;mapper&#x2F;new &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;~&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;test
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;重启&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;备份文件增加 LUKS 可用性&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;备份 &lt;code&gt;&#x2F;etc&#x2F;fstab&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;备份 &lt;code&gt;&#x2F;ect&#x2F;crypttab&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;备份 &lt;code&gt;&#x2F;ect&#x2F;default&#x2F;grub&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;备份 LUKS header&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; cryptsetup luksHeaderBackup &#x2F;dev&#x2F;nvme0n1p6&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --header-backup-file&lt;&#x2F;span&gt;&lt;span&gt; nvme0n1p6.bin
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; cryptsetup luksHeaderBackup &#x2F;dev&#x2F;nvme0n1p7&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --header-backup-file&lt;&#x2F;span&gt;&lt;span&gt; nvme0n1p7.bin
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 验证备份文件
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; cryptsetup luksDump nvme0n1p6.bin
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>破碎的诗歌 —— 《诗人》</title>
        <published>2023-03-17T00:00:00+00:00</published>
        <updated>2023-03-17T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/the-poet-note/"/>
        <id>https://ghost.livexia.xyz/the-poet-note/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/the-poet-note/">&lt;blockquote&gt;
&lt;p&gt;《诗人》—— 迈克尔·康奈利 读后感&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;两天前的早晨，我坐在阳台的椅子上，看着手机心生厌恶，侧头向窗外看去，又是天气极佳，阳光还没能进入阳台，我的心情不像阳光一样那么阳光。我的内心一片空虚，不知道自己的方向，没有任何力量，我只在消耗时间。我转移自己的注意力，我不认识自己，甚至于一个月前疯狂的喜欢一个人，但我却对自己充满怀疑，无法相信自己。这一切和这本书有什么关系呢？好像并没有，但我就是在这样的心情中点开了这本书，我需要一本紧张的书，能紧紧抓牢我，让我不再胡思乱想。现在读完这本书，好像它达成了最初的使命，但是好像也起了反作用。&lt;&#x2F;p&gt;
&lt;p&gt;悬疑和侦探小说是不适合介绍剧情的，这本书并不薄，所以我预期会有好几个反转，但是不断的阅读，对反转的预期越来越低，不需要反转就足够完整了。而当我阅读到反转的时候，阳台外的天空，顺应了剧情发展，乌云开始聚集，我的身体开始颤栗，一种恐惧降临了。我意识到这个世界也许就是孑然一身，也许我的那些空虚是确实的，我所拥有的就是空虚，我存在的价值就是空虚。&lt;&#x2F;p&gt;
&lt;p&gt;过去和未来是不存在的，存在的只有这一刻，时间是流动的，我就是一颗水珠，顺着时间流动，上一个位置和未来的位置，也许我能记得和短暂遇见，但是他们是不存在的。时间是无法划分的，现在是一个什么概念我表达不了，它是数学里的一个点，不存在范围，也就是说我在一个点上存在。这个点上的我不断的变化，点并不变大变小，过去的事情和对未来的期待，时时刻刻的在对这个点上的我发挥作用，因此孑然一身的我被两张网所包围。&lt;&#x2F;p&gt;
&lt;p&gt;一切判断和选择，人们都会尝试从这两张网中寻找答案，所以这两张网既是束缚又是线索，如果没有那么人生将多么自由，不必因为过去而担有责任，又不必因为未来而胆战心惊。但那也意味着，我在一个点上会变的无比渺小，仅仅成为生物上的人，和窗外马路上那只正在寻找虫子的母鸡毫无差别。&lt;&#x2F;p&gt;
&lt;p&gt;好像这些都和这本书没关系，但我却在读这本书时，不断的思考这些问题，作者巧妙的勾画了一个不寒而栗的故事，细致而深入的描绘每一个人物，让他们做出选择和判断，在我眼中看来就是让他们去体验不同的可能性。如此残忍的事件，究竟为何，而代表正义的人又是究竟为何选择正义。&lt;&#x2F;p&gt;
&lt;p&gt;看到对面大妈走向鸡窝，也许是要拿东西，突然发现本来满地乱跑的鸡，都有了一致的目标，都朝着大妈去了，当发现大妈并没有要喂它们的时候，它们又一哄而散。那么鸡也是受到了过去和未来的束缚吗？也许它们的过去和未来都更加简单，但是更加简单就意味着更容易被束缚。虽然在我自己的脑海中，我的过去和未来对我的束缚更加牢固，但是这也意味着也许我并不容易被喂食的假象所控制，当然我无法抵抗时间，所以也许我会被时间碾碎，最后深陷在黑暗中，我不想做一颗被裹挟的水珠，但我也不想被过去紧紧抓牢。&lt;&#x2F;p&gt;
&lt;p&gt;这是一本悬疑侦探小说，不是一本哲学书，并不包含深奥难懂的哲理，那么为何让我不断的思索，我的内心因为读过这本书而有了一些新的东西，也许我依旧感到空虚，但是阴云密布的天空并不意味压抑与低沉，也意味着即将到来的畅快淋漓，为了那一天我接着书本继续与自己对话。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>参加2022年Advent of Code</title>
        <published>2023-01-01T00:00:00+00:00</published>
        <updated>2023-01-01T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/adventofcode2022/"/>
        <id>https://ghost.livexia.xyz/adventofcode2022/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/adventofcode2022/">&lt;p&gt;代码仓库：&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;livexia&#x2F;advent-of-code-2022&quot;&gt;livexia&#x2F;advent-of-code-2022&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;链接: &lt;a href=&quot;https:&#x2F;&#x2F;adventofcode.com&#x2F;2022&quot;&gt;Advent of Code 2022&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jin-yi-bu-xue-xi&quot;&gt;进一步学习&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;对所有代码进行 clippy 检查并修改&lt;&#x2F;li&gt;
&lt;li&gt;Day 22&lt;&#x2F;li&gt;
&lt;li&gt;Day 19 (进一步性能提升)&lt;&#x2F;li&gt;
&lt;li&gt;Day 18&lt;&#x2F;li&gt;
&lt;li&gt;Day 17&lt;&#x2F;li&gt;
&lt;li&gt;Day 16 (测试不通过)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;zong-jie&quot;&gt;总结&lt;&#x2F;h2&gt;
&lt;p&gt;今年自己可以明显感觉到对于路径查找、动态规划的题目更加熟练，虽然期间也有几天的题目花了非常多的时间，但是基本上自己都能够独立完成，看了去年的排名和时间，可以发现好像去年的结果好像稍好看一些，但是去年如果自己几个小时想不出来，我就直接看社区答案了。今年有三天第二部分应该是看了社区的思路，但是今年借鉴的成分远比去年少，更多的还是自己实现。相比于去年，今年对于记忆化搜索认识更加彻底，意识到在何种场景下增加缓存能够加速程序。而对于 DFS 、 BFS 和 DP 去年可能都仅有简单理解，而今年自己则更加的熟练，对于去年不熟练的迭代和递归，今年也可以熟练运用和理解。虽然今年也有不少需要构建树的题目，但是我通过侧面的方法规避了直接构造树结构，所以对于树的构造依旧不熟练，我现在对于 Rc RefCell 和其他一些的智能指针已经有了足够多的认知，但是相关的练习依旧较少，这是后续需要提升的。在性能分析和程序风格上，我使用 cargo flamegraph 对程序性能进行分析，通过分析可以确定程序优化点，确定是否有必要进一步对当前的方法进行优化。使用 cargo clippy 对 rust 代码进行规范和风格检查，虽然在最后几天才开始使用这个工具，但是这个工具的效益已经让我觉得必不可少，所以在最后我也会对今年 AOC 的之前代码都进行 clippy 检查。今年终于在最后一天的 part 2 挤进前 1000 ，明年加油。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;day-25&quot;&gt;Day 25&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;依旧是最后一天圣诞节的简单题。&lt;&#x2F;li&gt;
&lt;li&gt;需要实现数字的进制转换，类似于五进制和十进制间的转换。&lt;&#x2F;li&gt;
&lt;li&gt;题目给出的并非标准的五进制，并不是从 0 到 4 五个数字表示，而是由 = - 0 1 2 五个字符表示，其中 = 表示 -2 ，而 - 表示 -1。&lt;&#x2F;li&gt;
&lt;li&gt;首先是五进制转十进制，这很容易实现，输入为字符串，从字符串尾部（数字低位）开始读取，根据读入的字符对当前位的基进行乘法运算，合并每一位的计算结果即可得到十进制表示，基从 1 开始每一位之后都需要乘 5 。&lt;&#x2F;li&gt;
&lt;li&gt;十进制转题目中的五进制是比较复杂的，对于一般的五进制，一般是对十进制取 5 的余数，然后将十进制整除 5 ，直到十进制为 0 ，只这样可以得到从最低位到最高位的五进制表示。但是题目中的表示形式是 = - 0 1 2 ，可以发现实际上 = 就是 5 - 3，- 则是 5 - 4，也就是说当余数为 3 的时候，如果我们将其视为 5 ，那么就需要减 2 ，也就是 = 符号，同理 - 也是如此。所以当余数为 3 时，向结果中推入 = &lt;code&gt;snafu.push(&#x27;=&#x27;)&lt;&#x2F;code&gt;，但是因为借了 2 给十进制，所以需要对十进制整除 5 的结果加一 &lt;code&gt;num += 1&lt;&#x2F;code&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;实现这两个方法就可以解决第一部分的问题，因为是最后一天，所以第二部分是直接可以通过的。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-24&quot;&gt;Day 24&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;今天的题目并不困难，但是存在一个边界情况没有考虑到，浪费了不少时间。&lt;&#x2F;li&gt;
&lt;li&gt;输入为当前时刻的地图以及暴风雪情况。&lt;&#x2F;li&gt;
&lt;li&gt;地图的每一个坐标处存在三种情况：墙、空地、暴风雪，人和暴风雪无法移动到为墙的坐标，人无法移动到为暴风雪的坐标，暴风雪可以移动到为暴风雪的坐标。&lt;&#x2F;li&gt;
&lt;li&gt;存在两个移动的物体：&lt;&#x2F;li&gt;
&lt;li&gt;第一个是人也就是我，需要从起点移动到终点。在一分钟内人可以上下左右移动，&lt;strong&gt;如果情况允许&lt;&#x2F;strong&gt;也可以不移动。移动规则如下：
&lt;ul&gt;
&lt;li&gt;不能移动到地图边界之外&lt;&#x2F;li&gt;
&lt;li&gt;不能移动到墙&lt;&#x2F;li&gt;
&lt;li&gt;不能移动到为暴风雪的坐标&lt;&#x2F;li&gt;
&lt;li&gt;如果下一分钟暴风雪会移动到当前位置，那么不能在原地不动&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;第二个则是地图上到处都有的暴风雪，暴风雪的移动规则如下：
&lt;ul&gt;
&lt;li&gt;每个暴风雪占据一个坐标，由输入的字符表示移动方向&lt;&#x2F;li&gt;
&lt;li&gt;移动过程中暴风雪的方向不变&lt;&#x2F;li&gt;
&lt;li&gt;每次移动花费一分钟，一次移动最多移动一个方格&lt;&#x2F;li&gt;
&lt;li&gt;当移动到边界时，方向不变的从另一侧边界继续移动，也只需要一分钟&lt;&#x2F;li&gt;
&lt;li&gt;如果多个暴风雪的下一个位置相同，那么下一分钟时他们同时存在与那个位置，不影响暴风雪的移动&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;可以发现人的移动情况是受制于暴风雪的位置，而暴风雪的移动则与时间和地图大小有关。&lt;&#x2F;li&gt;
&lt;li&gt;构造 struct Map 表示某一时刻的地图情况，因为输入地图大小较小，同时无论是人还是暴风雪的移动都被限制在一定范围内，并不是无限平面，所以直接使用二维 Vec 存放当前地图情况。每一个元素表示当前位置的类型，因为可能存在多个暴风雪，每一个元素也是一个 Vec 。&lt;&#x2F;li&gt;
&lt;li&gt;暴风雪直接用输入的字符表示，在每一分钟的移动中，首先构造同样大小的 Vec 存放下一分钟的地图情况。遍历每一个坐标，如果当前坐标处为一个或多个暴风雪，移动这些暴风雪（考虑边界情况），在新的 Vec 中重新存入暴风雪。所有坐标完成便利后，替换 Map 中的 Vec ，暴风雪移动完成。&lt;&#x2F;li&gt;
&lt;li&gt;在实现了暴风雪的移动之后，我尝试进行无限次的移动，同时将每一分钟的地图情况存入集合，我想要判断是否会出现循环的情况，果不其然发现了循环，对于示例输入循环是 12 ，我的输入循环则是 600 ，也就是说可以将时间与地图对应，而不需要一边移动一边更新地图的情况。实际上循环的大小就是可移动区域长宽的最小公倍数，示例输入是 4 和 6 最小公倍数是 12 ，而我的输入则是 25 和 120 最小公倍数刚好是 600 ，向上或者向下的暴风雪，最少移动距离为可移动区域的高度，就可以回到原处，同样的向左向右则是可移动区域的宽度，而要所有的暴风雪都再次回到原地，那么最少就需要长宽的最小公倍数。&lt;&#x2F;li&gt;
&lt;li&gt;确定了暴风雪的移动情况存在循环，那么就可以考虑人的移动。&lt;&#x2F;li&gt;
&lt;li&gt;因为要计算最短路径，无权图直接使用&lt;strong&gt;广度优先搜索&lt;&#x2F;strong&gt;，初始位置为起点。&lt;&#x2F;li&gt;
&lt;li&gt;在任意坐标处，人的移动情况最多有五种，上下左右和不动，这些移动情况收到当前时间的地图情况影响，虽然题目中描述人和暴风雪的移动是同时的，但不妨想象暴风雪移动先进行，然后人再进行移动。&lt;&#x2F;li&gt;
&lt;li&gt;队列的元素为当前人的坐标和下一分钟的时间，因为时间和地图情况存在对应和循环关系，实际上元素可以理解为是人的坐标和下一分钟暴风雪的情况，或者是上一个坐标和当前暴风雪情况。&lt;&#x2F;li&gt;
&lt;li&gt;在队列不为空的情况，每次从队首弹出坐标和当前地图情况，计算当前坐标所有可能的下一个位置，判断这些坐标在当前地图中是否允许，如果允许则直接将该坐标和加一点时间压入队列尾部，如果这些坐标中包含了目的地，则搜索完成，直接返回当前时间。&lt;&#x2F;li&gt;
&lt;li&gt;在搜索过程中增加访问表，如果当前人的位置和下一刻暴风雪的情况已经出现过，那么这个路径无需再进行搜索，之前的路径一定短与当前路径。因为暴风雪的移动情况存在循环，与时间存在直接的对应关系，所以无需用坐标和暴风雪的情况作为访问表的元素，而可以直接使用转换后的时间（最小周期的时间即可）。同时对与搜索的元素也要在访问表中插入坐标和对应转换后的时间。&lt;&#x2F;li&gt;
&lt;li&gt;第一部分就是进行一次搜索，第二部分则是进行三次搜索。&lt;&#x2F;li&gt;
&lt;li&gt;在实现的过程中有一个人移动情况的细节被我忽略了，对于在原地等待的情况，这个时候不仅要考虑下一分时，我是否还能在原地等待，所以也要判断下一时刻当前位置是否有暴风雪。然后也要考虑起始位置的情况，很可能在一开始我就无路可去，也就是说我只能在原地等，在这里我做了一个假设，也就是起点和终点都是一定不会有暴风雪的，实际上在暴风雪的移动中我也并不考虑这两个位置，所以在这个情况下如果我在起点，那么我想要等多久都可以（拖延症晚期患者）。再处理这个两个细节问题之后，轻松解决。&lt;&#x2F;li&gt;
&lt;li&gt;优化 1 ，使用更加高效的方式代表暴风雪的情况：
&lt;ul&gt;
&lt;li&gt;因为每一行输入的长度不大于 128 所以可以使用 u128 代表一行的暴风雪出现的情况&lt;&#x2F;li&gt;
&lt;li&gt;同时在初始状态，每一个方格仅有一个暴风雪（如果一个坐标处存在两个以上的暴风雪，无法决定任一的方向，题目无解）。&lt;&#x2F;li&gt;
&lt;li&gt;所以理论上再移动的过程中，一个坐标最多存在四个方向不同的暴风雪。&lt;&#x2F;li&gt;
&lt;li&gt;根据这一点可以使用4个 u128 表示一行中每个位置每一个方向暴风雪的出现情况。&lt;&#x2F;li&gt;
&lt;li&gt;这个方法可以降低预构造哈希表的难度。存储空间由 u8 * 4 * 122 * 27 到 4 * 27 * u128&lt;&#x2F;li&gt;
&lt;li&gt;参考：https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;zu28ij&#x2F;comment&#x2F;j1gww24&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;优化 2 ，可以确定暴风雪的出现情况是与时间直接关联的，同时周期是同可移动范围的长宽相关，那么在预构造的过程中完全可以直接计算所有周期，而不必使用 HashMap 尝试的方法。需要实现 lcm 函数计算最小公倍数。&lt;&#x2F;li&gt;
&lt;li&gt;这两个优化提升并不明显，特别是第一个优化，这个优化方法会增加理解难度，虽然我实现了，但是在这个场景里不是特别有价值。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-23&quot;&gt;Day 23&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;依旧是需要注意细节的模拟题。&lt;&#x2F;li&gt;
&lt;li&gt;输入为地图，# 为精灵的初始位置。&lt;&#x2F;li&gt;
&lt;li&gt;题意分析
&lt;ul&gt;
&lt;li&gt;精灵需要移动到特定位置，以类似于回合制的方式进行移动。&lt;&#x2F;li&gt;
&lt;li&gt;每一个回合包括选择移动和进行移动两个部分。&lt;&#x2F;li&gt;
&lt;li&gt;在选择移动的阶段，所有精灵都会进行选择，选择移动分为如下几个阶段
&lt;ol&gt;
&lt;li&gt;如果当前精灵在八个领接方向上都没有精灵，那么当前精灵不需要移动&lt;&#x2F;li&gt;
&lt;li&gt;存在四条移动规则，其中一条如下，如果当前精灵的北方、西北方和东北方的领接坐标处都没有精灵，那么当前精灵可以选择向北移动。每个精灵都会对四条移动规则进行判断，如果存在规则允许移动时，选择停止，后续规则不再判断。&lt;&#x2F;li&gt;
&lt;li&gt;如果对四条规则都完成了判断，同时也没有可选的移动目标，那么当前精灵不移动。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;在移动阶段，所有精灵一起移动，如果某一个坐标是两个及以上精灵的移动目的地，那么这些精灵都不移动。&lt;&#x2F;li&gt;
&lt;li&gt;所有的精灵完成移动之后，需要调整移动规则的次序。当前四条规则中最先被考虑的规则将被移动到规则列表的尾部。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;构造 Ground 类代表地图的情况，可能不是一个好的名字。包含了 elves 即所有精灵坐标的 HashSet，以及四条规则。&lt;&#x2F;li&gt;
&lt;li&gt;在输入处理中构造初始 elves ，同时根据题意硬编码移动规则。&lt;&#x2F;li&gt;
&lt;li&gt;移动规则的保存，我是直接以字符串数组的形式三个检测规则和最终移动方向。例如 &lt;code&gt;[&quot;N&quot;.to_string(), &quot;NE&quot;.to_string(), &quot;NW&quot;.to_string(), &quot;N&quot;.to_string()]&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;具体的坐标变换，编写了 4 个函数，分别对应向北、向南、向西或者向东移动一步。而对于 &lt;code&gt;NE&lt;&#x2F;code&gt; 这样的移动，实际上就是执行向北和向西的函数。可以直接使用 &lt;code&gt;match&lt;&#x2F;code&gt; 来快速计算移动后的坐标，通过四个函数就可以覆盖八个方向的所有移动。&lt;&#x2F;li&gt;
&lt;li&gt;在选择移动目的坐标的时候，首先判断当前精灵的八个领接方向是否存在精灵，如果都不存在直接放入 &lt;code&gt;next_move: HashSet&amp;lt;Pos&amp;gt;&lt;&#x2F;code&gt;，其中的精灵在这个回合都不移动。&lt;&#x2F;li&gt;
&lt;li&gt;然后，我利用 &lt;code&gt;possible_move: HashMap&amp;lt;Pos, Vec&amp;lt;Pos&amp;gt;&amp;gt;&lt;&#x2F;code&gt; 保存中间结果，其中的键为根据规则确定的下一个坐标，而值则为在这一个回合开始时这个精灵的坐标，因为一个目的坐标可能会被多个精灵选择，所以是 Vec。&lt;&#x2F;li&gt;
&lt;li&gt;当所有精灵完成了选择时，遍历 &lt;code&gt;possible_move&lt;&#x2F;code&gt; ，如果值对应的数组长度为 1 ，说明目标坐标只有一个精灵选择，将键即新坐标加入 &lt;code&gt;next_move&lt;&#x2F;code&gt; ，否则值中的所有精灵不移动，坐标不变，将数组中所有的精灵坐标加入 &lt;code&gt;next_move&lt;&#x2F;code&gt; 。&lt;&#x2F;li&gt;
&lt;li&gt;完成移动后，将移动规则的第一个元素移除，将其放到移动规则列表的尾部。移动规则以 &lt;code&gt;Vec&lt;&#x2F;code&gt; 存储，使用 &lt;code&gt;remove(0)&lt;&#x2F;code&gt; 进行移除，再通过 &lt;code&gt;push&lt;&#x2F;code&gt; 压入尾部。&lt;&#x2F;li&gt;
&lt;li&gt;当完成十个回合时，需要计算第一部分的结果，首先遍历此时所有精灵的坐标，取的每个坐标的范围，确定长方形的边界，计算长方形的面积，然后减去精灵的数量，得到第一部分结果。&lt;&#x2F;li&gt;
&lt;li&gt;第二个部分需要计算再多少个回合之后，所有的精灵都不进行移动，构造 loop 循环，循环中记录当前回合数，同时执行一回合，在每一个回合中统计没有移动的精灵数量，如果等于总的精灵数量，返回真，表示所有的精灵不再移动，循环结束并返回回合数。&lt;&#x2F;li&gt;
&lt;li&gt;两个部分的解答都不困难，在移动的逻辑上要注意题目要求，我漏看了一个移动规则浪费了一些时间。两个部分的执行效率也都可以接受，在 release 版本第二个部分花费半秒左右，而 debug 版本则会花费 15 s 左右，虽然不能算得上是极快，但是我并没有什么意见。也许第二个部分也可以进行优化，但是那要求对于每两个精灵的位置进行具体的分析，也许会有效率的提升，但是每次依旧需要更新精灵的坐标，不能确定进一步的优化是否有必要。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-22-ban-shou-dong-wan-cheng-di-er-bu-fen&quot;&gt;Day 22（半手动完成第二部分）&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;15051530&#x2F;209130206-73dfea30-9480-4866-9ed6-891ff4d3c20f.png&quot;&gt;cube&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;依旧是一道模拟题，根据输入的地图和指令进行移动，确定最终位置。&lt;&#x2F;li&gt;
&lt;li&gt;输入包含两部分：地图和移动指令，使用 HashMap 存储地图，方便确定位置，构造哈希表的过程中记录最远位置（最远列加一），作为地图边界，地图起始坐标为 (0, 0)。&lt;&#x2F;li&gt;
&lt;li&gt;地图形状并不规则，所以不能删除空格。存在三种方块，空白方块代表不存在。开放方块代表存在并且可在其上移动的方块。墙方块代表存在，但不能在其上移动的方块。&lt;&#x2F;li&gt;
&lt;li&gt;构造 Movement 枚举类型存放移动指令，直走为 S(i32) ，右转为 R ，左转为 L。&lt;&#x2F;li&gt;
&lt;li&gt;第一个部分较容易，移动逻辑如下：
&lt;ul&gt;
&lt;li&gt;确定地图第一行最早的开放方块，这个坐标是起始坐标，初始时移动方向为向右。&lt;&#x2F;li&gt;
&lt;li&gt;根据指令进行移动，存在两种移动方式，直走和转弯。&lt;&#x2F;li&gt;
&lt;li&gt;如果直走中遇到墙那么当前移动终止。如果直走进入了空白区域，那么就要从地图的另一侧继续直走，空白部分类似于虫洞，直接连接两侧非空白区域。&lt;&#x2F;li&gt;
&lt;li&gt;转弯是在原地进行的，不会改变具体坐标。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;根据这个逻辑，可以直接进行模拟。直走过程中只有当移动到的位置是墙或者开放，才计算移动距离，如果移动进入空白区域，那么继续移动，但不影响实际坐标，如果移动超过了地图边界（输入构成的长方形，包含空白方块），对当前坐标取边界的模数（余数），然后再继续移动。直到统计的移动距离等于当前指令指定的直走距离，或者撞到墙，直走停止。&lt;&#x2F;li&gt;
&lt;li&gt;令移动方向向右为 0 向下为 1 向左为 2 向上为 3，可以发现方向对应的值随着顺时针方向增大，逆时针方向减小，向右转即是顺时针方向改变，向左转即是逆时针方向，利用这个特点快速调整方向，当方向为 4 或 -1 的时候，进行判断跨越即可。 4 == 0 ， -1 == 3 。&lt;&#x2F;li&gt;
&lt;li&gt;因为使用 HashMap ，而且坐标的类型为 i32 ，所以不需要担心在 0 处的溢出，根据不同的方向构造不同的坐标变化函数，即可实现不同方向的移动。&lt;&#x2F;li&gt;
&lt;li&gt;当指令执行完成后，得到最终的坐标和朝向，进行密码计算即可解决第一部分。&lt;&#x2F;li&gt;
&lt;li&gt;第二个部分非常复杂，不规则的地图实际上是一个立方体的表面展开，立方体的六个面互相连接。所以当移动到空白区域时，需要根据立方体面的连接情况进行对应的移动。整体的思路其实是一致的，只不过在计算移动到边界时的下一个坐标较难。&lt;&#x2F;li&gt;
&lt;li&gt;我首先在纸上画了我的输入中的地图，然后对每个面进行编号，折叠立方体，观察每个面边的连接情况。我并没有总结出通用的规律，最后我决定直接将连接边的对应关系进行硬编码。
&lt;ul&gt;
&lt;li&gt;已知立方体边长为 50&lt;&#x2F;li&gt;
&lt;li&gt;以起点和终点的二元组记录所有不相连的边，总共有 14 条这样的边。记录方向是从左到右，从上到下。&lt;&#x2F;li&gt;
&lt;li&gt;观察这些边之间的连接关系，确定每条边的对应边。
在折叠之后，两条边的起点和终点并不都是从左到右或从上到下的，部分的重叠边是相反的。&lt;&#x2F;li&gt;
&lt;li&gt;如果一条边位于一个面的右侧，那么移动到这个边并产生跨越的情况时，移动方向一定是向右的（不考虑顶点），如果另一条边是处于面的下侧，那么移动方向就会从向右边为向上，所以也要记录从一条边到另一条重叠边的方向变化情况。&lt;&#x2F;li&gt;
&lt;li&gt;最后我手写生成了一个元组，其中第一个元素为起始边，第二个元素为目标边，第三个元素为移动方向的改变。&lt;&#x2F;li&gt;
&lt;li&gt;根据这些信息，就可以计算跨越时坐标和移动方向的变化。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;这个方法异常的繁复，对于每一条边的坐标都要确保正确，确保边是处于面之内的，同时每一条边的对应边的情况也要记录正确。然后进行坐标计算的时候也要考虑到两条边的方向问题。在这些细节上我都犯过错误，但是最后终于得到了一个提交通过的答案。&lt;&#x2F;li&gt;
&lt;li&gt;这个做法并不通用，我根据自己的输入构造了边的对应情况，边的方向。这并不是一个通用的程序，如果要实现通用的程序，我需要实现以下功能：
&lt;ul&gt;
&lt;li&gt;输入的过程中检测边，确定边的范围&lt;&#x2F;li&gt;
&lt;li&gt;计算边与边之间的对应关系，以及对应边的方向关系&lt;&#x2F;li&gt;
&lt;li&gt;根据边在面上的位置确定移动方向的变化&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;通用的方法&lt;&#x2F;strong&gt;
&lt;ul&gt;
&lt;li&gt;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;zsct8w&#x2F;comment&#x2F;j184mn7&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-21&quot;&gt;Day 21&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;今天题目不难，这让我担忧明天的题目难度。题目并不难，但是如果想要能够解决通用化的输入，那实际上依旧非常复杂，今天的输入有以下几个假设：
&lt;ul&gt;
&lt;li&gt;输入中只有一个猴子和 humn 相关&lt;&#x2F;li&gt;
&lt;li&gt;root 猴子的值和 humn 一定是单调的（和前一个假设其实是一样的）&lt;&#x2F;li&gt;
&lt;li&gt;除法操作一定是整除（即不使用浮点数作为数据类型，使用整形如果用二分法暴力查找，会得到好几个结果）&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;输入为猴子的列表，根据题意可以直接抽象为算数表达式&lt;&#x2F;li&gt;
&lt;li&gt;部分猴子对应数字，部分猴子对应算数表达式（与两个其他的猴子相关联）&lt;&#x2F;li&gt;
&lt;li&gt;第一部分需要计算名为 root 的猴子最后的值&lt;&#x2F;li&gt;
&lt;li&gt;利用哈希表存储猴子名和猴子编号的对应关系，利用数组存储所有的猴子，数组索引与猴子编号相互对应。每一个猴子可能对应一个数，或者对应两个猴子和一个操作，其中对应猴子也通过编号记录。&lt;&#x2F;li&gt;
&lt;li&gt;利用哈希表和数组避免了构造树，通过编号访问猴子的属性，也没有增加计算的复杂度。&lt;&#x2F;li&gt;
&lt;li&gt;第一部分直接模拟，深度优先搜索，同时构建 memo 实现记忆化搜索，从哈希表中得到 root 猴子的编号，从这个编号开始搜索。搜索逻辑如下：
&lt;ul&gt;
&lt;li&gt;如果当前猴子对应一个数，则直接返回这个数&lt;&#x2F;li&gt;
&lt;li&gt;如果当前猴子在 memo 中已经存在，直接返回 memo 的结果&lt;&#x2F;li&gt;
&lt;li&gt;如果当前猴子对应一个算数表达式，那么对表达式中的两个猴子进行同样的搜索并得到结果，再根据操作对两个猴子的结果进行计算。将当前猴子编号和计算结果存入 memo，返回计算结果&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;环是不存在的&lt;&#x2F;strong&gt;，如果存在环就意味着存在无法计算 root 猴子结果，那么至少对于和 root 相关的所有猴子而言，环是不存在的，不需要进行环的检测。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;在运行 release 版本的程序时得到了错误的结果，通过 debug 版本可以发现存在越界的情况，因为我使用 i32 记录计算结果，而乘法则导致存在溢出，替换为 i64 后结果正确。&lt;&#x2F;li&gt;
&lt;li&gt;第二个部分看似比第一部分复杂不少，root 猴子不再对应一个数学运算，而是判断其相关联的两个猴子的数值是否相同，同时 humn 也不是猴子，而是做题的人（我），需要计算的就是当我喊出的数值使得 root 对应的两个猴子的数量相同。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;简单枚举得到第二部分结果&lt;&#x2F;strong&gt;，通过第一部分我已经知道了计算数值较大，所以暴力测试 humn 的值是不现实的，所以我首先观察了规律，测试了一些 humn 的值。测试过程中发现两个猴子的值其中一个是不和 humn 相关的，同时另一个猴子的值则和 humn 成反比 humn 越大值越小。知道这一点之后，不断的增大 humn 的值，使得两个猴子的差值越小。最后通过这个方法可以确定 humn 的值，而且存在好几个，提交通过。测试的方法没有问题，但是如何通过程序直接计算呢？大致有两个思路。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;二分查找&lt;&#x2F;strong&gt; humn ，如果 humn 和两个猴子的值存在关联，而且相关性是单调的，那么就可以通过二分法查找结果。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;求解方程&lt;&#x2F;strong&gt;，只存在一个未知数 humn，也只有一条方程，计算出两个猴子的算数表达式，然后求解方程。
&lt;ul&gt;
&lt;li&gt;题目的输入比较凑巧，所以和 root 相关的两个猴子中只有一个与 humn 相关，而且所有猴子中只有一个猴子是和 humn 相关的，可以进行简单的方程求解&lt;&#x2F;li&gt;
&lt;li&gt;一个表达式为包含 humn 的 f&lt;&#x2F;li&gt;
&lt;li&gt;另一个表达式为常数&lt;&#x2F;li&gt;
&lt;li&gt;那么直接逆向求解 f 直到 humn 即可&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-20&quot;&gt;Day 20&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;今天的题目简单一些，但在实现过程中依旧因为细节问题导致无法得出正确的答案。&lt;&#x2F;li&gt;
&lt;li&gt;每一行输入均为一个数字，处理简单，但在具体的计算过程中可能要引入辅助数据结构。&lt;&#x2F;li&gt;
&lt;li&gt;题意分析：
&lt;ul&gt;
&lt;li&gt;输入为数字列表，需要根据列表中数字的值移动数字&lt;&#x2F;li&gt;
&lt;li&gt;移动可以向前也可以向后，移动的次数为数字的值&lt;&#x2F;li&gt;
&lt;li&gt;列表成环，当数字移动到列表尾部或者头部还没完成移动，那就需要从另一侧继续移动，&lt;strong&gt;环的特征如下&lt;&#x2F;strong&gt;：
&lt;ul&gt;
&lt;li&gt;起点和终点实际上是同一个位置，考虑输入长度为 3，将输入视为数组，输入为 [-1, 1, 0]， 数字 -1 左侧的数字为 0 ，右侧的数字为 1 ，所以如果 -1 左移一个位置，也就是说 -1 右侧的数字为 0 ，所以数字 -1 新的索引就是 1，而不是 2。&lt;&#x2F;li&gt;
&lt;li&gt;同样的对于输入 [-1, 0, 1]，数字 1 要右移一个位置，那么它新的索引应该是 1 而不是 0。&lt;&#x2F;li&gt;
&lt;li&gt;对于一般的数组例如 [0, 1, 2]，如果数组也成环，那么在数字 2 之后就是 0 ，在数字 0 之前就是 1 ，往往可以直接通过 index % length 求解越界时新的索引，但在这个题目中这样的计算方式是错误的。&lt;&#x2F;li&gt;
&lt;li&gt;因为是移动数据，所以可以想象这时移动的数据已经被删除了，对于第一个例子输入就变成了 [1, 0]，可以想象这个时候 -1 和 0 处于同一个位置，然后再左移一个位置，也就是 1 和 0 的中间。具体的可以利用 index % (length - 1) 进行计算。&lt;&#x2F;li&gt;
&lt;li&gt;在 Rust 中的 % 运算计算的余数，而非取模，所以 -2 % 10 的结果是 -2 而不是 8。所以在计算小于 0 的索引时，还要在加上 length - 1 得到取模的结果。&lt;&#x2F;li&gt;
&lt;li&gt;可以直接使用 next.rem_euclid(length - 1)
&lt;ul&gt;
&lt;li&gt;参考 https:&#x2F;&#x2F;github.com&#x2F;wilkotom&#x2F;AoC2022&#x2F;blob&#x2F;main&#x2F;day20&#x2F;src&#x2F;main.rs&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;移动数字的顺序是输入的顺序&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;题目并不复杂，输入数据量也不大，解决这个问题的最优数据结构应该是链表，但我对链表并不熟悉，所以第一想法就是直接使用 Vec 实现。&lt;&#x2F;li&gt;
&lt;li&gt;Vec 数组实现
&lt;ul&gt;
&lt;li&gt;考虑只移动一个数字，当前位置为 cur ，数值值为 offset ，输入数据长度为 length，那么下一个位置 next = cur + offset，但是这个位置可能超出数组的范围，所以要考虑以下几种可能。&lt;&#x2F;li&gt;
&lt;li&gt;如果 next &amp;gt;= 0 同时 next &amp;lt; length 即 next 处于范围内，那么不需要考虑越界的情况，next 即是数字新的位置。&lt;&#x2F;li&gt;
&lt;li&gt;如果 next &amp;lt; 0 ，那么实际上的索引就是 next % (length - 1) + length - 1&lt;&#x2F;li&gt;
&lt;li&gt;如果 next &amp;gt;= lenght 那么索引值就是 next % (length - 1)&lt;&#x2F;li&gt;
&lt;li&gt;确定了待移动数字的目标位置，那么就可以移动了，直接利用 Vec 中 remove 和 insert 的方法即可。&lt;&#x2F;li&gt;
&lt;li&gt;如果仅仅使用 Vec&lt;i64&gt; 来存储数字，那么在移动过程中输入的顺序就被打乱了，移动也无法按照输入顺序进行，所以需要记录移动的顺序。&lt;&#x2F;li&gt;
&lt;li&gt;输入数字是存在重复的，所以利用 Vec 的 position 方法是无法准确找到目标索引的。&lt;&#x2F;li&gt;
&lt;li&gt;在第一部分，我使用 Vec&amp;lt;(i64, bool)&amp;gt; 来存储输入，其中 bool 表示当前数字是否移动，移动数据后修改为 false 。无论移动的数字如何移动，还没有移动的数字他们的相对顺序，和输入一定是相同的，所以可以遍历每一个数字，如果当前数字对应的 bool 值为真，移动当前数字同时当前遍历结束，否则判断下一个数字。如果输入的数字数量为 n ，那么这样的遍历要进行 n 次，所以这个方法的时间复杂度是 O(n^2)，这样就得到了第一部分的解。
&lt;ul&gt;
&lt;li&gt;在计算目标位置时，我为了减少越界的情况，所以提前降低了 offset ，但是却没注意到修改了输入数据，导致后续的移动都产生错误，完全是自己的粗心大意。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;第二个部分，需要对所有的输入进行 10 次移动，很自然的我想使用 Vec&amp;lt;(i64, usize)&amp;gt; 来实现，其中第二个数据表示当前数据被移动几次，在匆匆编写代码之后发现结果错误，和第一部分不同，未移动的数字顺序是和输入一致的，也就是说只有在第一次才有这个特性，而第二次移动时这个特性就完全不存在了，所以记录移动次数是不行的。实际上这个位置只要记录输入的位置即可，同时在一次移动数据的过程中，初始时当前要移动第 1 个数字，遍历所有数字，找到位置为 1 的数字，进行移动。以此类推完成所有数据的移动。第二部分这个方法的时间复杂度是 O(10*n^2)。&lt;&#x2F;li&gt;
&lt;li&gt;这个方法的时间复杂度实际上是 O(n^3) 因为 Vec 插入和删除的操作时间复杂度为 O(n)，这个方法并不好。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;结果的计算，两个部分都需要在数字移动完成后得到的序列中找到值为 0 的数字位置 zero_index，从这个位置之后 1000、 2000 和 3000 的数字值，并累加。因为计算结果并不涉及移动，所以直接通过 (zero_index + offset)%length 计算即可。&lt;&#x2F;li&gt;
&lt;li&gt;不移动插入、删除数组的方法
&lt;ul&gt;
&lt;li&gt;输入存放在一个 Vec&amp;lt;(i32, i32)&amp;gt; 中，其中第一个数据表示数字的值，第二个数据表示当前位置。&lt;&#x2F;li&gt;
&lt;li&gt;每一次按照顺序遍历 Vec ，计算新的位置并更新。&lt;&#x2F;li&gt;
&lt;li&gt;计算结果时依旧是确定 0 的位置，然后计算第后 1000 个数字的位置，再通过 Vec 中的 position 确定数字的值即可。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;这个方法是错误的，因为移动一个数字之后，数组中其他数字记录的位置是错误的，需要更新其他数字的位置&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;li&gt;出乎我的意料的是这个方法的运行时间大概是上面方法的六倍，我猜测可能是因为输入数据的太小导致的。Vec 插入和删除的时间复杂度是 O(n - i)，然后第一个方法中每一次都要进行 n 次移动，每次移动最差的情况内层循环需要执行 n 次，所以最差的时间复杂度的确是 O(n^3) 。而这个方法中，一定需要进行 n 次移动，每次移动需要还需要遍历其他 n - 1 个数据，所以时间复杂度是 O(n^2)。可能不是这个原因？即是我加大数据量结果依旧类似。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-19-qi-ta-fang-fa-de-shi-xian&quot;&gt;Day 19 (其他方法的实现？)&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;按照我的实现程序运行的非常缓慢，今天的题目是我最不喜欢的那种题目，自己的思路没问题，剪枝也不成体系，记忆化也好像是胡乱一通，只能不断的想如何剪枝。最后即使参考了他人的方法，程序依旧不理想，运行时间甚至要慢于一些 python 的实现。
&lt;ul&gt;
&lt;li&gt;剪枝优化可能性？&lt;&#x2F;li&gt;
&lt;li&gt;更好的哈希方法？&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;大致就是直接模拟过程，DFS，&lt;strong&gt;同时利用 HashSet 保存已经访问过的状态，状态由三个部分构成，当前各个机器人的数量，当前各个矿物的数量，以及当前时间&lt;&#x2F;strong&gt;。
&lt;ul&gt;
&lt;li&gt;使用最符合大小的数据类型能够减少程序运行时间，特别是使用巨大的哈希表的时候，如果系统涉及 swap 的使用，那么如果减少了空间也就加快的运行速度。&lt;strong&gt;替换 usize 为 u16 之后，程序的运行时间直接减半。&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;然后利用 DFS 暴力计算结果，但是这样的求解空间巨大，基本上不可能完成计算。&lt;&#x2F;li&gt;
&lt;li&gt;对于任意一个状态（一分钟），最多有四种可能，构造四种机器人的一种，以及等待一分钟。如果时间限制为 t ，那么求解空间大小为 5^t。&lt;&#x2F;li&gt;
&lt;li&gt;为了求解最大的 geode 的数量，那么如果能够制作 geode 机器人，就直接选择这种可能，其他的可能性都不会使得结果最大。求解空间减少到了 4^t。&lt;&#x2F;li&gt;
&lt;li&gt;这个剪枝的方法就让我的程序运行速度稍微可以接受，但是对于第一部分的大量蓝图运行速度依旧缓慢，所以我进一步剪枝。&lt;&#x2F;li&gt;
&lt;li&gt;同样的考虑是否也能在确定能够制作 obsidian 机器人时而不考虑其他的可能呢？并没有理论依据能够支持这样的剪枝，但是我并想不到其他的办法了，所以我就这样做了，再次剪枝后求解空间减少到了 3^t ，这时一个蓝图，模拟 24 分钟的情况，运行时间大概是 15s，而且示例的输入结果也是正确的，所以我就用这个方法计算第一部分的结果，大概花了五分钟，没想到结果是正确的。&lt;&#x2F;li&gt;
&lt;li&gt;同样的我想把这个方法用在第二部分上，需要模拟的时间增加到了 32 分钟，虽然计算一个蓝图所需时间并非小时级别，但是对于示例的两个蓝图输入，这样剪枝得到的结果并不正确，两个蓝图一个正确一个错误。因为第二部分的输入只有三个蓝图，因为使用了记忆化的方法，以及极其复杂的记忆化键，所以对每一个蓝图都会产生巨大的内存占用，所以我将输入分为三个，直接在另一台内存较大的电脑上同时运行。虽然我知道这样的剪枝并不准确，但是最后依旧得到了正确的答案。&lt;&#x2F;li&gt;
&lt;li&gt;虽然得到了正确的答案，但是这个程序的运行依旧是痛苦的，所以还要搞明白有哪些可能的优化。&lt;&#x2F;li&gt;
&lt;li&gt;记录蓝图模拟过程中最大的 geode 数量。然后计算当前状态下，不考虑资源的限制，到时间限制为止每一分钟都制作一个 geode 机器人，最后得到的 geode 数量。如果这个数量不大于目前已经计算到的最大 geode 数量，那么当前状态的后续情况就不必考虑了。 这个剪枝能够极大的提升效率，虽然自己也想到了，但是在计算当前状态下最大的 geode 数量我却算错了。在看了其他人的实现之后，我又重新实现这个方法，最后对于 4^t 的求解空间，两个部分都能在一分钟内完成运行。&lt;&#x2F;li&gt;
&lt;li&gt;因为在任意一分钟，只能制作一个新的机器人。假设 geode 机器人需要 4 个 ore ，5 个 obsidian， 那么如果有 5 个 ore 机器人就会导致浪费（至少对于制作 geode 机器人而言），同样的最多也只需要 5 个 obsidian 机器人就能满足需求。所以可以计算每一个蓝图，在一分钟中，每一种矿物所需要的最大数量，最大数量其实就对应了 ore 、clay 和 obsidian 机器人的最大数量。在计算下一个可能的状态时，可以利用这个条件进一步剪枝。（这个方法的优化不明显，因为往往超出机器人数量限制的时候，依旧是搜索的底层，只能减少少量的可能）。&lt;&#x2F;li&gt;
&lt;li&gt;还可以减少当前状态中的矿物，如果当前状态中的矿物数量已经远超过最大可能需要（每一分钟最多需要矿物*剩余时间），那么可以减少矿物的数量，提高缓存的命中率，但是效果非常不明显，理由类似。&lt;&#x2F;li&gt;
&lt;li&gt;还有其他的优化方法，包括减少记忆化包含的值，提高命中率，后续再学吧。&lt;&#x2F;li&gt;
&lt;li&gt;参考：
&lt;ul&gt;
&lt;li&gt;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;zpihwi&#x2F;comment&#x2F;j0tlukf&lt;&#x2F;li&gt;
&lt;li&gt;随机测试组合机器人序列，测试结果。https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;zpihwi&#x2F;comment&#x2F;j0tjfrt&lt;&#x2F;li&gt;
&lt;li&gt;30ms rust 没有额外内存空间，直接计算构造机器人的类型，求解空间会远小于 4^t https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;zpihwi&#x2F;comment&#x2F;j0tol2k&#x2F;?utm_source=share&amp;amp;utm_medium=web2x&amp;amp;context=3&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-18-dai-bu-chong-bing-cha-ji-shi-xian&quot;&gt;Day 18（待补充并查集实现）&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;今天的题目是一道连通题，只不过当我写完我才意识到这一点。&lt;&#x2F;li&gt;
&lt;li&gt;输入处理很简单，每一行是一个三维的坐标，字符串处理即可。
&lt;ul&gt;
&lt;li&gt;最初我构造了 Cube 抽象化坐标，但是最后发现使用三元组会更加方便。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;第一部分：计算所有方块的非重叠面积，不考虑重叠时，总表面积为方块数乘 6。如果两个方块存在重叠，那么总的表面积减少 2 。&lt;&#x2F;li&gt;
&lt;li&gt;输入的方块是仅有一个坐标，也就是一个点，如果仅仅考虑一个点，其实也就无从考虑重叠，所以在解决的过程中，是将输入作为方块的一个顶点。&lt;&#x2F;li&gt;
&lt;li&gt;可以发现当两个方块的&lt;strong&gt;输入顶点&lt;&#x2F;strong&gt;距离为 1 的时候，两个方块的一个面存在重叠关系，当距离为 0 时两个方块完全重叠，当距离为 2 时两个方块存在一条边重叠，当距离等于 3 时两个方块存在一个顶点重叠，距离大于 3 时方块不存在任何重叠。&lt;&#x2F;li&gt;
&lt;li&gt;第一个部分只需要计算出两个方块存在面重叠的数量即可。令输入方块数量为 n ，那么总共需要判断 C(n, 2) 次，C 为组合函数。&lt;&#x2F;li&gt;
&lt;li&gt;第二部分：需要计算最后物体暴露在外的区域面积，我采取了间接的计算方法。相比于第一部分，第二部分中需要减去的面积是所有由方块围成的空气方块的表面积。&lt;&#x2F;li&gt;
&lt;li&gt;除去组合成的物体，存在两种类型的空气方块
&lt;ul&gt;
&lt;li&gt;和大气构成的空气方块，也就是最后物体之外的空气方块&lt;&#x2F;li&gt;
&lt;li&gt;物体内部的空气方块，这些方块不和大气相连，并构成一个个的空气包&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;物体内部的空气包（由空气方块构成），无论大小如何，构成其的空气方块中一定有与岩浆方块重叠的情况，这就是寻找空气方块的入手条件。&lt;&#x2F;li&gt;
&lt;li&gt;一个方块最多与六个方块存在重叠（距离为 1 ），那么可以首先计算出所有岩浆方块的六个重叠方块坐标，排除岩浆方块就是所有可能的空气方块，其中可能构成空气包，也可能于大气相连。 遍历这些空气方块，进行搜索。&lt;&#x2F;li&gt;
&lt;li&gt;需要构造访问表来记录每一个空气方块的访问情况，构造 HashMap，键为坐标，值为 0 或 1
&lt;ul&gt;
&lt;li&gt;其中 0 表示对应坐标处的空气方块已经被判断，而且该空气方块连通大气。&lt;&#x2F;li&gt;
&lt;li&gt;1 表示对应坐标处的空气方块已经被判断或者正在被判断，不能确定该空气方块是否连通大气。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;搜索逻辑如下，&lt;&#x2F;li&gt;
&lt;li&gt;当前空气方块为 A ，如果 A 在访问表中存在，那么无需判断，直接返回空即可。否则在访问表中置 A 的值为 1 表示正在搜索。&lt;&#x2F;li&gt;
&lt;li&gt;如果当前空气方块可能的六个重叠方块都是岩浆方块，这时就确定了一个空气包，这个空气包由一个空气方块构成，返回空气包大小为 1 ，包含空气方块的坐标。&lt;&#x2F;li&gt;
&lt;li&gt;如果当前空气方块的六个可能重叠方块不都是岩浆，那么需要进一步搜索，判断其中每一个重叠的空气方块：
&lt;ul&gt;
&lt;li&gt;如果该空气方块已经在访问表中出现，而且值为 0 ，也就是说这个空气方块是连接到大气的，那么当前的空气方块也是连接到大气，没有进一步搜索的必要。在访问表中置当前空气方块为 0 ，返回空气包为空。&lt;&#x2F;li&gt;
&lt;li&gt;如果该空气方块并未访问过，那么迭代的进行搜索，得到子空气包，如果子空气包大小为 0， 说明该空气方块是连接大气的，于是空气方块 A 也是连接大气，没有必要继续搜索。在访问表中置空气方块 A 为 0 ，返回空气包为空。&lt;&#x2F;li&gt;
&lt;li&gt;如果所有重叠的空气方块都已完成搜索，但当前空气包大小为 0 ，也就是说当前空气方块连通大气，在访问表中置 A 为 0&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;在计算可能的重叠方块时，计算出的方块可能是与大气相连的，这时这个方块并未被访问，如果不加以控制，可能会无限制的搜索，所以需要增加边界，确定搜索停止的情况。&lt;&#x2F;li&gt;
&lt;li&gt;计算输入岩浆方块的范围，计算每个方向上的最大和最小值，最后得到两个坐标，岩浆方块构成的物体一定是处于由这两个坐标构成的六面体中（两个坐标处于对角线，这个六面体的每一个面和xyz三个面都垂直或平行），所以如果方块不处于这个六面体中，那么这个方块一定与大气相连。判断一个坐标是否处于一个六面体中，只需要计算这个坐标和得到的两个最小坐标和最大坐标的距离和是否与最小坐标和最大坐标之间的距离相同即可。通过这个方法可以规避死循环，同时也避免了大量重复计算。&lt;&#x2F;li&gt;
&lt;li&gt;在得到了构成每一个空气包的所有空气方块坐标后，计算这个空气包的表面积，因为每一个空气包全都有空气方块构成，不存在空洞，所以表面积实际上就是暴露的面积，这个部分的面积正是所需要减去的部分，可以利用第一部分的方法计算。&lt;&#x2F;li&gt;
&lt;li&gt;方法说明：
&lt;ul&gt;
&lt;li&gt;这个方法可以算是 DFS 也可以算是 DP&lt;&#x2F;li&gt;
&lt;li&gt;DFS 就是从可能的空气方块开始搜索，直到完成对这个空气方块所在的空气包搜索或者确认该空气方块连接大气停止。&lt;&#x2F;li&gt;
&lt;li&gt;DP 的实现则是自顶向下的迭代搜索。
&lt;ul&gt;
&lt;li&gt;令 s 为可能的空气方块，s 未被搜索，同时 A(s) 表示所有与 s 存在一个面重叠的空气方块，同时 F(s) 表示 s 所在的空气包大小，转移方程如下：&lt;&#x2F;li&gt;
&lt;li&gt;当 k 属于 A(s) 且 F(k) 都不为空时， F(s) = sum(F(k)) + s,&lt;&#x2F;li&gt;
&lt;li&gt;当 k 属于 A(s) 且存在 F(k) 为空时， F(s) 为空&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;过程中我一直以为自己用的是 DFS 但是看来好像 DP 的解释更加合理，当然这并不重要。完成之后我也意识到其实这也是一道并查集的题目。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;并查集&lt;&#x2F;strong&gt;
&lt;ul&gt;
&lt;li&gt;计算岩浆的边界，得到范围内所有的坐标&lt;&#x2F;li&gt;
&lt;li&gt;如果两个距离为 1 的坐标都为岩浆和空气，则这两个坐标间存在一条边&lt;&#x2F;li&gt;
&lt;li&gt;和边界之外相连的坐标同时为空气，那么这个坐标和大气相连&lt;&#x2F;li&gt;
&lt;li&gt;计算出所有空气包的坐标&lt;&#x2F;li&gt;
&lt;li&gt;最后利用第一部分的方法，计算岩浆的表面积，再计算出每一个空气包（集）的面积，最后相减得到所求面积。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Flood fill 直接求解暴露面积 BFS &#x2F; 自底向上的 DP&lt;&#x2F;strong&gt;
&lt;ul&gt;
&lt;li&gt;从边界最小处开始（0, 0, 0），依旧是判断六个方向上，如果某一方向方向上的方块为岩浆，说明存在一个面与岩浆重叠，面积加一&lt;&#x2F;li&gt;
&lt;li&gt;如果不为岩浆，需要继续搜索，将该方向的坐标加入队列&lt;&#x2F;li&gt;
&lt;li&gt;直到队列为空，搜索完成。&lt;&#x2F;li&gt;
&lt;li&gt;如果使用队列那么就是 BFS ，如果使用栈那么就是 DFS&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;同样要引入访问表确保不会出现死循环&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;因为是直接计算表面积，所以边界需要比岩浆的最大位置再大 1 。&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;li&gt;这个方法运行速度最快，大致上和第一部分一样快，比我自己的方法也要快不少。&lt;&#x2F;li&gt;
&lt;li&gt;参考：https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;zoqhvy&#x2F;comment&#x2F;j0oo08q&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-17-dai-bu-chong&quot;&gt;Day 17(待补充)&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;第一部分直接模拟实现，第二部分数据量巨大，无论采用何种数据结构总是都是不可能急剧减少运行时间，所以猜测是存在规律的，每年都有这样的题目。不出意外的，我依旧没能找到规律，最后只好去 &lt;a href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;znykq2&#x2F;2022_day_17_solutions&#x2F;&quot;&gt;r&#x2F;adventofcode&lt;&#x2F;a&gt; 寻找参考。&lt;&#x2F;li&gt;
&lt;li&gt;如果存在规律，需要确定如下问题：
&lt;ul&gt;
&lt;li&gt;因什么特征而有规律&lt;&#x2F;li&gt;
&lt;li&gt;如何利用规律加快运算&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;第二部分参考：
&lt;ul&gt;
&lt;li&gt;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;znykq2&#x2F;comment&#x2F;j0kc9qp&lt;&#x2F;li&gt;
&lt;li&gt;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;znykq2&#x2F;comment&#x2F;j0kvtwd&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-16-dai-bu-chong&quot;&gt;Day 16(待补充)&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;加权图&lt;&#x2F;li&gt;
&lt;li&gt;阀门的打开顺序有两个决定因素
&lt;ul&gt;
&lt;li&gt;阀门的流速（正比，流速较快的越早打开越好）&lt;&#x2F;li&gt;
&lt;li&gt;当前位置到目标阀门的距离（反比，较近的越早打开越好）&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;第一个阀门流速为 a ，在第 m 分钟打开，总压力为 0&lt;&#x2F;li&gt;
&lt;li&gt;第二个阀门流速为 b ，在第 n 分钟打开，总压力为 (n - m) * a
&lt;ul&gt;
&lt;li&gt;n - m 为第一个和第二个阀门的距离&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;第三个阀门流速为 c , 在第 k 分钟打开，总压力为 (n - m) * a + (k - n) * (a + b)
&lt;ul&gt;
&lt;li&gt;k - n 为第二个和第三个阀门的距离&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;需要计算两个阀门之间的最短距离（时间）
&lt;ul&gt;
&lt;li&gt;我又用 DFS 来寻找最短路了，使用 BFS 之后完成了第一部分&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;第二个部分
&lt;ul&gt;
&lt;li&gt;我和大象同时都打开阀门&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;优化代码永远比等效率差的代码完成执行要节省时间&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-15&quot;&gt;Day 15&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;每一行输入包含一个传感器和其对应的最近的信标的坐标位置&lt;&#x2F;li&gt;
&lt;li&gt;利用 regex 和 lazy_static 通过正则表达式提取坐标&lt;&#x2F;li&gt;
&lt;li&gt;一个传感器存在三个重要的属性
&lt;ol&gt;
&lt;li&gt;传感器的坐标 &lt;code&gt;coord&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;最近信标的坐标 &lt;code&gt;beacon&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;传感器和最近信标的距离 &lt;code&gt;closest_dis&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;根据这三个属性构造 &lt;code&gt;Sensor&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;对于任意一个坐标，如果这个坐标和某一个传感器的距离小于等于传感器记录的最近距离，同时这个坐标也不是这个传感器记录的最近信标，那么这个坐标上一定不可能是信标&lt;&#x2F;li&gt;
&lt;li&gt;依照这个逻辑，可以通过排除法确定某一个坐标上是否是信标&lt;&#x2F;li&gt;
&lt;li&gt;输入的坐标值较大，而且并不需要记录具体的网格信息，所以既不需要使用 Vec 也不需要使用 HashMap&lt;&#x2F;li&gt;
&lt;li&gt;从输入中取的传感器列表，可以计算出地图的最大范围。x 坐标的最小值是所有传感器 x 轴坐标加上传感器和最近信标距离中的最小值，min{coord.x + closest_dis} 。可以确定 x 和 y 轴的范围。&lt;&#x2F;li&gt;
&lt;li&gt;第一个部分限定了网格区域，只考虑某一个 y 轴坐标，也就是一条线上的所有坐标。遍历这条线上所有的坐标，如果该坐标在任意的传感器计算中判断不可能是信标，那么该坐标满足条件，保留。最后对不可能是信标的坐标进行计数。这个部分的运行时间就达到了 2s ，可以说是非常慢的解法了。&lt;&#x2F;li&gt;
&lt;li&gt;第二个部分需要寻找一个没有被任何传感器检测到的信标，这个信标和所有传感器的距离都大于传感器的最近信标距离。信标的坐标在 (0, 0) 到 (4000000, 4000000) 的区域中。对于任意坐标，如果该坐标对于所有的传感器都有可能是信标，那么这个坐标就是要求的信标位置。&lt;&#x2F;li&gt;
&lt;li&gt;如果依旧同第一部分一样使用排除法，那么需要遍历 4000000^2 个坐标，用第一个部分的时间估算，&lt;strong&gt;大概需要 5000 个小时才能排除所有的坐标。&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;li&gt;考虑坐标 (x,y) 和传感器 S，其中传感器坐标为 (a, b)，最近距离为 r 。令该坐标和传感器 S 的距离小于 r ，也就是说该坐标不可能是信标。传感器 S 划定了一个区域，这个区域中任何坐标到传感器的距离都不大于 r ，在网格上看起来就像是一个菱形（旋转 45 度的正方形）。即此时 (x, y) 落在这个菱形中，假设在当前行中遍历是从左到右的（x增加，y不变）。可以发现这个菱形和遍历过程中所有坐标相较与一个线段，这个线段上所有的坐标都处于菱形中，当然 (x, y) 也落在这个线段中，线段上的所有坐标都不需要再计算。设线段右端点坐标为 (x1, y)，那么就有：
&lt;ul&gt;
&lt;li&gt;|x1 - a| + |y - b| = r&lt;&#x2F;li&gt;
&lt;li&gt;|x1 - a| = r - |y - b|&lt;&#x2F;li&gt;
&lt;li&gt;x1 = r - |y - b| + a 或&lt;&#x2F;li&gt;
&lt;li&gt;x1 = -r + |y - b| + a&lt;&#x2F;li&gt;
&lt;li&gt;两者取较大作为结果&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;即 x1 = max{r - |y - b| + a, -r + |y - b| + a}&lt;&#x2F;li&gt;
&lt;li&gt;通过这个方式，暴力的方法中每一次 x 的值只能增加一，但是经过这个优化，可以将 x 的值更新为 x1 + 1。在每一个 y 值的遍历（同一行）中，实际上只需要判断少量的坐标即可。&lt;&#x2F;li&gt;
&lt;li&gt;不能再通过这个方式加快 y 轴的遍历，因为这个方法实际上只确定了某一行上所有的坐标是否满足条件，并不能对 y 进行跳跃，所以 y 轴依旧只能一行一行的遍历。&lt;&#x2F;li&gt;
&lt;li&gt;在使用这个优化后运行时间在 5s 左右，也就是在每一行的遍历中，的确只计算了少数的坐标。&lt;&#x2F;li&gt;
&lt;li&gt;我发现按照传感器检测范围的最小值对传感器进行排序，也可以加速程序的运行，第二个部分的运行时间缩短到 3.5s 左右。在计算坐标是否落入传感器检测范围时，如果刚开始计算的传感器是距离较近的，那么就更有可能找到满足条件的传感器，也就能减少所需计算传感器的数量。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;interval&quot;&gt;Interval&lt;&#x2F;h3&gt;
&lt;p&gt;参考链接：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;zmcn64&#x2F;comment&#x2F;j0anz77&quot;&gt;Reddit&#x2F;EVQLVE&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;思路：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;一个传感器由多个区间组成，对于给定的 y 值，可以确定传感器在这个线上的区间。&lt;&#x2F;li&gt;
&lt;li&gt;第一个部分计算出所有传感器在 y = 20 上的所有区间，合并区间，最终得到不重叠的区间列表，长度即是结果。&lt;&#x2F;li&gt;
&lt;li&gt;第二个部分对每一个 y 值都进行区间列表计算，如果得到的区间列表为长度为 2 此时即找到所求坐标，两个区间列表之中的坐标即是结果。&lt;&#x2F;li&gt;
&lt;li&gt;第二个部分中，题目保证在所求范围内仅有一个结果，即除了结果处，其余 y 值上合并区间后仅有一个区间，可以记录每一次合并区间时重叠区域的大小来对 y 值进行跳过。合并区间列表时，如果两个区间的重叠区域大小为 L ，因为传感器的检测范围是一个菱形（旋转的正方形），L 可以看作是一个小正方形的对角线，L &#x2F; 2 即是从当前 y 开始，向下所有的部分都会重叠，后续可以不再判断。在合并过程中计算每一个重叠区域大小 L 的最小值，得到的结果的一半即是所有重叠区域在 y 轴方向上的小区间。于是原本需要每次对 y 加一，加速为 y + min{L &#x2F; 2 + 1}，进一步加快程序运行。&lt;&#x2F;li&gt;
&lt;li&gt;这个方法运行时间：
&lt;ul&gt;
&lt;li&gt;Part1（Debug）为 45.542µs&lt;&#x2F;li&gt;
&lt;li&gt;Part2 (Debug) 为 1.35s&lt;&#x2F;li&gt;
&lt;li&gt;Part1（Release）为 5.75µs&lt;&#x2F;li&gt;
&lt;li&gt;Part2 (Release) 为 82.974166ms&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;liang-ge-fang-fa-dui-bi&quot;&gt;两个方法对比&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;可以发现在第一个部分的运行时上新的方法提速明显，这很好理解，但第二个部分上区间法的优化就不明显了，这是因为区间法实际上是我自己实现的一种优化，当然区间法也更好理解。&lt;&#x2F;li&gt;
&lt;li&gt;自己的方法中，对坐标 (x, y)，实际上计算了某一传感器的区间的右边界，然后再在这个基础上计算下一个传感器的区间右边界，可以理解成是在计算的过程中合并了区间，而不是像第二个方法中直接计算所有的区间。其实我应该在发现对传感器进行排序能优化程序运行速度的时候就想到区间法的，比较在 interval 的算法题里，对区间列表进行排序总是必要的。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-14&quot;&gt;Day 14&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;今天的题目并不复杂，细节的处理上也不存在模糊的情况。&lt;&#x2F;li&gt;
&lt;li&gt;输入的处理较容易，每一行都是岩石的路径，提取坐标即可。&lt;&#x2F;li&gt;
&lt;li&gt;抽象化
&lt;ul&gt;
&lt;li&gt;构造类型 &lt;code&gt;Coord&lt;&#x2F;code&gt; 表示坐标&lt;&#x2F;li&gt;
&lt;li&gt;构造枚举类型 &lt;code&gt;Material&lt;&#x2F;code&gt; 表示坐标处的物质，包含 &lt;code&gt;Rock&lt;&#x2F;code&gt;, &lt;code&gt;Air&lt;&#x2F;code&gt; 和 &lt;code&gt;Sand&lt;&#x2F;code&gt; 三种&lt;&#x2F;li&gt;
&lt;li&gt;构造类型 &lt;code&gt;Cave&lt;&#x2F;code&gt; 表示洞穴
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;grid: HashMap&amp;lt;Coord, Material&amp;gt;&lt;&#x2F;code&gt; 存储坐标对应的物质情况&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;range_x: (usize, usize)&lt;&#x2F;code&gt; x 轴的范围&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;range_y: (usize, usize)&lt;&#x2F;code&gt; y 轴的范围&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;sand_src: Coord&lt;&#x2F;code&gt; 沙子的源头&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;floor: usize&lt;&#x2F;code&gt; 第二个部分的地板界限（暂时不考虑）&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;沙子坠落逻辑
&lt;ul&gt;
&lt;li&gt;每一个单位的沙子都从源头开始 (500, 0)，考虑某一时刻沙子位置为 (x, y)&lt;&#x2F;li&gt;
&lt;li&gt;首先沙子会向下掉 (x, y + 1)，如果目标位置为 Air 那么沙子能够直接掉落，否则&lt;&#x2F;li&gt;
&lt;li&gt;沙子考虑左侧对角线位置 (x - 1, y + 1)， 如果沙子同样不能安放，在考虑&lt;&#x2F;li&gt;
&lt;li&gt;右侧下方对角线位置 (x + 1, y + 1)，如果沙子同样不能安放，那么&lt;&#x2F;li&gt;
&lt;li&gt;目前位置 (x, y) 即是目前这个单元的沙子最终位置。修改 grid 中对应位置的材料为 Sand 。坠落的沙子单元数加 1 ，重新冲沙子源头掉落一个新的单元&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;当沙子掉出石头所能容纳的最大范围的时候，在第一个部分这些沙子会坠入深渊，那么一个单元的沙子会无限的坠落，第一部分就是需要计算当第一个单元的沙子开始坠入深渊时，总共有多少沙子已经坠落而且安放完毕。只需要在沙子的坠落过程中判断当前沙子的位置是否处于深渊（超过输入中所有坐标的边界），如果处于深渊则停止循环，返回计数结果。&lt;&#x2F;li&gt;
&lt;li&gt;实际上洞穴下方不一定都是深渊，特别是站在洞穴里网上看，所以第二个部分的洞穴存在地板的限制，地板的高度（y轴坐标）是输入坐标中所有最大 y 轴坐标加二。第二个部分沙子停止坠落的情况，也就是当从源头掉出的沙子已经没有任何地方可以去了，这时沙子停止坠落。那么需要沙子坠落的过程中，记录沙子从源头中掉出后，是否有移动到新的位置，如果没有则停止循环，返回计数结果。&lt;&#x2F;li&gt;
&lt;li&gt;逻辑和实现都不难，最后也得到了正确的结果，但是我不满意的地方在于运行的速度较慢，第二个部分的运行时间达到了 1.5s ，可以说是很慢了。利用 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;flamegraph-rs&#x2F;flamegraph&quot;&gt;[cargo-]flamegraph&lt;&#x2F;a&gt;，可以发现运行时间中一个判断位置是否能够安放沙子的函数占用了大量的时间，准确的来说是在对 grid 也就是 HashMap 进行取值的过程耗费了大量的时间。理论上从 HashMap 中取值的时间复杂度是 O(1) ，细看火焰图的时候还可以发现有一半的时间也在计算哈希。为了减少这个部分的时间，可以考虑使用数组替代 HashMap。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;使用 Vec 替换 HashMap&lt;&#x2F;strong&gt;：如果要使用 Vec 就需要确定洞穴的最大边界，以及沙子可能掉落的边界，可以直接使用第二部分的地板 floor 设定，因为地板是最大的 y轴坐标，也就是说确定了一个最大高度，考虑没有石头的情况，当沙子从 floor 堆叠到沙子的源头时，沙堆的形状是一个三角形，宽度的一半刚好是高度（总是对角线移动），根据这一点以及所有输入坐标中的最大和最小 x坐标，就能确定 Vec 的范围。
&lt;ul&gt;
&lt;li&gt;首先对输入的所有坐标查找 y 坐标最大值 max_y ，查找 x 坐标的最大值 max_x 和最小值 min_x&lt;&#x2F;li&gt;
&lt;li&gt;边界值都扩大 2 ，保证第二个部分地板的设定
&lt;ul&gt;
&lt;li&gt;max_y += 2;&lt;&#x2F;li&gt;
&lt;li&gt;min_x -= 2;&lt;&#x2F;li&gt;
&lt;li&gt;max_x += 2;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;计算左边界和沙子左侧最远位置的最小 &lt;code&gt;min_x.min(500 - max_y)&lt;&#x2F;code&gt; 作为最终 x 的最小值&lt;&#x2F;li&gt;
&lt;li&gt;计算右边界和沙子右侧最远位置的最大 &lt;code&gt;max_x.max(500 + max_y)&lt;&#x2F;code&gt; 作为最终 x 的最大值&lt;&#x2F;li&gt;
&lt;li&gt;所以 &lt;code&gt;grid&lt;&#x2F;code&gt; 的大小就是 &lt;code&gt;max_y + 1 * (max_x - min_x + 1)&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;注意后续在进行 &lt;code&gt;grid&lt;&#x2F;code&gt; 查找的时候，需要通过 &lt;code&gt;x - min_x&lt;&#x2F;code&gt; 来确定最终的索引值。&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;li&gt;**这个优化的结果还是比较明显的，两个部分都将运行时间降低到了原有的五分之一。**火焰图显示目前程序运行的时间主要在数组的索引操作上。&lt;&#x2F;li&gt;
&lt;li&gt;进一步的优化，可以发现在沙子垂直掉落的过程中，存在大量重复运算，也就是在 x = 500 的区域上，可以动态更新可能可以放置沙子的 y 值，这样就能免去大量的向下掉落的操作。不确定这个优化能够带来多少的收益，很可能增加了程序的复杂度但效率提升并不明显。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;**可能的数学方法？**也许可以通过计算直接取的空洞区域的大小，这是一个思路，我不够聪明也没有耐心理清这个思路，也没有看见其他人有的实现，所以暂时就这样。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-13&quot;&gt;Day 13&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;初看题目并不复杂，但我在细节的处理上耗费大量时间，没有正确的理解题意导致一直无法得出正确答案。&lt;&#x2F;li&gt;
&lt;li&gt;抽象化
&lt;ul&gt;
&lt;li&gt;每一行输入都是一个数据包，每一个数据包都可以由列表和数字构成，同时列表中又可以由列表和数字构成&lt;&#x2F;li&gt;
&lt;li&gt;构造枚举类型 Packet&lt;&#x2F;li&gt;
&lt;li&gt;包含 &lt;code&gt;List(Vec&amp;lt;Packet&amp;gt;)&lt;&#x2F;code&gt; 和 &lt;code&gt;Integer(Num)&lt;&#x2F;code&gt; ，对应列表和数字&lt;&#x2F;li&gt;
&lt;li&gt;其中 &lt;code&gt;Num&lt;&#x2F;code&gt; 为 &lt;code&gt;i32&lt;&#x2F;code&gt; 的别名&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;输入的处理也不简单，大致上是同检测括号是否正确的思路一致，使用栈完成
&lt;ul&gt;
&lt;li&gt;对输入按行划分，保留非空行，一行是一个数据包。&lt;&#x2F;li&gt;
&lt;li&gt;将每一行的字符串转为字符数组，直接使用字符数组作为处理栈。&lt;&#x2F;li&gt;
&lt;li&gt;新建结果栈 &lt;code&gt;stack: Vec&amp;lt;Option&amp;lt;Packet&amp;gt;&amp;gt;&lt;&#x2F;code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;None&lt;&#x2F;code&gt; 存在一个列表仍未被构建完成，否则这个列表已经构建完成&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;每次从处理栈顶弹出字符（字符串从右到左）&lt;&#x2F;li&gt;
&lt;li&gt;如果字符为 &#x27;]&#x27; ，表示一个列表结尾，但是因为是从右到左处理，所以是列表的开始，向 stack 中压入 None&lt;&#x2F;li&gt;
&lt;li&gt;如果字符为 &#x27;[&#x27; ，表示从右到左的过程中，一个列表输入已经完成，那么循环弹出 stacks 栈顶，直到栈顶元素为 None ，那么弹出的 Packet 都是属于外层 Packet 的，构建新的 Packet 后再将结果压入 stack&lt;&#x2F;li&gt;
&lt;li&gt;如果弹出字符为数字，那么表示遇到了 &lt;code&gt;Integer(Num)&lt;&#x2F;code&gt; ，因为纯数字的长度不为 1 ，所以需要反复的从字符栈顶端再弹出字符，直到栈顶不为数字。因为是从左到右的，所有得到的数字字符列表是逆序的，需要将列表逆序后再转为数字构造 Packet ，再将结果压入 stack。&lt;&#x2F;li&gt;
&lt;li&gt;如果字符为 &#x27;,&#x27; 跳过当前字符。&lt;&#x2F;li&gt;
&lt;li&gt;理论上不会遇到其他的字符，可以使用 &lt;code&gt;unreachable!()&lt;&#x2F;code&gt; 保证不会又问题&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;对输入进行处理后得到 &lt;code&gt;Vec&amp;lt;Packet&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;第一个部分需要两个两个的划分所有数据包，然后比较两个数据包的顺序，所以需要完成数据包比较的逻辑。&lt;&#x2F;li&gt;
&lt;li&gt;比较逻辑，令两个数据包为 left 和 right
&lt;ul&gt;
&lt;li&gt;如果 left 和 right 都为数字，那么当 left 的数值小于 right 的数值时，两个数据包处于正确的顺序，即 left 小于 right&lt;&#x2F;li&gt;
&lt;li&gt;如果 left 和 right 都为列表，那么依次比较两个列表内的数据包，在依次比较过程中
&lt;ul&gt;
&lt;li&gt;如果 left 中存在数据包小于 right 中对应位置的数据包，那么 left 小于 right ，&lt;strong&gt;注意在这里只要有一个这样的情况即可，不再需要进行后续比较，我正是错过了这个细节所以浪费了很多的时间&lt;&#x2F;strong&gt;，两个数据包处于正确的顺序。&lt;&#x2F;li&gt;
&lt;li&gt;同样的如果 left 中存在数据包大于 right 中对应位置的数据包，那么 left 大于 right ，两个数据包处于错误的顺序，直接返回比较结果。&lt;&#x2F;li&gt;
&lt;li&gt;如果依次比较过程中 left 和 right 数据包大小都一样（数字一样大），同时 right 的长度大于 left 的长度，那么视作 left 小于 right ，如果长度相同则 left 等于 right ，如果 right 长度小于 left ，那么 left 大于 right。&lt;strong&gt;因为数据包存在嵌套的情况，这时的比较结果会影响外层数据包的比较，所以要严格的传递数据包的比较结果。&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;如果 left 和 right 之中存在一个数字和一个列表，那么需要将数字专为包含数字的列表之后再进行比较&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;数据包的大小关系存在三种，大于、小于和等于，但是数据包顺序的正确性只有两种。&lt;&#x2F;li&gt;
&lt;li&gt;顺序正确性和数据包大小的对应关系
&lt;ul&gt;
&lt;li&gt;正确： left &amp;lt; right&lt;&#x2F;li&gt;
&lt;li&gt;错误： left &amp;gt; right&lt;&#x2F;li&gt;
&lt;li&gt;不确定： left == right&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;好在题目的输入中并不存在数据包一致的情况，只需要保证在比较数据包的过程中，确保三种大小关系一致即可。&lt;&#x2F;li&gt;
&lt;li&gt;两个部分在严格的实现了比较逻辑后就能够很简单的取得结果。&lt;&#x2F;li&gt;
&lt;li&gt;第二部分可以先对输入的所有数据包进行排序，然后在二分查找需要插入的新数据包位置，要插入两个数据包，确定第一个数据包的插入位置时注意要将插入数据包放入数组，然后再查找第二个数据包，确保准确。&lt;&#x2F;li&gt;
&lt;li&gt;可以对 &lt;code&gt;Packet&lt;&#x2F;code&gt; 实现 &lt;code&gt;std::cmp::Ord&lt;&#x2F;code&gt; 来快速使用 &lt;code&gt;sort&lt;&#x2F;code&gt; 和 &lt;code&gt;binary_search&lt;&#x2F;code&gt; ，当然也可以实现 &lt;code&gt;Packet::cmp&lt;&#x2F;code&gt; 而不实现 &lt;code&gt;trait&lt;&#x2F;code&gt; ，然后使用 &lt;code&gt;sort_by&lt;&#x2F;code&gt; 和 &lt;code&gt;binary_search_by&lt;&#x2F;code&gt; 来快速实现第二部分的排序和二分查找。
&lt;ul&gt;
&lt;li&gt;实现 &lt;code&gt;Ord&lt;&#x2F;code&gt; 需要实现 &lt;code&gt;PartialOrd&lt;&#x2F;code&gt; 、 &lt;code&gt;PartialEq&lt;&#x2F;code&gt; 和 &lt;code&gt;Eq&lt;&#x2F;code&gt; ，在这个题目中 &lt;code&gt;PartialOrd&lt;&#x2F;code&gt; 是需要实现的，实际上调用 &lt;code&gt;Ord&lt;&#x2F;code&gt; 即可，而 &lt;code&gt;PartialEq&lt;&#x2F;code&gt; 和 &lt;code&gt;Eq&lt;&#x2F;code&gt; 则可以通过 &lt;code&gt;#[derive( PartialEq, Eq)]&lt;&#x2F;code&gt; 快速实现&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-12&quot;&gt;Day 12&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;题意并不复杂，阅读题目的过程中要注意细节&lt;&#x2F;li&gt;
&lt;li&gt;输入是由字母构成的网格，网格中由小姐字母代表地势高低，a 最低， z 最高，额外的 S 表示起点，E 表示终点。&lt;&#x2F;li&gt;
&lt;li&gt;从 S 出发，要抵达 E ，每次只能在上下左右四个方向中选择一个移动到下一个网格。同时只有当前网格的高度大于下一个网格高度，或者当前网格高度仅比下一个网格高度低一个级别才允许移动。例如 a -&amp;gt; b 是允许的，f -&amp;gt; a 也是允许的，但是 a -&amp;gt; z 就是不允许的。&lt;&#x2F;li&gt;
&lt;li&gt;同时 S 的高度等同于 a ，而 E 的高度等同于 z 。&lt;&#x2F;li&gt;
&lt;li&gt;要求从 S 到 E 的最短路径，最短路径可以使用 BFS 。上一次写 BFS 的题目已经过去接近两个月了，所以有些生疏，对最短路径的套路也没有很明白，刚开始还尝试用 DFS ，但是对于最短路径而言，广度优先搜索应该是最方便的了。&lt;&#x2F;li&gt;
&lt;li&gt;广度优先搜索 BFS
&lt;ul&gt;
&lt;li&gt;利用 VecDeque 构造队列 queue&lt;&#x2F;li&gt;
&lt;li&gt;初始时队列中仅有初始 S 的位置&lt;&#x2F;li&gt;
&lt;li&gt;每一次从队头取出一个元素，表示当前位置，判断当前位置的上下左右四个位置是否满足移动条件，如果满足则入队&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;避免死循环&lt;&#x2F;strong&gt;，因为是可以上下左右四个方向移动，所以很可能会导致元素的重复入队。考虑一个位置 A ，如果 A 已经在队列中出现过，因为是深度优先，所以如果后续再将 A 入队，这个时候 A
所在的路径长度一定长于最早出现 A 时的路径长度（存在环路，无意义的增加了路径长度）。引入 visited 数组，记录位置的访问情况。如果出队的位置已经在访问过，那么就不必要考虑这个位置的后续可能，如果没有访问过，这时需要在 visited 中记录当前位置已经访问过，确保后续不会再次搜索。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;这是最简单的搜素方式，但是这样只能确定是否有路径。因为是广度优先，所以如果遇到了终点，那么这时的路径就是最短的，同时路径长度就是长度优先搜索的深度。&lt;&#x2F;li&gt;
&lt;li&gt;记录深度的 BFS
&lt;ul&gt;
&lt;li&gt;当队列不为空时&lt;&#x2F;li&gt;
&lt;li&gt;记录队列的长度为 count ，这个长度是当前深度的大小&lt;&#x2F;li&gt;
&lt;li&gt;循环 count 次从队首取出位置，对每一个位置根据上述逻辑继续构造队列。（清空一层）&lt;&#x2F;li&gt;
&lt;li&gt;深度加一&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;当搜索中发现位置即是终点，这时直接返回深度，不需要进一步搜索。&lt;&#x2F;li&gt;
&lt;li&gt;刚开始自己的实现其实并没有问题，但是结果却不对，所以我怀疑是自己的 BFS 写错了，刚好中途有事出门，期间一直在想，但是我的实现是没有问题的。回到家后，观察了实际的输入文件，才发现实际输入中 S 的位置并不同示例中是从左上角（0，0）开始的，S 可能是在任意位置的。所以需要自己搜索初始位置。调整了这个细节后就完美解决了第一个部分。&lt;&#x2F;li&gt;
&lt;li&gt;第二个部分是第一个部分的简单变体，初始位置并不只有 S ，也可以从高度为 a 的位置开始。最为直接的方法就是找到所有可能的初始位置，对每一个初始位置都进行一次广度优先搜索。在计算所有最短路中的最短路。这个方法要注意很可能有的起点是不可能到达 E 的，要处理到达不了的情况。&lt;&#x2F;li&gt;
&lt;li&gt;但是可以逆向考虑第二个部分，终点 E 依旧不变，只不过有多个可能的起点。那么可以考虑从 E 开始，找到终点为 S 或 a 的最短路径。也就是调整 BFS 中的搜索终结条件即可。这个方法不需要进行多次的 BFS 搜索，也能保证一定能够找到可能的最短路径而不需要额外考虑。&lt;&#x2F;li&gt;
&lt;li&gt;https:&#x2F;&#x2F;github.com&#x2F;TheAlgorithms&#x2F;Rust&#x2F;blob&#x2F;master&#x2F;src&#x2F;graph&#x2F;dijkstra.rs&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-11&quot;&gt;Day 11&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;这道题目的题意有些复杂，不仔细阅读就会出错。输入依旧简单，根据输入构造 Monkey
&lt;ul&gt;
&lt;li&gt;我最初使用了基本的字符串提取方法，但是在个输入上，使用正则表达式是更加容易的方法。&lt;&#x2F;li&gt;
&lt;li&gt;Reddit 讨论区推荐的有 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kevinmehall&#x2F;rust-peg&quot;&gt;peg&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;pest.rs&#x2F;&quot;&gt;pest&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;nom&#x2F;latest&#x2F;nom&#x2F;&quot;&gt;nom&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;每一个猴子有两个复杂的动作，检查一个物品时会影响物品对应对担心值（修改），同时又根据新的担心值而决定将物品传递给下一个猴子&lt;&#x2F;li&gt;
&lt;li&gt;每个猴子都有不同的修改担心值的方法，由三个部分组成，两个操作数，一个操作符。操作数可以是物品的原有担心值（old）或者是一个常数，操作符可以是乘号或者加号，对应乘法和加法。对两个操作数执行相应操作取得新的结果。&lt;&#x2F;li&gt;
&lt;li&gt;传递目标由担心值是否能被一个常数整除而决定，如果能整除则传递给某一个猴子，不能则传递给了一个猴子。每一个猴子都有不同的整除常数，和两个不同的目标猴子。&lt;&#x2F;li&gt;
&lt;li&gt;第一个部分中，每一次计算出新的担心值时对担心值除以三，这样可以保证担心值不会越界。&lt;&#x2F;li&gt;
&lt;li&gt;但是在第二个部分中，担心值是不能除以三的，而且轮次达到了 10000 轮，所以一定会有越界的情况，需要判断题意自行降低担心值。&lt;&#x2F;li&gt;
&lt;li&gt;因为传递是由每个猴子的整除常数确定的，所以要保证降低担心值的过程中不影响整除情况。&lt;&#x2F;li&gt;
&lt;li&gt;传递的目标是完全由担心值和整除常数决定的，考虑整除常数 17 ，对于担心值 30 和 13 而言，下一个猴子的位置都是一致的。所以对于某一个猴子而言，可以将担心值降低到担心值对整除常数的余数，而不影响这个物品在这个猴子上的传递目标。&lt;&#x2F;li&gt;
&lt;li&gt;能否直接取当前值对当前猴子整除常数的余数作为新的担心值？这是不正确的，考虑当前值为 34 ，整除常数为 17 ，那么余数就是 0 ，假设下一个猴子的操作为 old + 2 整除常数为 18。因为 34 % 17 == 0 而且更新担心值为 0 ，那么等到下一个猴子检查时，担心值被更新为 2 ，被 18 整除不为 0 。但是如果依旧是 34 ，担心值更新为 36 ，能够被 18 整除。可见直接取余数的方法是不正确的，物品传到了错误的猴子手上。&lt;&#x2F;li&gt;
&lt;li&gt;可见在降低担心值时不能仅仅考虑当前猴子的情况，也要考虑其他可能有关联的猴子，因为猴子之间的传递链条复杂，大概率每一个物品都会出现在所有猴子手中，所以&lt;strong&gt;在降低担心值时要考虑到所有猴子的情况&lt;&#x2F;strong&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;考虑两个整除常数 2 和 3，对于担心值 8 而言，如果要担心值降低后不影响被这两个常数整除的结果，那么应该需要取 8 对 2 和 3 两个数的最小公倍数的余数，也就是 8 % lcm(2, 3) ，即 8 % 6。&lt;&#x2F;li&gt;
&lt;li&gt;根据这个思路，在更新物品担心值时，对担心值取所有猴子整除常数的最小公倍数即可。这样就能够保证即使使用了 u64 的情况下也不会出现越界的情况。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;注意可以不使用最小公倍数（可以直接累积），只不过最小公倍数能更有效的降低担心值，同时在我的输入文件中，所有猴子的整除常数都是素数，所以最后使用的值就是所有整除常数的累积，可能是这个输入文件凑巧导致。&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;li&gt;因为第二个部分的循环次数较多达到了 10000 次，所以在不引入这个优化时，即使使用 u128 或者更长的数据类型也有会导致溢出。但是即使在使用这个方法后，依旧需要使用 u64 才能保证不会有溢出。&lt;&#x2F;li&gt;
&lt;li&gt;需要注意一个情况，在使用 --release 编译时，即使使用 u32 数据类型也不会产生溢出错误，但是计算结果是错误的，无论是否使用上述方法。也就是说在编译优化的过程中，编译器消除了溢出的问题，但是却导致了计算结果的错误。&lt;strong&gt;这个问题不确定是编译器的 feature 还是 bug ？&lt;&#x2F;strong&gt; 好像是个 feature ？
&lt;ul&gt;
&lt;li&gt;https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;71196238&#x2F;why-does-repeated-multiplication-panic-due-to-overflow-in-debug-mode-when-it-ou&lt;&#x2F;li&gt;
&lt;li&gt;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch03-02-data-types.html#integer-overflow&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;blockquote&gt;
&lt;p&gt;When you’re compiling in release mode with the --release flag, Rust does not include checks for integer overflow that cause panics. Instead, if overflow occurs, Rust performs two’s complement wrapping. In short, values greater than the maximum value the type can hold “wrap around” to the minimum of the values the type can hold. In the case of a u8, the value 256 becomes 0, the value 257 becomes 1, and so on. The program won’t panic, but the variable will have a value that probably isn’t what you were expecting it to have. Relying on integer overflow’s wrapping behavior is considered an error.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-10&quot;&gt;Day 10&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;每年都有的指令题来了，输入的处理依旧简单&lt;&#x2F;li&gt;
&lt;li&gt;这个 CPU 很简单，只有一个寄存器和两条指令&lt;&#x2F;li&gt;
&lt;li&gt;指令 noop 什么也不做，需要一个周期&lt;&#x2F;li&gt;
&lt;li&gt;指令 addx a 寄存器自增 a ，需要两个周期&lt;&#x2F;li&gt;
&lt;li&gt;寄存器的值只有在指令完全执行完成后才会更新&lt;&#x2F;li&gt;
&lt;li&gt;构造 CPU ，包含寄存器 register ，程序 program ，程序计数器 pc&lt;&#x2F;li&gt;
&lt;li&gt;仅有一个寄存器，所以 register 类型为 i32&lt;&#x2F;li&gt;
&lt;li&gt;program 为指令列表&lt;&#x2F;li&gt;
&lt;li&gt;pc 为指令指针，当前执行指令位置&lt;&#x2F;li&gt;
&lt;li&gt;当前指令为 noop 时，pc 加一即可&lt;&#x2F;li&gt;
&lt;li&gt;当前指令为 addx 时，因为这个指令需要两个周期，所以在第一次 addx 时，不对 register 进行修改，下一个周期再对 register 修改，然后 pc 加一&lt;&#x2F;li&gt;
&lt;li&gt;所以 CPU 中需要另外的计数器 cycle ，用于记录当前指令的执行周期数。因为只存在一个指令需要两周期，所以可以使用 bool 类型进行计数器。初始为 false ，表示不需要额外周期执行当前指令，只有当 pc 指向 addx 时，cycle 置为 true ，表示需要额外的一个周期。在下一个周期中，pc 虽然依旧指向 addx ，但是因为 cycle 为 true ，表示指令需要的额外周期已经完成，这时可以对 register 修改，同时 pc 指向下一条指令。&lt;&#x2F;li&gt;
&lt;li&gt;在指令寻址的部分，程序可能是循环执行的，即当程序运行结束时，pc 需要从头开始。在这个题目中其实不涉及这个问题，因为程序运行周期为 240 ，刚刚好在两个部分问题的范围内。按照往年题目，后续肯定有类似的扩展题，后续可能要考虑这一点。&lt;&#x2F;li&gt;
&lt;li&gt;第一部分需要计算 CPU 在某一个执行周期中寄存器的值。根据上述的 CPU 实现，只要按照周期运行即可，在特定周期时记录寄存器值计算信号强度。因为要求计算的是执行周期中寄存器的值，这时指令还没完成执行，寄存器的值没有更新，是和周期前寄存器值一致的。而且当前的实现，一个周期是不存在执行中的情况的，所以直接用当前周期执行前寄存器的值。&lt;&#x2F;li&gt;
&lt;li&gt;第二部分看似复杂，需要绘制像素。绘制一个像素的过程分为两个部分：
&lt;ul&gt;
&lt;li&gt;首先是 &lt;code&gt;sprite&lt;&#x2F;code&gt; ，可以视作画笔，宽度为 3
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sprite&lt;&#x2F;code&gt; 的中间位置是寄存器的值，这个值是可能小于 1 的，所以画笔有作用的实际宽度会小于 3&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;然后是屏幕的部分，每一个计算周期中，只会更新一个像素，可以视作画布&lt;&#x2F;li&gt;
&lt;li&gt;只有当画笔落在了画布上，像素才会被点亮&lt;&#x2F;li&gt;
&lt;li&gt;令屏幕为 &lt;code&gt;screen: [[false; 40]; 6]&lt;&#x2F;code&gt; 初始时所有像素都没有点亮为 &lt;code&gt;false&lt;&#x2F;code&gt; ，屏幕宽度为 40 高度为 6&lt;&#x2F;li&gt;
&lt;li&gt;屏幕的绘制方式是从左到右，从上到下，最初绘制的像素是 (0, 0) ，最后绘制的像素是 (5, 39)&lt;&#x2F;li&gt;
&lt;li&gt;令当前绘制行 &lt;code&gt;cur_row&lt;&#x2F;code&gt; ，当前行中的位置 &lt;code&gt;cur_pos&lt;&#x2F;code&gt; 那么当前绘制的像素就是 &lt;code&gt;screen[cur_row][cur_pow]&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;那么只有当绘制像素落在 &lt;code&gt;sprite&lt;&#x2F;code&gt; 的范围内，像素才会被点亮，否则不变
&lt;ul&gt;
&lt;li&gt;可以计算 &lt;code&gt;cur_pos&lt;&#x2F;code&gt; 和 &lt;code&gt;sprite&lt;&#x2F;code&gt; 中间位置的距离，如果距离小于 2 ，那么绘制像素落在 &lt;code&gt;sprite&lt;&#x2F;code&gt; 中&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;当绘制的位置超出了行的边界，表示需要绘制下一行&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;因为绘制也是在一个执行周期中完成的，所以绘制是发生在周期完成前，需要先绘制，在执行周期&lt;&#x2F;li&gt;
&lt;li&gt;执行完所有的周期，第二个部分也就是 240 个周期，执行再多的周期也不会对屏幕有影响。这时得到的 screen 就是像素的明暗情况，根据对应位置值，绘制 &#x27;#&#x27; 和 &#x27;.&#x27; ，打印结果即可取得答案。我还记得写 18 年的题目的时候，也是一个绘制题，我画出了正确的结果，但是却认错字，今年的结果还是很清晰的。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-9&quot;&gt;Day 9&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;第九天的问题难度并不大，输入的处理上也不复杂，在细节上需要考虑仔细&lt;&#x2F;li&gt;
&lt;li&gt;输入处理
&lt;ul&gt;
&lt;li&gt;构造枚举类型 Move ，类型内部数据为步数&lt;&#x2F;li&gt;
&lt;li&gt;实现 trait FromStr 将一行输入构造对应的 Move 类型&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;第一个部分的绳子很短，只有两个结，尾部的结 T 随着头部结 H 移动&lt;&#x2F;li&gt;
&lt;li&gt;T 跟随 H 移动的规则如下
&lt;ul&gt;
&lt;li&gt;如果 H 和 T 直接相邻或者重合那么 T 不移动&lt;&#x2F;li&gt;
&lt;li&gt;如果 H 和 T 处于同一行或同一列，而且距离为 2 ，那么 T 向 H 的方向移动一步。如果每一次移动都严格按照移动规则进行移动，当 H 和 T 同属一行或一列时，他们的距离不可能超过 2 ，同时 T 当新位置就是 H 和 T 的中位，所以可以不用考虑 H 的移动方向，直接计算中位即可 T = (H + T)&lt;&#x2F;li&gt;
&lt;li&gt;如果 H 和 T 处于对角线，同时距离为 2，那么这个时候 T 不移动&lt;&#x2F;li&gt;
&lt;li&gt;如果 H 和 T 的距离大于 2 ，那么 T 的移动方向是对角线，这个时候 T 有四个可能的移动方向，可以发现四种情况中只有一种可以缩短 H 和 T 的距离，所以遍历四种可能，确定唯一的移动路径即可&lt;&#x2F;li&gt;
&lt;li&gt;更加简便的规则：&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;blockquote&gt;
&lt;p&gt;https:&#x2F;&#x2F;github.com&#x2F;ropewalker&#x2F;advent_of_code_2022&#x2F;blob&#x2F;master&#x2F;src&#x2F;day09.rs&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;移动的情况是随意的，所以假想的地图应该是无限大的，那么利用 Vec 来抽象地图就不方便了，而且题目的要求中并不需要真正的抽象地图，而只需要计算某一个绳结所有的访问位置，那么可以利用 HashSet 来进行存储，值为对应的绳结坐标即可。&lt;&#x2F;li&gt;
&lt;li&gt;同样的对于 H 和 T 也只需要关注每一颗的坐标即可。&lt;&#x2F;li&gt;
&lt;li&gt;对 Move 实现方法 get_step 和 move_fn 来快速取得 H 需要移动的步数和移动的方法，move_fn 方法返回函数闭包，能够传入参数快速计算出 H 的下一个位置。&lt;&#x2F;li&gt;
&lt;li&gt;第一个部分的解答就很容易了，因为只有两个结 H 和 T ，为了防止混乱（步子迈太大容易扯到自己），所以一步一步计算，对于每一步，首先利用 move_fn 的方法移动 H ，再根据移动规则移动 T ，将 T 的新位置存入 HashSet 。最后 HashSet 的长度即是 T 到访过的所有位置。&lt;&#x2F;li&gt;
&lt;li&gt;第二个部分看似复杂，绳结的数量增加到了 10 个，构建 ropes ，c长度为 10 ，初始时每一个绳结的位置都为 (0, 0)，索引 0 为 H 的坐标，索引 9 为 T 的坐标。依旧是一步一步的考虑，对于每一步，移动总是从头部开始，所以当 i 为 0 时，利用 move_fn 移动头部。对于其他绳结，利用移动规则计算下一个位置 &lt;code&gt;ropes[i + 1] = move_tail(ropes[i], ropes[i + 1])&lt;&#x2F;code&gt; 可以理解 i 是头部和 i + 1 是尾部，这是第一部分。需要记录尾部的访问情况，所以当 i 为 8 时，也就是计算 &lt;code&gt;ropes[i + 1]&lt;&#x2F;code&gt; ，这个时候将 &lt;code&gt;ropes[i + 1]&lt;&#x2F;code&gt; 的位置存入 HashSet 。同样的最后 HashSet 的长度即是 T 到访过的所有位置。&lt;&#x2F;li&gt;
&lt;li&gt;如果花费大量的时间，也是可以不一步一步的来，但是那就要花费大量时间分析 H 和 T 的对应情况，而且这个问题需要确定 T 的移动路径，那么对这个问题来说可能没有必要。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-8&quot;&gt;Day 8&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;今天这一题考虑过度，导致花了很长的时间，最后是直接暴力完成的，运行速度不慢&lt;&#x2F;li&gt;
&lt;li&gt;输入的处理很简单，直接按照字符划分即可，再将每个字符转为数字即可&lt;&#x2F;li&gt;
&lt;li&gt;对于每一个位置，只存在四个观测路径，朝上下左右四个方向看，直到实现被阻挡或者尽头（边界）&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;搜索最远可见树的位置&lt;&#x2F;strong&gt;：考虑一个位置 (x, y)，树高为 h， 从这个位置向左遍历所有树高度小于 h 的位置，当遍历到的位置树高大于 h 或 遍历到边界时，遍历结束，结束时的位置即为 (hx, hy)&lt;&#x2F;li&gt;
&lt;li&gt;对于第一部分，如果位置 (hx, hy) 是处于边界的，那么起始位置 (x, y) 是可以从边界之外看见的树。那么只要遍历网格中所有的位置，同时对每一个位置，进行四个方向的搜索，最后就能确定所有能够从边界处看见的树。&lt;&#x2F;li&gt;
&lt;li&gt;对于第二个部分，从位置 (x, y) 搜索到最远可见的树的位置 (hx, hy) ，在这两个位置间存在树的数量即是计算分数的一部分，因为搜索只能是笔直方向的，所以两个位置的差距即是可见树的数量，如果 (hx, hy) 是在边界上，那么在这之外是看不见一棵树的，但是如果 (hx, hy) 不在边界上，那么视线被 (hx, hy) 的树阻挡，这一棵树也要计入，需要在结果上加一。计算四个方向上可见树的数量，再累积即可。最后对所有位置上的分数取最大值即可（或者搜索时同时计算最大值）。&lt;&#x2F;li&gt;
&lt;li&gt;考虑网格的大小为 n * n （方便起见设为正方形），每一次搜索的路径都是笔直的，所以一个位置对一个方向上的搜索，最多需要比较 n 次，时间复杂度为 O(n) ，那么所有位置对一个方向的搜索的时间复杂度是 O(n^3) ，四个方向上搜索的时间复杂度就会是 O(4n^3) 。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;可能有的优化&lt;&#x2F;strong&gt;：正是这个地方让我花费了大量的时间，最初我并没有意识到搜索的路径是笔直的，所以是在四个方向上进行四次毫无关联的搜索。因为给定输入的网格大小只是 100 ，所以即是没有优化，最后的时间复杂度也不会过高，程序依旧能较快完成。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;优化——记忆化搜索&lt;&#x2F;strong&gt;：
&lt;ul&gt;
&lt;li&gt;第一部分：考虑输入中的一行 123 ，从左到右依次编号 1、2、3，那么考虑向左搜索，搜索 1 号时，不需要进行比较，已经处在边界，所以 1 肯定是从左边界可见的，搜索 2 号时，需要和 1 号进行比较，抵达边界不再需要其他的比较，所以 2 也是左边界可见的。考虑 3 号的搜索，默认情况下 3 号要和 2 号比较，然后再同 1 号比较，所以需要比较两次，但是在和 2 号进行比较的时候，因为 2 号已知可以被看见，所以只需要进行一次比较即可。这个优化的麻烦点在于四个方向上的搜索是独立的，所以需要进行四次记忆化。&lt;&#x2F;li&gt;
&lt;li&gt;第二部分也可以用这样的方法进行记忆化，当前位置为 (x, y) 在比较下一个位置 (x1, y1) 时，如果当前树高于下一个树，那么可以直接和下一个树可见位置 (hx1, hy1) 进行比较，因为 (x1, y1) 位置的树高一定大于 (hx1, hy1) 处的树高，那么中间那些重复的比较就可以略过，减少了计算。同样的这个记忆化在不同方向上是独立的，需要单独存储。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;现在看来好像这些优化也并非特别复杂，这是因为我已经完成了基础版本的代码，在这基础上再进行优化会比从写第一行代码时就开始考虑优化要容易很多。可以说是步子迈的太大以至于浪费了时间，也弄乱了思路。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-7&quot;&gt;Day 7&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;这一题要求根据命令和结果构造存储结构，应该是不难的一题，但是我却花了两个小时&lt;&#x2F;li&gt;
&lt;li&gt;输入包含两个部分，命令和命令输出结果&lt;&#x2F;li&gt;
&lt;li&gt;只有两条命令 cd 和 ls&lt;&#x2F;li&gt;
&lt;li&gt;cd 表示进入目录，这个命令无输出结果&lt;&#x2F;li&gt;
&lt;li&gt;ls 表示输出当前目录结构&lt;&#x2F;li&gt;
&lt;li&gt;ls 的命令输出结果中也包含两部分&lt;&#x2F;li&gt;
&lt;li&gt;例如 dir a 表示存在子目录 a&lt;&#x2F;li&gt;
&lt;li&gt;和 14848514 b.txt 表示存在文件 b.txt 大小为 14848514&lt;&#x2F;li&gt;
&lt;li&gt;对输入的处理并不难，但是 cd 命令中存在两个特殊的情况， &lt;code&gt;cd &#x2F;&lt;&#x2F;code&gt; 和 &lt;code&gt;cd ..&lt;&#x2F;code&gt; ，也就是说进入子目录后需要能够回到上层目录和根目录&lt;&#x2F;li&gt;
&lt;li&gt;第一部分需要在确定目录结构之后，计算每一个目录的大小，再计算目录小于 1000000 的目录大小总和&lt;&#x2F;li&gt;
&lt;li&gt;第二部分需要确定再删除了哪一个目录后能够空出需要的空间，所以同样需要计算每一个目录的大小。&lt;&#x2F;li&gt;
&lt;li&gt;如果能够正确的表示目录结构那么就能够轻易的求解。&lt;&#x2F;li&gt;
&lt;li&gt;**构造树有些大材小用，如果要计算目录大小，可以模拟完成。**处理输入时记录文件夹结构，同时计算文件夹下文件大小的总和，完成输入处理后，再递归计算子文件夹大小，这样就能确定所有文件夹的大小。
&lt;ul&gt;
&lt;li&gt;转移方程 f(dir) = sum{f(sub_dir)} + sum{f(file)}&lt;&#x2F;li&gt;
&lt;li&gt;边界情况：当文件夹不存在子文件夹时，f(dir) = sum{f(file)}&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;gou-zao-shu&quot;&gt;构造树&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;初步构造 Dir&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;Dir {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sub_dir&lt;&#x2F;span&gt;&lt;span&gt;: HashMap&amp;lt;String, Dir&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;files&lt;&#x2F;span&gt;&lt;span&gt;: HashMap&amp;lt;String, File&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;size&lt;&#x2F;span&gt;&lt;span&gt;: Option&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;parent&lt;&#x2F;span&gt;&lt;span&gt;: Option&amp;lt;Dir&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这时最初的文件夹思路，但是这样的做法存在严重的问题，问题就在于对上层文件夹的访问，如果将文件夹结构视为树，那么也就是子节点需要访问父节点，那么这样的 Dir 是无法满足需求的，虽然也有 parent 但是会导致所有权的问题，一般来说构造树的时候需要使用 &lt;code&gt;Rc&amp;lt;RefCell&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&amp;gt;&lt;&#x2F;code&gt; 但是我并不想这样做，太复杂了。所以我参考了 https:&#x2F;&#x2F;rust-leipzig.github.io&#x2F;architecture&#x2F;2016&#x2F;12&#x2F;20&#x2F;idiomatic-trees-in-rust&#x2F; 中构造树的方法。&lt;&#x2F;p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;增加 Dirs ，利用 Vec 和节点索引值来构造树结构&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;Dirs {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;dirs&lt;&#x2F;span&gt;&lt;span&gt;: Vec&amp;lt;Dir&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;next_index&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;调整 Dir 为&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;Dir {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;id&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sub_dir&lt;&#x2F;span&gt;&lt;span&gt;: Vec&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;table&lt;&#x2F;span&gt;&lt;span&gt;: HashMap&amp;lt;String, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;files&lt;&#x2F;span&gt;&lt;span&gt;: HashMap&amp;lt;String, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;parent&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;sub_dir 中只保存子目录的索引值&lt;&#x2F;li&gt;
&lt;li&gt;table 中保存子目录名称和索引值的对应&lt;&#x2F;li&gt;
&lt;li&gt;id 当前目录的索引值&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;这样修改之后既可以实现子节点快速访问父节点，又可以保证树的结构&lt;&#x2F;p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;构造 File&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;File 较为简单，只需要包含文件名和大小，可以视为树的叶子节点。可以优化直接优化为 HashMap ，而不需要额外的结构，直接用哈希表存储文件名和大小即可。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;File {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;size&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;mo-ni&quot;&gt;模拟&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;首先对输入进行处理
&lt;ul&gt;
&lt;li&gt;构造栈 pwd 存储档期当前目录的绝对路径&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;cd ..&lt;&#x2F;code&gt; pwd 弹出栈顶&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;cd \&lt;&#x2F;code&gt; pwd 设为 &lt;code&gt;vec![&quot;&#x2F;&quot;]&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;cd name&lt;&#x2F;code&gt; pwd 压入 name&lt;&#x2F;li&gt;
&lt;li&gt;对于 ls 命令，需要完成两件事情，
&lt;ol&gt;
&lt;li&gt;记录当前路径下所有的子目录&lt;&#x2F;li&gt;
&lt;li&gt;记录当前路径下所有文件的大小和&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;构造 &lt;code&gt;sub_dirs: HashMap&amp;lt;String, Vec&amp;lt;&amp;amp;str&amp;gt;&amp;gt;&lt;&#x2F;code&gt; 来存放每一个路径对应的子目录&lt;&#x2F;li&gt;
&lt;li&gt;构造 &lt;code&gt;sizes: HashMap&amp;lt;String, usize&amp;gt;&lt;&#x2F;code&gt; 存放每一个路径的大小&lt;&#x2F;li&gt;
&lt;li&gt;对输入进行处理时，是没法直接计算出文件夹大小的，读取当前文件夹时子文件夹的情况还没读取和处理，所以输入处理时只能计算出一部分的文件夹大小（文件部分）&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;当已经完成所有文件结构的确定，即完成输入同时也完成构造 &lt;code&gt;sub_dirs&lt;&#x2F;code&gt; 时
&lt;ul&gt;
&lt;li&gt;从根目录计算每一个文件夹的大小&lt;&#x2F;li&gt;
&lt;li&gt;如果当前目录没有任何子文件夹，那么输入时计算的所有子文件大小总和即是当前文件夹的大小，不更新 &lt;code&gt;sizes&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;如果当前目录存在子文件夹，那么递归计算子文件夹的大小，确定所有子文件夹大小后，更新 &lt;code&gt;sizes&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;day-6&quot;&gt;Day 6&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;依旧是不复杂的一题，对输入的处理也很简便&lt;&#x2F;li&gt;
&lt;li&gt;读入字符串，转为字符数组&lt;&#x2F;li&gt;
&lt;li&gt;第一个部分要求寻找最早出现的四个完全不同的连续字符的位置&lt;&#x2F;li&gt;
&lt;li&gt;第二个部分要求寻找最早出现的十四个完全不同的连续字符的位置&lt;&#x2F;li&gt;
&lt;li&gt;考虑直接暴力的方法，单指针，从零开始，每次截取所需要的长度的字符数字，存入 Set ，判断 Set 的长度是否不变，如果不变说明截取部分不存在重复，如果发生变化则向右移动指针，继续判断。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-5&quot;&gt;Day 5&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;这一题的难点在于如何处理输入，如果不从文件中读取，而是直接根据输入手动写栈，那么最后的结果应该还能向前&lt;&#x2F;li&gt;
&lt;li&gt;首先确定每一行的输入类型&lt;&#x2F;li&gt;
&lt;li&gt;如果是以 move 开头，那么输入为操作类型，根据空格进行划分，取出中的数字，第一个数字表示移动数量，第二个数字为初始栈，第三个数字为目的栈。&lt;&#x2F;li&gt;
&lt;li&gt;如果为空行则跳过&lt;&#x2F;li&gt;
&lt;li&gt;其他的行都是初始栈的一部分，输入是很形象的栈，所以第一行是所有栈的顶部，自上而下栈顶到栈底。
&lt;ul&gt;
&lt;li&gt;每一个大写字母代表一个集装箱，其他的字符都无意义，但是可以发现即使是空的栈，输入中也包含了空格&lt;&#x2F;li&gt;
&lt;li&gt;利用 char_indices 获取每一行中的字符，以及对应位置，需要将字符位置对应到具体的栈索引&lt;&#x2F;li&gt;
&lt;li&gt;正常情况下，输入中表示集装箱需要使用三个字符，同时使用一个空白和隔壁的栈表示分割，可以考虑从字符 &#x27;[&#x27; 到空白的四个字符都属于当前栈，第一个栈的字符位置应当是 0 到 3（都包涵），第 N 个栈的字符位置应当是 (N - 1) * 4 到 (N - 1) * 4 + 3&lt;&#x2F;li&gt;
&lt;li&gt;那么只要将代表集装箱的大写字符的位置除以 4 就可以得到栈的索引，而且因为索引从 0 开始，所以得到的就是具体的索引，不必加一&lt;&#x2F;li&gt;
&lt;li&gt;当需要将集装箱压入的栈不存在时，即索引大于栈的数量时，需要构造空栈。&lt;&#x2F;li&gt;
&lt;li&gt;而且根据输入是从顶部开始入栈，最后得到的结果是相反的，所以构造完之后也需要对每一个栈进行逆序操作。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;第一个部分只要按照栈的要求即可，根据输入的步骤不断的进行 pop 和 push 操作即可，注意输入中栈的索引是从 1 开始&lt;&#x2F;li&gt;
&lt;li&gt;第二个部分不再是一个一个移动，而是一次性移动好几个，不是纯粹的栈操作。当然可以全都 pop 存放到中间栈，再将最后的结果存入目的栈。但是在这里我直接使用了 Rust 中 Vec 的方法，利用 split_off 直接截取需要移动的元素，然后再利用 extend_from_slice 移入目标栈。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-4&quot;&gt;Day 4&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;这是一道区间题，判断两个区间的重叠情况&lt;&#x2F;li&gt;
&lt;li&gt;对输入进行预处理
&lt;ul&gt;
&lt;li&gt;首先对每行根据 ‘,’ 进行分割&lt;&#x2F;li&gt;
&lt;li&gt;再对每个部分根据 ‘-’ 进行分割&lt;&#x2F;li&gt;
&lt;li&gt;再将字符串转为数字构造具体区间&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;第一个部分需要判断每行的两个区间存在完全重叠的情况
&lt;ul&gt;
&lt;li&gt;&lt;del&gt;可以根据区间的起点进行排序，设起点较小的区间为 p1 ，这时如果 p2 的终点小于 p1 的终点，那么完全重叠&lt;&#x2F;del&gt;&lt;&#x2F;li&gt;
&lt;li&gt;仅仅根据起点进行排序是不够的，例如对于区间 (14, 39) 和 (14, 85) ，按照起点排序，那么顺序不变，这时 p2 区间的终点是不小于 p1 区间的终点的，所以按照这个逻辑这两个区间是不存在完全重叠的，和实际相反。&lt;&#x2F;li&gt;
&lt;li&gt;**排序逻辑：**按照起点排序，起点相同时按照终点倒序，即终点较大的区间为 p1 。&lt;&#x2F;li&gt;
&lt;li&gt;如果不进行排序，需要进行两次比较，在这个部分两次比较的方法更加不容易出错。 (p1.0 &amp;lt;= p2.0 &amp;amp;&amp;amp; p1.1 &amp;gt;= p2.1) || (p1.0 &amp;gt;= p2.0 &amp;amp;&amp;amp; p1.1 &amp;lt;= p2.1)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;第二个部分需要判断每行的两个区间存在重叠的情况
&lt;ul&gt;
&lt;li&gt;可以根据区间的起点进行排序，设起点较小的区间为 p1 ，这时如果 p2 的起点不大于 p1 的终点，那么必然存在重叠&lt;&#x2F;li&gt;
&lt;li&gt;因为按照起点排序，所以 p2 的起点一定大于等于 p1 的起点，如果两个区间重叠，那么只要 p2 的起点都在 p1 区间中，这时两个区间一定存在重叠。&lt;&#x2F;li&gt;
&lt;li&gt;这里的排序并没有第一个部分排序时的忧虑，考虑两个区间起点相同（这时已经存在重叠），这个起点都会小于两个区间的终点，也就是说一定存在重叠。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-3&quot;&gt;Day 3&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;第一个部分和第二个部分的问题是一致的：取得所有都出现在几个字符串中的字符&lt;&#x2F;li&gt;
&lt;li&gt;可以进一步化简为，取得所有都出现在几个序列中的元素&lt;&#x2F;li&gt;
&lt;li&gt;第一个部分每一行输入需要一分为二，然后进行计算&lt;&#x2F;li&gt;
&lt;li&gt;第二个部分则是每三行输入需要进行计算&lt;&#x2F;li&gt;
&lt;li&gt;通过 b as u8 - &#x27;A&#x27; as u8 + 27 可以将大写字符转为题目要求的权重&lt;&#x2F;li&gt;
&lt;li&gt;通过 b as u8 - &#x27;a&#x27; as u8 + 1 可以将小写字符转为题目要求的权重&lt;&#x2F;li&gt;
&lt;li&gt;每个字符可能在一个序列中重复出现，所有对于一个序列中的字符，只计算一次出现的情况&lt;&#x2F;li&gt;
&lt;li&gt;第一部分：
&lt;ul&gt;
&lt;li&gt;构造一个 dup 数组，元素类型为 (bool, bool) ，长度 53 ，数组下标对应相应字符权重对应字符&lt;&#x2F;li&gt;
&lt;li&gt;第一个元素表示当前字符在前一半的输入中出现情况，第二个元素表示当前字符在后一般的输入出现情况。&lt;&#x2F;li&gt;
&lt;li&gt;当元素值为 (true, true) 时则表示当前字符即出现在前一半输入，又出现在后一半输入。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;第二部分和第一部分一致，只不过 dup 数组的元素需要增加一个元素，应对新增的第三个输入&lt;&#x2F;li&gt;
&lt;li&gt;更多解法
&lt;ul&gt;
&lt;li&gt;使用位运算，最多有 52 个不同字符，可以利用 u64 来保存一个输入序列的出现情况，最后计算结果时可以对不同序列的出现情况进行与运算，然后再计算位为 1 的位置和&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-2&quot;&gt;Day 2&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;依旧考察的是对于输入的处理，并不涉及复杂逻辑。自己实现的时候在对于输入的解析上过于复杂了，如果仅仅为了得出结果，完全可以直接处理字符，但是这样的实现便于阅读，也可以练习实现一些常见的 Trait&lt;&#x2F;li&gt;
&lt;li&gt;第一个部分输入均为手势
&lt;ul&gt;
&lt;li&gt;构造枚举类型 Shape 对应手势&lt;&#x2F;li&gt;
&lt;li&gt;通过实现 Trait FromStr 可以很容易的将 A B C X Y Z 六个不同的字符串对应到不同的手势&lt;&#x2F;li&gt;
&lt;li&gt;通过实现 Trait Sub 实现不同手势间的计算结果，实现结果计算
&lt;ul&gt;
&lt;li&gt;也可以实现 Traid Ord 实现不同手势的大小比较，同样实现结果计算&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;第二个部分第一列输入为手势，第二列输入为结果
&lt;ul&gt;
&lt;li&gt;对第一列依旧实现字符解析，对应 Shape&lt;&#x2F;li&gt;
&lt;li&gt;构造枚举类型 Outcome 对应不同的结果&lt;&#x2F;li&gt;
&lt;li&gt;不再实现 Trait ，而是直接利用 match ，根据两列的输入计算结果&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;分数计算：根据给出的手势和结果进行计算每一轮的分数
&lt;ul&gt;
&lt;li&gt;石头：1 分&lt;&#x2F;li&gt;
&lt;li&gt;步：2 分&lt;&#x2F;li&gt;
&lt;li&gt;剪刀： 3 分&lt;&#x2F;li&gt;
&lt;li&gt;输：0 分&lt;&#x2F;li&gt;
&lt;li&gt;平：3 分&lt;&#x2F;li&gt;
&lt;li&gt;赢：6 分&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;day-1&quot;&gt;Day 1&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;首先对输入进行处理
&lt;ul&gt;
&lt;li&gt;输入数据为每个精灵所携带（不同）食物的卡路里数&lt;&#x2F;li&gt;
&lt;li&gt;一个精灵可能对应多个卡路里数&lt;&#x2F;li&gt;
&lt;li&gt;不同精灵通过空行分割&lt;&#x2F;li&gt;
&lt;li&gt;最初设想保留每一个卡路里数&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;第一个部分计算最大的精灵携带食物卡路里数
&lt;ul&gt;
&lt;li&gt;不需要每一个精灵中每一个卡路里数&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;第二个部分计算前三的精灵携带食物卡路里数
&lt;ul&gt;
&lt;li&gt;同样不需要每一个分别的卡路里数&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;可以在输入时就计算每一个精灵携带食物的卡路里总数&lt;&#x2F;li&gt;
&lt;li&gt;第一个部分直接使用 max 取得，时间复杂度应该是 O(n)&lt;&#x2F;li&gt;
&lt;li&gt;第二个部分将转化后的输入数据存入最大堆 (O(n))，取三次堆顶，累加即是结果，时间复杂度是 O(logn)&lt;&#x2F;li&gt;
&lt;li&gt;也可以直接对输入数据进行反向排序 O(nlogn)，第一个部分取第一个元素，第二个部分的问题则是前三元素的和&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>他们大多会没事 ——《江城》</title>
        <published>2022-12-23T00:00:00+00:00</published>
        <updated>2022-12-23T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/jiang-cheng-du-hou-gan/"/>
        <id>https://ghost.livexia.xyz/jiang-cheng-du-hou-gan/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/jiang-cheng-du-hou-gan/">&lt;blockquote&gt;
&lt;p&gt;《江城》—— 何伟 读后感&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;今年的冬天非常寒冷，冬至还没到我已经用上了全部的装备，甚至还购买了新电热毯和帽子，阅读这本书完全和寒冷有关，因为我不是在阳光正好慵懒的午后在躺椅里阅读，就是在温暖的被窝里翻页。和阅读的环境一样，这本书带给我一种慵懒和温暖的感觉。&lt;&#x2F;p&gt;
&lt;p&gt;作者到涪陵的时候我还在母亲的身体里成长，等他逐渐融入涪陵，我也哇哇坠地，作者刚到涪陵的时候比我现在的年纪要大一些，以一个外国人的身份进入当时的中国，进入一个偏僻小城的困难作者在书中写的一清二楚。从抵达涪陵开始成为一名志愿者老师，到依依不舍的离去，两年间何伟从对本地人不礼貌的讨厌，到游刃有余，他被涪陵同化了。那些曾经被他批评的问题，那些奇奇怪怪的社会现象，令人失望的官僚主义，当然他并不喜欢，但是他也像每一个中国人一样开始做到能够忍受而不至于窒息。&lt;&#x2F;p&gt;
&lt;p&gt;改革开放还没实施二十年，而上一次的运动才不到十年，影响了两代人的文革也才结束二十年，那时的人们是怎么样的呢？他们好像都在追求更好的生活，追求财富的增长，但是他们也没有忘记过去的苦痛，对一切还怀有希望和信任。因为水库，长久的家园也要消失，他们也并没有多少波澜，那些可能逝去的历史他们好像也不在乎，长江并没有那些修建水库的机械好看。这一点被我当时在宜昌讨生活的父亲所认同了，父亲现在说起依旧是当时那巨大的器械。&lt;&#x2F;p&gt;
&lt;p&gt;时间过去了二十多年，涪陵榨菜可能已经被全世界华人所知，甚至也渗透到了其他地方，就如美国巨星 rock 那一口不标准的 bingqilin 一样也成为外国人会说的中文。中国在外人的眼里不再是闭塞落后的国家，人们开始担它的威胁，开始依赖它的能力。作者书中出到涪陵对交通不发达的描述可能在现在的人看来有些难以置信，中国现在的印象是遍布高速公路和城际高铁。可以说对中国的评价，以及中国的发展都让人们惊叹，这样的变化可能是中国速度吧。&lt;&#x2F;p&gt;
&lt;p&gt;这好像都是外在和物质的发展，人们的内心发生了什么变化呢？我想是越来越开放，但同时又越来越闭塞了。人们可以享受到来自世界的文化，可以和全世界人在同一时刻听到最新的歌曲，看到最热的电影，也可以买到最好的产品，这都是开放的一面。但是我们却看不到像《江城》这样的书能够在现在再被出版，无数的批评和讽刺都不会在当今的出版市场存活。公开的讨论是受到限制的，更别提批评了，在我写下这段话的时候我就清楚的意识到，当我在豆瓣提交书评的时候，很可能会弹出需要审核的提示。而那些真正好的电影、游戏和书籍，总是难以通过。这一切都悄然发生，而大部分的人对这些事情并没有什么不满，也许是表面上看起来，但是满意的人大都是要多过不满的人。&lt;&#x2F;p&gt;
&lt;p&gt;这本书是一本镜子，也许不是平整和完美的镜子，但是透过这面镜子我依旧看见那个我出生时中国的浮光掠影，也看到那样的时光是如何成为现在的现实。当我被楼下大妈谈话的声音吵醒，睡眼朦胧的窝在被窝里读完最后的部分，可能是因为刚刚睡醒，我却泪眼婆娑，好像在和一个老友告别，在和涪陵告别，在和作者告别。我很高兴能够透过一个外国人的眼睛看见自己，透过一个成为我们的人发现自己。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>做得非常好 ——《金色梦乡》</title>
        <published>2022-12-06T00:00:00+00:00</published>
        <updated>2022-12-06T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/golden-slumber-note/"/>
        <id>https://ghost.livexia.xyz/golden-slumber-note/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/golden-slumber-note/">&lt;blockquote&gt;
&lt;p&gt;《金色梦乡》—— 伊坂幸太郎 读后感&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;读完这本书的时候已经是凌晨四点半了，本来想着睡前读个十分之一就不错了，结果一不小心直接读完了。这本书不是本格推理，不存在严密的逻辑推理，虽然反派是存在的，但是却不是主要人物，甚至都没有正式出场，到最后人们也不知道究竟是谁。这是一次畅快淋漓的阅读体小说的节奏安排的很好，情节发展与安排也不突兀，总是能将我紧紧抓牢。&lt;&#x2F;p&gt;
&lt;p&gt;主人公们都不是英雄，即便分手多年，青柳依旧沉浸在上一段恋情中，他是一个平凡人，不追求高大上的工作，也没有英雄的浪漫感。但是作为一个普通人，他能见义勇为，即使经历各种各样的背叛，他依旧将信赖作为行事的准则，他关心他人，能够谅解他人的不易。青柳是每个人都认识的一个朋友，他有各种各样的朋友，了解他的人不会不相信他，认识他的人了解他的可靠，他由各种各样的小细节构成。这样的一个人，突然被陷害，然后开始他的逃亡人生。&lt;&#x2F;p&gt;
&lt;p&gt;走投无路的青柳怎么办能？陷害他的人拥有一股巨大的能量，能够构造他的生活，能够利用要挟他的好友，在这个时候他眼里的世界是怎么样的呢？如果是我一定会陷入偏执，所有人看起来可能都像是要举报我，但是男主他却不断的信赖，信赖老友，信赖学弟，信赖杀人狂，信赖莫名其妙大叔的计划，对前女友的想念，可以说是对过去的信赖，在冥冥之中帮助了他。这是一种稚嫩的勇气，这对一个陷入绝境的普通人来说好像是致命的，但在另一方面，这也是本书最大的优点。&lt;&#x2F;p&gt;
&lt;p&gt;要摆脱强加在自己头上的黑暗，如果是好莱坞的电影，那么可能单枪匹马，找到幕后黑手，最后惩恶扬善，是勇气和力量的化身。青柳也是单枪匹马，但是逃跑的念头来自死去的好友，第一次直面警察也并非处于本意，而是为了拯救学弟，但是最后却被人抓走。青柳的逃亡是狼狈的，没有太多的反抗，最后也完全没有找到幕后黑手，连皮毛可能都没有触及，设想的伟大自证清白的计划刚开始就失败了，最后只好狼狈的再次逃离。&lt;&#x2F;p&gt;
&lt;p&gt;那么是什么让一个黑暗面处于完全上风，正义面的人民被压着的故事如此让我着迷呢？那就是由亲情、友情和社会最普通的人之间的友爱组成的力量，这一股力量代表了正义，这是一股温暖的力量。逃亡路上对青年时代的回忆，不同人物巧妙的交织在一起，最后集结成一股温暖的力量，使得本应该跌入深渊的青柳得以生存。当青柳以平凡普通的面貌出现在那些帮助他的人面前，而他们又都以各自的方式进行回应，因此我流泪，但又因此而笑出声。&lt;&#x2F;p&gt;
&lt;p&gt;所以即使是一个正义没有打败黑暗的故事，我却看出了无限的希望，自己内心的黑暗也被清扫，我想这正是这本书做得非常好的地方吧。至于男主有没有跳出生活的框框，好像他的确跳出了平凡的生活，但是也正是过去的生活让他生存，所以是否能够跳出生活的框框是不重要的，他和樋口的分手也并非如此，只不过二人想要的不同，不同的框框，他们二人最后都能够好好的继续生活。所以我想如果能够继续努力的生活，那么也就是做得非常好了。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>生活即生活 ——《鹿川有许多粪》</title>
        <published>2022-11-24T00:00:00+00:00</published>
        <updated>2022-11-24T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/lu-chuan-you-xu-duo-fen-note/"/>
        <id>https://ghost.livexia.xyz/lu-chuan-you-xu-duo-fen-note/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/lu-chuan-you-xu-duo-fen-note/">&lt;blockquote&gt;
&lt;p&gt;《鹿川有许多粪》—— 李沧东 读后感&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;那颗星悬挂在空中，我站在这里。任何人、任何东西都无法抢占那颗星的位置。我心里也有一颗星，世界上的任何力量都无法将它夺走。“是的，这就是我的生活。”
——《鹿川有许多粪》&lt;&#x2F;p&gt;
&lt;p&gt;我好像没有看过李沧东的电影，所以看他的书好像也是很奇怪的体验，但是机缘巧合我就决定读这本书，读这本书总是提醒我我该重新读一读王小波的书。第一篇短篇还没读完我就知道我会疯狂爱上这本书，这不是一本讲道理的书，不比较制度的优越性，也不指导人们该如何生活，它描述人的生活，描述人的变化，底层人的挣扎、迷惘和愤怒。&lt;&#x2F;p&gt;
&lt;p&gt;五个故事构成了这本书，主人公各式各样，他们都代表了社会的某一部分。《真正的男子汉》的主人公是一个“政治觉醒”的人，这样的人在现在的社会非常多，他们被某一种理念吸引，但是最后却忘记了生活才是奋斗的意义。《龙川白》则描述了一个不愿再为社会而妥协的人，他沉迷在过去的使命中，他抛弃了生活，而到生命的最后，他连这样破碎的生活也不想再妥协，他决定不再做龙川白，但是最后他好像又成了另一种不同的龙川白。&lt;&#x2F;p&gt;
&lt;p&gt;《关于命运》则是一个转折，主人公不再执着于某一个政治理念，但是他执着于自己人生的不幸，虽然不幸但是他依旧努力生活，直到一天他意识到也许自己可以改变命运。在他准备顶替成为有钱人的儿子时，才发现对方是自己的亲身父亲，但是等不到社会的认同，能够证明他们关系的父亲死去。然后他的人生被打碎了，这样不幸的人生占据了他，他不再努力生活，过去成了虚妄，于是未来也就不重要了。直到某一天再次遇到父亲的手表，虚妄的过去被确定了，他不再疯狂，也能够讲诉自己的命运。&lt;&#x2F;p&gt;
&lt;p&gt;《鹿川有许多粪》的主人公是一个最为普通的人，努力的工作，追求稳定的生活，这样的生活被自己的弟弟打破。他和他弟弟正好像是他的母亲和父亲的对应，他的母亲承受着所有社会底层人所需要承受的困难，需要能没有困扰的偷窃面包，在需要时能够放弃自己的尊严。他的父亲本有着良好的工作，育人子弟，但是却搞出了婚外情，他则是一个不顾生活的人，生活在尊严面前是不存在的，他是看不见粪的人。弟弟和父亲都是最自由的人，他们享受生活中美好的一面，能够为了自己的理念而存活，而他和母亲则只能在生活中挣扎。妻子因为弟弟的出现而质问二人的关系，最后甚至决定要分开，而他也因为弟弟的出现而追问自己生活的价值。在这个故事中主人公的挣扎是很真实的，他们的生活被打破，于是普通生活的挣扎就变得不堪了。但是主人公也意识到了，弟弟和父亲的自由是建立在他和母亲的挣扎上的，他们保持的尊严和追求是建立在他和母亲的付出上的，如果高尚是建立在卑鄙之上，那么这样的高尚是有价值的吗？&lt;&#x2F;p&gt;
&lt;p&gt;最后一篇《天灯》是我最喜欢的，也是我最能切身体会的，一个前学运的参与者，为了赚钱来到矿村，但却被视做激进分子而承受了牢狱之灾和折磨。她本就不能对周围伙伴参与的运动完全投入，她有一种出离感。她并不认同当局，但也不是彻底的反对派，懵懂和冲动让她成为了运动的一部分，但是最后又对本该是敌人的对方产生了同情，被迫休学，但是又不想认输，于是不断的打工赚钱支付需要的学费。她是一个复杂、混沌和迷茫的人，她有说不清的信念，她坚守这样一种信念她为这样的信念付出了惨痛的代价。如果说在读完这本书的时候，这些事情离我很远，但是在我写这篇读后感的时候，这些事情却好像变得很近了。我也不知道自己的信念是什么，但是我知道我想要的是一种平稳，但拥有一定自由的生活。如果我想要享受我习惯的娱乐，不想用抖音，想要便捷的了解我想要学习的问题，每天早上起床后我需要花半个小时给自己打造一个通道，创造某一种自由。这听起来很奇怪吧，事实上就是如此，这样不自然的描述，本就说明了问题。我不想为自己不相信的事情而奋斗，也不想因为反对某一个事情就赞成对立面，我也不想承认自己没有做过的事情，并不是因为我有什么坚持，我也不是一个高尚的人，这只是我的坚守。秀仁在经过虐待、强奸和出卖之后，她的内心不是灰暗的，她忘着天上的星星，意识到自己的这样的坚持也是不会被剥夺的，她认识了自己。&lt;&#x2F;p&gt;
&lt;p&gt;人活着并不简单，即使是最普通的人，也有着最复杂的脉络，复杂造就了人的不同状态，那么该如何成为某一个人呢？如果要成为人们期望的样子，意味着要抛弃复杂性，要脱离人的根本，然后剩下一具空壳。无论是哪一种生活，投身与理念，沉溺与不幸还是底层挣扎，亦或是迷茫而又坚守，哪一种生活都不会是另一种生活的解答，每一种生活好像都不存在解答，但即使是这样，天上还是有一盏灯，一盏在最绝望的时刻能够提醒人们的明灯，只要一瞥就可以感到治愈。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>不容于世 ——《白痴》读后感</title>
        <published>2022-08-24T00:00:00+00:00</published>
        <updated>2022-08-24T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/the-idiot-note/"/>
        <id>https://ghost.livexia.xyz/the-idiot-note/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/the-idiot-note/">&lt;p&gt;看简介好像可以知道这是一本英雄救美人失败的故事，只不过书中的英雄是个白痴，而美人也不想被拯救，一个白痴终将无法拯救一个不想被拯救的人。作为一个少年，人人都想成为那个拯救美人的英雄，多少人想成为马里奥。看完《堂吉诃德》我也想成为那个幻想中的骑士去拯救那想象中纯洁的爱人。但是读完《白痴》我却难以想象自己成为公爵，反而我更像是书中那些次要人物。&lt;&#x2F;p&gt;
&lt;p&gt;白痴是什么样的，在当下的社会，除了真正精神失常的，还有就是那些种种和社会主流不符的人。书中的主角又是怎么样一个白痴呢？他从小生病居住国外，获得遗产而回国，他不懂当时社交界的任何礼仪，他天真善良，所有人只要想骗他总是能成功，他轻信于人，对于他人做出任何选择好像都不诧异，认为人们做的选择在某个程度上总是合理的。这样的他成为了当时社交圈中的白痴，人人都会认为他是白痴，但是人人却有都不讨厌他，甚至每个人都有些喜欢和敬爱他，但是他依旧还是个白痴。&lt;&#x2F;p&gt;
&lt;p&gt;本来写了一大堆人物的介绍，总感觉自己在凑字数，写来很是难受，我既不能把这本书中所有人物细致的介绍一遍，我也不能描绘出主人公的形象，我做的只不过是以自己拙略的语言来弱化这本书。读这本书总是让自己心有愧疚，书中那些一个个普通人，对应自己的行为，我总是觉得自己好像无比的不堪。自己依旧是那些普通人中的一员，我依旧追逐物质的生活，即使我明白自然和精神的重要，我却无法让自己脱离物质。&lt;&#x2F;p&gt;
&lt;p&gt;从小到大我们总是接受着两种教育，第一种教育是形而上的，这种教育要求我们向往崇高的目标，成为一个好人，这种教育中物质并不是最重要的，在大部分时候要为了崇高而牺牲物质的，甚至牺牲自己。然后还有一种更加实际的教育，这种教育中我们的目标是更好的生活，更好的成绩，更加优渥的生活，在这种教育中崇高好像是次要的。这两种教育总是充满了任何一个人，在这样的教育下，我们的生活是首先追逐利益，然后才是讲求高尚，正如我们选择工作首先是考虑是否稳定和待遇，然后再考虑是否符合自己的理想追求。人们存在一种撕裂，这正是我读这本书最大的感觉，我感觉到公爵不断的处于这种撕裂中。&lt;&#x2F;p&gt;
&lt;p&gt;人们喜欢他的高尚，但是却又厌恶他的白痴，他的存在无时不刻不在提醒着周围的人有多么低下。高尚、纯洁的公爵，无法根据社会的变化做出选择，他做出的选择是圣人式的，于是他被社会所不容，他就是白痴。他是一个伟大的人，他的伟大在于他能够信任那些不值得信任的人，他能够体谅任何选择，甚至这些选择是为了攻击他。但是他却无法在这个社会中生活，他本应该出离在这个社会之外，他被遗产所引入这个社会。他陷入一系列的问题，而他却无法让自己离开这些问题。是的我很想看到公爵和娜斯塔霞幸福生活，我也想看到公爵和阿格拉雅能够成为一生的挚友。但是这样的他是不可能的，他的人物就不是为了这样的目的而出现的，他终于陷入两难的选择，而他只能做出拯救娜斯塔霞的选择，于是他失去了一切，不仅仅是失去娜斯塔霞，失去阿格拉雅，他也失去自己，他终于被这个社会所杀死，陷入混沌。&lt;&#x2F;p&gt;
&lt;p&gt;我并不能告诉自己我要成为公爵这样的人，因为那很可能意味着失去一切，失去自己所想要的东西，他的选择和行动是极其高尚的，是圣人式的，但是同时也是白痴的行为。这是一幅悲剧，一幅没有解答的悲剧，难道娜斯塔霞认为自己可救就能够有美满的结局了吗？罗果仁难道不能在婚礼上奋起杀人吗？难道阿格拉雅能够理解公爵就能使一切不走向混沌吗？难道我能想象社会上所有的人都同公爵一般吗，十九世纪作者笔下的社会就已如此，一切都在进步的时代，我却依旧能在当下看见书中的那个社会。将军一家在讨论社会上的丑闻和现在人们讨论微博热搜又有什么区别，社会上依旧有没有目的，可能仅仅为了娱乐而选择混乱的列别杰夫。&lt;&#x2F;p&gt;
&lt;p&gt;这是一本有些绝望的书，作者可能是想要表达一种对信仰力量的认同，他创造了一个温顺的公爵，可见作者是有信仰的。但是作为一个读者我却很难感受到这样的信仰，作者相信信仰能够拯救人类，即使这可能是悲剧，但是他可能也是相信这一点，因为人们依旧是喜爱公爵，依旧在公爵陷入混沌之后有人能够照顾他，在结尾依旧让一个富家子弟爱上一个贫困姑娘，依旧拥有希望。当下，拥有信仰的人们已不多，人们曾经信仰各种各样新的观念和事物，但是这些好像总是没能带来好的结果。冲突和不平等好像依旧是世界的主旋律，信仰在当下能有什么作用呢？人们很可能看到现在世界上的恐怖袭击，意识到是时候抛弃信仰了。&lt;&#x2F;p&gt;
&lt;p&gt;书中有一段讲述普通人的，想要成为旷世奇才的普通人，这类人总是折腾。这一段的描写是很具有伤害性的，我自己曾相信自己是能够做出一番大事业的，我也曾想象自己的美好未来，也就是说我也是这样一个想要成为旷世奇才的普通人。这样的普通人不甘于普通的生活，总想要创造一个什么，但是往往却无法克服自己的缺点，总是在一个地方打转。这其中好像有一种灭杀梦想力量存在，如果一个人无法努力，那么他能拥有梦想吗？这样的人生是否可笑，是否可悲？是否这样的人也是白痴呢？&lt;&#x2F;p&gt;
&lt;p&gt;如何解答书名白痴，我好像只看出了其中一种解答，这种解答完全是由于我的境遇而产生的，书中的白痴不一定只有一个，也不一定都是好的。上一次读《罪与罚》，读完很久以后我还在思考其中意义，作者的故事好像总是不复杂，往往也不是那么的吸引人，但是作者的魅力好像就在于此，以小见大，虽然不能算是精彩的情节，但是所有的一切好像都自有深意，总是能在以后的生活，在特殊的时刻暗暗的提醒我，期待下一次的再遇。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>信仰崩塌的时代什么是神 ——《美国众神》读后感</title>
        <published>2022-08-03T00:00:00+00:00</published>
        <updated>2022-08-03T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/american-gods-note/"/>
        <id>https://ghost.livexia.xyz/american-gods-note/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/american-gods-note/">&lt;p&gt;我还记得家里有一本这个实体书，我还记得我曾经好几次想要翻开看，但是每次最终都以没有感觉而放弃，这次在读那种感觉完全不存在了，一方面我对美国有了更多的认知，同时我也对神有了更多的认知。美国不仅仅是那个管辖着一大堆好像和他们没什么关系的事情的国家，也不仅是有着苹果手机的国家，美国在我眼中更是一个有着普通人的国家，正和我们身边的人一样，美国人其实也差不多是这样，所以我知道这本书中的故事，实际上也可能是发生在我们周围的故事。&lt;&#x2F;p&gt;
&lt;p&gt;故事是很新奇的，神其实和普通人一样，生活在我们身边，他们并非无所不能，也会穷困潦倒。故事以一个看似普通人的角度出发，他刚刚出狱，他遇见奥丁，他为他工作。于是他不断的参与和观察到即将发生的事情，那就是新神和旧神的冲突，但是一切好像都不止这么简单。&lt;&#x2F;p&gt;
&lt;p&gt;旧神是被移民带到新大陆的，而新神则是新大陆上人们寻得新的信仰而产生的，旧神逐渐被人遗忘，新神迅速崛起，但也意识到自己也很容易被遗忘，他们争夺着人们的信仰和祭品。人们经常会说，现在我们不再信仰。但是我觉得这并不对，人们不是没有信仰，人们依旧信仰，只不过这个信仰可能是自己。信仰究竟是什么，我想从我成长中所看见的来展开，我们家并没有什么信仰，但是一年之中我们会在固定的时刻，去到寺庙，拜神和许愿，我们往往不知道自己所拜的是谁，可能对他们有什么帮助会了解一点。在每个月固定的日子，村里也有人会去村口的土地庙上香。也不断的会听到人们进行各种各样的迷信活动，而白事中往往不仅会出现和尚，也会出现道士。我们这几本看不见道士，但是却能看见各种和尚，他们不像电视剧里一样化缘，更多的是在特定时刻安排吃饭，然后我们按惯例给香火钱。附近最大的寺庙，是很多个村子一起的，寺庙里好像什么各种神仙都有，当然这可能是我的认知错误。总之我的结论是，我们并不特别的信仰佛教或者道教，但是我们的生活却从来没有远离他们。&lt;&#x2F;p&gt;
&lt;p&gt;在读书的时候，我去到寺庙的唯一原因就是，父母叫我许下好好读书的心愿。而到了工作，我见到了不同地方的信仰形式，我住在一个拆迁安置房小区，小区里大都是年纪较大的居民，几乎是每周从小区走到公司的路上，我就看见在小区固定的地方，很多的人在准备宴席，然后是烟雾缭绕的香，经过一段时间的观察，我发现好像他们平时就在准备，当时我的房东，经常的就会折用于焚烧的纸。单就我的观察，这些活动上基本都是和尚。因为居民大都是年纪较大，所以也经常的可以听到白事做法和念经的声音。我的观察是有偏见性和错误的，即使我有所兴趣，那也是短暂和片面的。我不知道人们是出于何种原因而进行这些活动，但是我知道在我小的时候，我的确是会在考的好的时候归因于去年的跪拜，然后在今年更加诚心，不知道是某一年我实在考的太差了，还是其他的什么原因，我突然就对这一切产生了怀疑，于是我不再跪拜。&lt;&#x2F;p&gt;
&lt;p&gt;然后我没有信仰，至少没有传统意义上认为的信仰，但是我的确非常崇拜计算机和互联网，直到现在也是如此，而且也在一段时间内崇拜过这个国家，然后还有各种各样的事物，崇拜游戏，崇拜金钱，崇拜知识，这些各种各样的可能可以称为信仰的事物。这里面很少有是出于某种神秘色彩的，可能计算机和互联网可以算是，因为我好像不知觉的就被吸引，我不求回报的在学，当然也达不到虔诚的地步，因为我还是会偷懒。如果说有什么信仰是达到了虔诚的地步，我会说是自我，当然不是指盲目的自信和热爱，但是我会为了考得好而去跪拜，为了成功而崇拜金钱，为了更有世面和崇拜知识。所以如果按照我的情况，相比于那些虔诚的佛教徒，我的信仰应该算是崩塌的，所以我是不崇拜神的，即使我可能有这么多的崇拜对象，但是他们都是没有具体形象的，我并不崇拜某一个计算机，这些崇拜都是灵活可变的，可能之前我还心心念念崇拜着的电脑，新品发布后马上就被我弃之不顾。&lt;&#x2F;p&gt;
&lt;p&gt;讲完了自己对信仰的观察，其实也没有什么好讲的了，书里的旧神就生活在这样的世界，书里的故事虽然极具美国特色，因为可能他们的旧神更多，而且这些旧神可能都来自某些伟大的神，甚至也有从我们这跨洋而去的八仙，但是我也明白更多的还是这样的冲突，这样的冲突实际上在我们时候周围存在。&lt;&#x2F;p&gt;
&lt;p&gt;还有一个事情值得一说，那就是为什么人们不再信仰神，就是说为什么我自己的信仰会这样支离破碎。因为我并不想献祭，神如果凭借人们的献祭而活，而这个献祭需要是运气不好在某一个时刻出生的小孩，那么我就不想献祭，所以旧神会不被信仰。当我看见佛教徒惯例需要的香火钱的数额，当我看见道家根据法事的时常而计算费用的时候，我就觉得这样的献祭值得吗？这看起来像极了骗局。那么新神呢？是的我会沉迷电脑，可能花费一整天的时间在游戏上，可以说我献祭了时间，但是有的时候我依旧不想献祭，因为我自己知道这是沉迷，这是不对的，如果神建立在一个需要信众沉迷的活动上，那么我并不信仰它，我只是自制力不强而已。我觉得这就是作者的答案，那就是他并不同情旧神，也不厌恶新神，他只是觉得神应该顾好自己，而不是在乎是否有人信仰它。&lt;&#x2F;p&gt;
&lt;p&gt;在过去，神是这个世界的主人，所有的事情都有神的参与，他们可能有不同的名字和表现，造反需要神，结婚也要根据神的意见，神好像在主宰着一切。然后旧神被科学之神杀死，人们不再将洞穴墙壁上的影子看作神，而是相信自己能发现一切的奥秘，人们虽然不承认信仰新神，但是的确有人信仰。如果按照现在的看法，也就是神是不存在的，至少在物理上不存在，神变成了精神上的存在。于是神开始淡出一切，灾害不再是因为神，而是因为人，而成功也不再是因为神的祝福，而是因为自我奋斗，于是人开始主宰一切，神成为了人的工具，大家也不再叫神为神，它有了新的名字，那就是意识形态，人们利用这个工具自相残杀，人们过于自大。人们总是按照意识来判断价值，没有意识到空气实际上是最不重要的，虽然人们不能不呼吸，水和大地都是这样。人们不在乎植物是否疼痛，但是人们在乎杀害牛是否不人道，而鱼缸里鱼的死去也是可以接受的，因为它们没有意识，而人们依旧在神话外星人。人们按照自己的模样塑造神，现代社会的神几乎就是人类，超级英雄里的英雄，几乎和人类一模一样。&lt;&#x2F;p&gt;
&lt;p&gt;从无处不在的神，到无处不在的人，我们总是在忽视。单就这个故事来说，旧神不重要，新神也不重要，人其实也不重要，那片土地才最重要，旧神和新神的斗争，人类的自大， 他们都忽视了这片土地，而土地静静的存在。在故事的最后，土地的象征告诉主角，无论是神还是人的到来，都是因为对这片土地有用，但是只是会改变的。这不正是当下世界正在发生的事情吗，隔壁的战争依旧没有结束，人们已经开始预言新的战争，地球稍微变暖，最有钱的人已经开始考虑前往新世界。我们长期所忽视的环境正在显现它的威力，持续一周的40度以上的高温，在过去38度就已经难以忍受了，但是借助空调，人们可以抵抗这炎炎夏日，过去在晚上就开始凉爽的夏夜，变成了闷热的夜晚。大地在某一时刻可能会选择不需要我们人类了，而这样的选择正是人类所做出的。&lt;&#x2F;p&gt;
&lt;p&gt;这本书，正如作者说的可能充满漏洞，可能也没有什么固定的主题，但是单就个人而言，他让我能够更深的思考人、神和大地的关系，那么这本书就算是一本好书，就值得推荐。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>一段让我重新体验的阅读体验 ——《鄙视》读后感</title>
        <published>2022-07-31T00:00:00+00:00</published>
        <updated>2022-07-31T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/il-disprezzo-note/"/>
        <id>https://ghost.livexia.xyz/il-disprezzo-note/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/il-disprezzo-note/">&lt;p&gt;&lt;strong&gt;注意：这并不是什么读后感，也不是什么评价，只是我的阅读体验。&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;最初发现这本书是接近一年前从一个播客中听到的，在忽左忽右上听见梁老师的推荐，听到的时候我就想要买来读了，但是我却在接近一年后才开始阅读这本书。为什么这么迟才决定读这本书呢？因为通过播客，所以我对这本书所涉及的一个主题有所了解，一方面让我对这本书产生了无比的兴趣，但是另一方面也让我对这本书产生了恐惧。我害怕通过阅读这本书，我终于可以知道我是一个多么糟糕和恶劣的人。&lt;&#x2F;p&gt;
&lt;p&gt;不知道是不是一种常见的问题，那就是人们相信爱情的力量是无比巨大的，爱是不会随着时间改变，于是当爱情发生变化的时候，人们好像感觉到自己被背叛了。书里的男主也是如此，从一开始他就无法看见自己的改变，而他的归因首先是工作，首先是让自己痛苦的工作，里卡尔多意识到埃米丽亚好像不爱自己的时候，他想要将这一切和工作所挂钩，可能的确工作和他们二人的破裂有关，但是这并不是直接原因。男主的逻辑是建立在妻子肤浅和对贫困的厌恶上的，他只看见妻子的外在，而从未真正的在意妻子的内心，不断的描述妻子的肤浅，这样的思考又如何能找到他想要的答案呢？&lt;&#x2F;p&gt;
&lt;p&gt;主人公不断的说买房子、买车子和做着痛苦的工作是为了妻子想要的，但是当妻子告诉她自己并不需要这些的时候，他却觉得收到羞辱。当主人公和妻子第一次到新的房子里的时候，妻子示爱，主人公却觉得妻子陷入物欲之中，而非对他的爱意，男主从来就不在乎妻子的内心。这样的场景不正是在爱情里送礼物的双方吗？一方可能在经济上有优势地位，所以习惯了利用消费来体现爱情，但是往往又恐惧于对方究竟是爱人还是爱物，于是就无法真正的表达自己的爱。处于劣势的人，则更加痛苦，因为对方很可能已经习惯了这样消费的爱意，而自己却无法做任何事情，于是爱情就产生了不对等，自己很可能并非真正的想要这一切，但是却必须要表示的开心，于是就在打压自己，爱情成为了消费的附属。&lt;&#x2F;p&gt;
&lt;p&gt;在当下这更加困难，找到一个愿意倾听的人很难，找到能够满足自己情感需求的人很难，而通过地位、财富来选择变的更加容易了，如果一个充满学识和智识的人都无法提供感情需求，选择一个能让自己在物质生活上有保障的人不是更好吗？当下的人们并不是不寻求美好的爱情，但是这样的爱情在一次次的尝试中都化为泡影，于是人们退而求其次，于是房子和车子成了更加重要的标准。但是这并不是一切，因为当到某一个时刻，人们又开始意识到，自己并不需要对方给予生活保障了，当初那些看的很重的事物，实际上自己的努力就已经足够，于是人们决定并不妥协。孤独可能好过两人痛苦相处，于是离婚越来越多。于是在新的时代，不再是过去那要求有房有车，给可能是我都要有，而这将是无比困难的。&lt;&#x2F;p&gt;
&lt;p&gt;男主不断的探寻为何妻子不爱他，为何妻子鄙视他，他观察得出结论然后就陷入英雄式的幻想。这样英雄式的幻想并没有成为英雄的行为，面对制片人对妻子的调戏他沉默以对，即使是最后的辞职他也不敢面对制片人，他依旧害怕制片人，他也只敢找自己的妻子对质，而无法对制片人有所动作。男主幻想自己是奥德赛式的英雄，但是却没意识到自己无比的害怕失去妻子，他幻想的是一个女性就该爱上奥德赛的世界，女性是没有价值的，男主其实和制片人是一致的，都在希望女性的投怀送抱，但是他却没有办法像制片人一样，他好像仍有对美好的追求，于是他陷入了这样的地步。也就是说男主即不是英雄，也不是反派。&lt;&#x2F;p&gt;
&lt;p&gt;在最后的时候，男主幻想了一个场景，女主突然现身，理解了他并原谅了他，女主意识到男主的牺牲。这是一种反讽，即使在这样的情况下，男性依旧沉迷在幻想之中，而这幻想之中女性依旧是木偶，没有自己的意识，所有的行为仍就是男性的视角和行为。&lt;&#x2F;p&gt;
&lt;p&gt;虽然随着科技的出现，人们的沟通越来越方便了，但是人们却更加难以说出那些真实的东西，最近我意识到这一点，但是我却没法改变自己，以致于我减少了和人的交流。讨论吃什么、买什么和今天又有什么热点事件，这都是虚假的，人们没有了真实的交流，每次面对屏幕，我想到自己无法说出自己想说的而痛苦。人们失去了沟通，人们不再倾听，男性不断的在说，女性的声音则不断的被忽略，于是她们也不想再听，所以我因为无法说出自己想说的而痛苦，实际上是因为自己也无法倾听。人们可以每分钟都在发信息，但是却从未沟通，书中的男主和女主就是如此，每个人都在说自己想说的，却没有听到对方想说的。&lt;&#x2F;p&gt;
&lt;p&gt;这是一本极其复杂的书，在写这个内容的时候，我一边觉得自己漏掉了无数的内容，一边又觉得读我写下的好像不如直接去读书。让我坚持读完的，是我想探究一下这本书是不是给出了答案，当然一切都不是那么简单，作者在书里给出了很多的答案，但是没有一个是完美的，这正是现实，即使你是成年人，你也无法我都要。我不想再多些书里的剧情了，我推荐梁老师在忽左忽右上的分享，更加全面。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;以下是我的一些不成逻辑的阅读体验。&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;一年前我还沉迷在上一段爱情的破灭之中，而那一年我不断的想要寻找到自己的问题，想要通过阅读，想要不断的转换视角来发现自己的问题，经过半年的时间，我决定暂时放下我对这段感情的依恋，我想要远离所有能让我想起这段感情的事情，而阅读这本书必然会将我拉回那样的状态，那么我将继续沉迷在回忆中。即便从那个时候到现在又过去了一年多，我的人生却好像依旧在原地踏步，一直想要找工作却迟迟无法下定决心，我的生活依旧是脱轨的，可以说直到现在我身上社会人的属性依旧在消减。我不断的想要逃避的这些回忆，总是不断的出现在我的生活中，我透过梦境和某些可笑的联想，不断的短暂沉迷在这些回忆之中，也就是说即使时间飞快流逝，人事物都在变化，而我仍旧对那过去抱有一丝幻想。&lt;&#x2F;p&gt;
&lt;p&gt;当我自以为自己已经完全的能够摆脱过去的影响的时候，在读完一部漫长的科幻之后，我很随意的决定开始阅读这本书，我读了一周，中间几乎想要放弃，过去并不如像我想象的消失了，反而它更加强烈的袭击着我。这本书讲的故事并不复杂，涉及到的人物也很少，一切看起来都很简单，但是我读来却极为艰辛。作者写的并不晦涩，让我觉得艰辛的实际上还是我自己的经历，我的回忆，每次阅读一章，我就不断的对照自己，对照里卡尔多和埃米丽亚的婚姻破裂，于是我就无法持续的阅读，每次总是让我痛苦的停下，去思索那过去的错误。&lt;&#x2F;p&gt;
&lt;p&gt;有的时候我觉得非常艰难，以致于我想放弃，但是在我读这本书的时候发生了一件事情。在周五，我已经读了四天了，进度很慢大概是三分之一左右。我的睡眠不是很好，但是这周我睡的很迟，睡觉的时候已经很累了，所以我一般半夜是不会醒来的，能记住的梦境往往也只有临近清晨的梦境。但是周五的时候很奇怪，这是在我早上起床很久之后才意识到的，那天晚上的某个时刻，我做了一个梦境，梦境里我打破了我的犹豫，我终于决定在时隔接近两年后重新联系前任，我想通过微信的好友认证发出我的消息，正在我思考要如何安排自己的说辞的时候，我醒来了。我醒来后意识到我在梦里的行为，这个时候我是清醒的并不是梦境，但是我很累，可能梦境对我的影响也很严重，我清醒的时候并不是想说要阻扰自己，而是在想着我现在很疲惫，这件事情明天起来再做吧。就这样我重新回到了睡眠之中，醒来之后我忘却了一切，一切都和平时起床一般，然后过了很长时间，这样一段发生在睡梦之中的事情才突然抵达我的大脑。&lt;&#x2F;p&gt;
&lt;p&gt;这样的梦境让我很害怕，平时我也会做关于过去的梦境，但是没有一次这么直接，影响之大几乎让我当时就要做出错误的事情，如果我当时不那么累，我想不到什么会阻止我，那正是我潜意识中想要做的，正是这本书读到三分之一的时候给我的感觉。男主那第一人称的叙述，让在感情破裂之后，那时我的苦求和努力重新出现了。我完全的把自己放入了男主的位置，我也无比的想要知道是否还有爱，为什么。在意识到这一点之后，我决定我必须要硬着头皮继续阅读，我需要这样的体验。&lt;&#x2F;p&gt;
&lt;p&gt;我如此的害怕阅读这本书，正是因为这本书真正的道出了我的问题，一切仿佛都能对应，我也体会到了那种鄙视，我既不能提供生活的保障，我也没有能够提供感情价值，于是我们的关系破裂了，对方的洞察更加彻底，而我却仍旧沉迷在自己的幻想之中。这本书没有给我答案，但是给了我无数的启发，最重要的一点就是，我没能在关系里注意到对方的价值，我无法走入对方的心，但是在关系中我却不断的希望对方能看见我的心，在我做出自我剖析的时候，我希望对方能够理解我的时候，我却没有意识到自己毫不在乎对方的剖析，我不在乎我是不是理解了对方，更准确的说，我早就自认我以把对方理解的透彻了，但是当关系破裂的时候，我却发现自己完全不认识对方了，这就是因为我根本没有真正的理解她。如果我想找她道歉，那也不是对方需要的，那只是我的幻想，我觉得道歉了就表示我理解了，表示我认识到了，但是这还是我的幻想。男性不断的要求女性爱着自己，理解自己，如果这有一点点无法达到，那么就会陷入恐惧。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>滑向混乱但仍旧精彩的科幻 ——《海伯利安诗篇》读后感</title>
        <published>2022-07-25T00:00:00+00:00</published>
        <updated>2022-07-25T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/hyperion-cantos-note/"/>
        <id>https://ghost.livexia.xyz/hyperion-cantos-note/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/hyperion-cantos-note/">&lt;p&gt;July 5, 2022 海伯利安&lt;&#x2F;p&gt;
&lt;p&gt;这是一本很漫长的书，但是不枯燥，本应该是七个人讲述的故事，最后却讲出六个故事，每个故事都很长，每个故事好像都在讲述一部分道理。第一个故事是关于宗教和永生，第二个故事则是关于爱恋和战争，第三个故事是关于词语和现实，第四个故事是关于时间和宗教，第五个故事是关于智能和爱恋，第六个故事是关于爱恋、时间和社会。这些故事应该是存在内在联系的，但是我没有看到很明晰的线路，每个故事都充满了痛苦和无法控制，好像存在一个导演安排了这一切的故事，这是一本入门，更加复杂的事情还将继续发生。我非常享受这本书所含有的一种诗意感，读诗的时间并不久也不多，但是读这本书好像给我一种读诗的感觉，感觉悄然的进入我的大脑，情绪悄然而生，诗人好像在独行。&lt;&#x2F;p&gt;
&lt;p&gt;July 8, 2022 海伯利安的陨落&lt;&#x2F;p&gt;
&lt;p&gt;写这个读后感的时候，已经是接近读完20天后了，而我现在已经难以记起很多的剧情了，这是我读书的现实，我无法记忆，我只能感受。如果说第一步书是一种铺垫，那么第二本书一行人的朝圣终于开始，其中每个人都要面对自己的未来和过去，第一本书里的六个故事好像终于有了完结。人工智能和人类的斗争浮出水面，一切的斗争可能都源于此。第一本书中济慈的诗歌继续在这一本书中频繁出现，甚至读者开始读到一个被安放到星际时代的济慈。第二本更加玄了，而我并不喜欢，总觉得是有些半吊子，特别是云门和济慈的对谈，虽然我没有深入佛法，但是作者的体现总让我觉得有些怪异，难道这样的佛语是一个人工智能和一个赛博人最好的交流方式吗？但是作者的讲故事的功底依旧没有变弱，每个故事的发展依旧层层递进，而作者穿针引线的将每个故事连接在一起的能力依旧让我佩服。&lt;&#x2F;p&gt;
&lt;p&gt;July 15, 2022 安迪密恩&lt;&#x2F;p&gt;
&lt;p&gt;依旧是延迟的读后感，这本书的故事我并不满意，所以很可能连感觉都无法给出。环网和霸主已经堕落了两个世纪，那七个朝圣者的故事好像已经完成，新的故事是由一个人讲述的，名字来自古希腊神话，讲述者这时已经处于绝境中，他所做的只是写下故事，进行记录。在这本书中，所有的故事都围绕着不同的星球进行，前途未知的一行人，身后还有追兵，最后却反而被一些追兵所救，然后抵达旧地的故事。一行人有，讲述人安迪密恩，然后是两百年前穿越到现在的赛博人济慈与“侦探”的女儿伊妮娅，然后是诗人的机器人贝提克，交通工具是简陋的木筏。&lt;&#x2F;p&gt;
&lt;p&gt;我明白作者为什么这样安排，一行人的冒险，就好像西游记，一行人克服困难，最后获得启示，可能这是作者的目标。我很难说作者是否有达成这个目标。首先是讲述者最开始就提及他和伊妮娅的爱恋，这让我感到奇怪，要知道二人最初见面的时候，安迪密恩应该已经接近30岁了，而伊妮娅才12岁，而切伊妮娅已经被确立为弥赛亚的地位了。这行人的组成充满了奇怪，讲述者是一个不愿因为永生而信仰的人，伊妮娅是一个被渲染充满神秘感的救世主，而贝提克是一个出现在各样历史事件中的机器人。伊妮娅有着看见未来可能的能力，于是不断的存在着暗示，暗示讲述者和伊妮娅存在爱恋，这就让爱恋不可显，一切好像都是经过巧妙的编织而形成的，包括二人的爱，过早的给伊妮娅以预示未来的能力好像是一大败笔。&lt;&#x2F;p&gt;
&lt;p&gt;虽然可能是二人经过这些曲折终于产生情愫，抛开岁数的差距不说，但是讲述者的出现好像完全是按照一种预言似的设计而达成的，也就是说好像是一出舞台剧，也就是说我很难看见开始，这是时空穿越和先知故事的败笔，很容易事情就没了起因经过结果，既然我预知到未来，那么未来就成了起因，也就是过去，在前两本书中，这个问题并不严重，因为没有很严重的环，一行人受到的是外在的编制，所以一切并不突兀。而这本书二人的关系就显得突兀，就有一种滑稽和虚无感，于是本应该是惊险刺激的追逐就显得有些枯燥和无聊，这不是因为主角必然有光环，不是这样一种认知而体现的，而是书中故事的背景，人物的行为和编排导致的。这个缺点在第四本更加淋漓尽致，我觉得本来这个缺点不会特别明显的，但是作者不知道什么原因，将每个部分都写的异常的漫长，塞进很多的无关叙述，于是更显枯燥，我的阅读也显得极为漫长，没有了第一本和第二本的流畅感。&lt;&#x2F;p&gt;
&lt;p&gt;July 25, 2022 安迪密恩的觉醒&lt;&#x2F;p&gt;
&lt;p&gt;在一个炎热而漫长的夏日午后，我终于读完了这个系列的最后一本，读这个系列并不轻松，读的越来越慢，最后一本我读了十天，中间曾经想过是不是不继续看了，但是最后还是硬着头皮看完了。一行人在旧地的学习好像终于要结束了，一行人的冒险还在继续，这次一行人分散前进，最后抵达一个叫做天山的星球，故事也在此达到高潮。不进行过多的剧透，但是我还是要继续说一下我觉得有的缺点。&lt;&#x2F;p&gt;
&lt;p&gt;在这一本书中，济慈的诗歌被替换成了藏传佛教，然后在我眼里就极具突兀感，很多的描述和我记忆中的藏传佛教并不相符，某些过于奢华的描写，更像是一种清朝皇家的描写，而不像是藏传佛教。这一本书很厚重，有很多的部分都在报人名，特别是反复的报人名，这些人物出场的确自有其作用，但是在很多的时候是没有必要如此详细的描述的，给我一种网络小说凑字数的体验，这个问题在某些场景描述上也有出现。&lt;&#x2F;p&gt;
&lt;p&gt;然后是有很多的说明总给我一种在吹牛的感觉，例如主角利用两千米长的翅膀在巨树之间翱翔，主角数出在场的人大概有两百万，这些描述总是给我一种出离感，这样巨大的描述是有可能发生的，但是我的想象力却无法处理，本应该是让读者有代入感的桥段，让读者感受某一种未来的想象，却让我无法想象，这可能是作品的时代导致的，我读过很多的科幻，看过过多的科幻电影，可能在某种层面上我的想象会更加实际，这也是为什么人类和人工智能大战并不会让我吃惊，我想如果是作者刚写出来的时候，人们一定会惊叹于这一点。&lt;&#x2F;p&gt;
&lt;p&gt;故事的潦草感，作者耗费了大量的时间在讲述天山的故事，讲述神圣的安排，但是却在最后的时候显得很急促，一切的事情都在瞬间发生，那些反复报出的名字，被安排任务，尔后完成，中间没有更多的描写，这样的急促让故事显出一种不真实的感觉。这让那些真正重要的情节完善和推进显得有些轻，就好像我在和同学讲一个故事，但是下一站我就要到了，而本应该是故事最重要的部分，但是却因为快结束了，所以草草说完。这样的潦草，让本来可以是一个完备的故事，变的有些虚无。&lt;&#x2F;p&gt;
&lt;p&gt;即使有这么多的缺点，但是这本书还是要好过第三本的，故事上必然更加精彩，故事的串联也更加流畅，然后加上实实在在的解决了一些悬念和疑问，我个人认为这歌系列还是值得一读。海伯利安这个系列所要讲述的故事太大了，所以必然会有很多的缺漏，有很多第一、第二本中很重要的内容在这一本中成为了背景板上的事物，有些设定和谜题都被弃置不顾，很多细节上的点仍旧无法深究。最后总结，借用看到的一个短评，虽然四本书中实际上只有第一本是最好的，但是这个系列的故事仍旧是超越普通科幻，的确可以算是大师的作品。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>独裁的节日 ——《公羊的节日》读后感</title>
        <published>2022-07-03T00:00:00+00:00</published>
        <updated>2022-07-03T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/la-fiesta-del-chivo-note/"/>
        <id>https://ghost.livexia.xyz/la-fiesta-del-chivo-note/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/la-fiesta-del-chivo-note/">&lt;p&gt;这是一本很厚重的书，但是讲述的故事其实不多，独裁者生命的末期，反抗者的暗杀，受害者的叙述，这三个故事很沉重的把那段历史摆在那里，无法逃避，即使独裁者已经死亡，历史已经前进，但是独裁者好像仍在透过这本书，透过这本书来让人恐惧。&lt;&#x2F;p&gt;
&lt;p&gt;多米尼加共和国是一个我不知道的地方，无知到我想在谷歌上了解一下这个国家的历史，于是我打入了多米尼克，错的离谱，但是最后我还是到达了多米尼加的维基百科，对书中描写的内容，词条里有一个特鲁希略时代，和一个后特鲁希略时代，特鲁希略时代中，关键词是经济发展、香菜大屠杀、残忍和被中情局谋杀。历史是无法从词条里看见的，这些词条只是一种简写，而对这样的痛苦，实际上简写是一种背叛。&lt;&#x2F;p&gt;
&lt;p&gt;这本书里的三条叙述路线，很早就都汇集到了一点，独裁者被杀，受害者受害或者死去，帮凶和加害者有的死去，有的痛苦存活，有的则精彩的活着。 三条叙述的路线安排的非常巧妙，每个部分好像都在给另一个部分的叙事举证，每当一条叙述路线中断的时候，作者留下的那种未知，虽然在不同叙述线路中没有得到明确，但是却进一步被证实，而当这条叙述路线恢复的时候，一切都好像被真实的展现，没有缺少任何的背景和环境，没有缺少任何需要的铺垫，我被放入到一个对这段历史十分熟悉的叙述者中，这个人可能是亲身经历这段历史，甚至是可能是其中的受害者或者加害人。&lt;&#x2F;p&gt;
&lt;p&gt;独裁者肯定是这本书的主角了，他独揽着多米尼加的所有权力，他拥有这个国家的经济，他从警察队伍中成为一个独裁者，独掌这个国家三十年的权力。如同其他的独裁者一样，特鲁希略有着狗腿子，有着游手好闲的家属，也有狂热的忠诚者。在这三十年里，他将国家变为自己的玩物，书中出现的所有人都和他有关，他的谋杀者不是在他的政府和军队工作，就是在他的家族企业中工作，这些人在人生的某一个时刻，都是特鲁希略的同盟。每次特鲁希略抓到反对者，他总是痛心为什么明明这些人依赖他获得了经济或地位上的成就，他没有意识到并不是因为别人依赖他，而是因为这些反对者，这些生活在这个国家上的人，没有办法避开他那巨大的权力。人们在他的统治下，好像吃穿无忧，经济上有了成就，但是这些成就最后必然流向他的口袋，人们获得了身体上的富足，但是却失去了精神上的自由。特鲁希略统治下的人，只允许工作、消费和赞美，他们是被剥夺的人。长达三十年的独裁统治，这些人民已经无法逃离他的力量了，即使是参与暗杀计划的人，他们也是在恐惧中进行行动的，其中那些身在这个独裁者身边的人物最为恐惧，他们无法按照理智行事，即使特鲁希略已经死去，但是他们仍旧无法背叛。&lt;&#x2F;p&gt;
&lt;p&gt;然后是长久以来没有回国的乌拉尼娅的叙述，她是一个有着痛苦过去，但是现在好像坚强和事业有成的女性，她回到这个逃离了三十五年的土地，面对已经无法说话的父亲，面对略带责备的姑姑一家，她讲诉自己作为被独裁者直接伤害的故事。这个故事并不曲折，在不到三分之一的时候，我就已经隐约的猜测到了，但是直到读到最后的讲述时，这个故事中充满的痛苦和愤怒才真正的降临到我身上。特鲁希略的死，没有给她解放，只有当特鲁希略的狗腿子阿贝斯·加西亚死亡的结局才能舒缓她的痛苦。我相信她肯定非常痛恨特鲁希略，但是我好像看到她其实更加痛恨那个人周围的一切，她的父亲，他的狗腿子，还有那个“皮条客”。这些痛恨是无法因为这些人的死去或者痛苦而消失的，她父亲的病痛并无法让她好过，痛苦并不会因为制造痛苦的人不存在了，或者没有新的痛苦而消失的。因为她的父亲无法说话了，所以到最后我也不知道卡拉布尔是否对自己的决定而感到痛苦或者后悔。直到最后我才明白，其实他是否后悔或者痛苦都不重要，因为这对乌拉尼娅来说是不重要的，他造就的痛苦，他没有承担一个父亲的责任，他后悔或者痛苦都不会对这些存在任何的影响，他是一个凶手，他伤害了自己的女儿，这是现实。&lt;&#x2F;p&gt;
&lt;p&gt;在暗杀者的叙述中，每个片段都叙述了每个暗杀者和特鲁希略的关系，他们的仇恨，他们的痛苦，他们因为这个目标而意识到只有杀死他才有出路，但是他们的结局更加悲惨，他们的家人更加悲惨，他们在最后还是被交易了，他们其实是遭到了时代的背叛的。那六个被抓住的暗杀者是极其令人同情的，他们以无比的勇气战胜了独裁者权力压迫，在焦急的等待中杀死了独裁者。但是他们没有等到解放，面对他们的是独裁者的狗腿子，是独裁者的儿子，他们被痛苦折磨五个月，最后死去的时候，还要被安上谋杀武警的罪名。让我最为难受的是，曾经的傀儡总统巴拉格尔在权力真空的时候，以自己独特的手段获得了权力，但是他却纵容独裁者的手段继续横行，而当他意识到这六个人被劫走的时候，他想的是为什么特鲁希略的儿子没有早点杀死他们，当他意识到六个人被杀死而且被安上杀人犯的名头的时候，他安然的接受了这种独裁者的方法，解决了这个麻烦。这六个人是英雄，但是却成为了污点英雄。&lt;&#x2F;p&gt;
&lt;p&gt;有很多人在独裁者政府里承担重要职务的人，在独裁政府被推翻之后，继续担任重要职务，巴拉格尔实际上在多米尼加不连续的做了24年的总统，他是否是一个独裁者我不知道，单就这本书的最后部分，我明白他是一个精通权力之道的人，而这样的人实际上是没有个体的，个体的痛苦是可以为了更宏大的叙述而忽略的。这样的人投身于权力，而非人民，在独裁者时期，他可能不是那些极为残忍的帮凶，但是他也不是反抗者，他精于权力知道如何退让和施展。&lt;&#x2F;p&gt;
&lt;p&gt;为什么在在历史沉淀之后，为什么会存在对过去那痛苦的历史的怀念，对独裁者对独裁政府对怀念？当乌拉尼娅向姑姑叙述自己对独裁政府的厌恶的时候，姑姑会表示过去没有这些小偷小摸，大家生活状况也好一些。这样的情况好像是普遍的，我喜欢看一个视频作者经常进入前苏联的国家，采访那些曾经生活在那个时代的人们，人们也会怀念那个时代。我想是因为虽然好像一切在变好，虽然当权者对个体的人有了更多的尊重，但是好像现在多米尼加的生活也没有那么好。生活在不好的环境中，总是会对其他的环境有着更加美好的幻想。的确特鲁希略被杀死了，人们过上更加自由的生活，但是压迫和迫害却不会消失，只不过以不同的形式出现了。人们不是怀念过去那黑暗的岁月，只不过好像现在的多米尼加也没有太多的盼头。我不相信意识形态这一套，但是这也是一种意识形态，权力的流动和分配，在不同的体系中有不同的体现，在每个体系中仍旧存在着迫害和不平等，一切事情好像都是可以交易的。正如巴拉格尔以杀死特鲁希略的凶手来换取自己的权力可能还有社会的稳定，好像这是一笔划算的交易，人就这样被交易了，而这对我来说，这也是残忍的一种体现。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>《地海传奇》读后感</title>
        <published>2022-06-28T00:00:00+00:00</published>
        <updated>2022-06-28T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/earthsea-cycle-note/"/>
        <id>https://ghost.livexia.xyz/earthsea-cycle-note/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/earthsea-cycle-note/">&lt;p&gt;June 22, 2022 地海巫师&lt;&#x2F;p&gt;
&lt;p&gt;人是无法逃避自己的恐惧，无法逃避过去的错误的，只有面对，然后意识到这也是自己的一部分，意识到自己是能够做出选择的，自己是能够控制这黑暗的。&lt;&#x2F;p&gt;
&lt;p&gt;June 23, 2022 地海古墓&lt;&#x2F;p&gt;
&lt;p&gt;光明和黑暗好像是存在着立场的，但是这互不相容的二者并非仅能简单的通过转换视角就能变化的，即使是在光明之中也有潜藏的黑暗，正如那影子，而黑暗之中好像也并非没有希望之光。身在黑暗的人追寻光明，是要比在光明之中寻找黑暗困难的，这样的选择意味着一切都可能会以对立的形式展现，这可能意味着自由，也可能意味着束缚，充满痛苦和艰难，并不是一路充满快乐的选择。&lt;&#x2F;p&gt;
&lt;p&gt;June 24, 2022 地海彼岸&lt;&#x2F;p&gt;
&lt;p&gt;死亡也是生命的一部分，如果没有死亡，那么生毫无意义，一切都好像是恒久不变，这是这本书的主旨，人们因为巫师无法永生，而追寻了一种虚假的永生。这个情节好像经常的出现，人类脆弱，不断的幻想不同的永生方法，有人设想和具有智力的星星融为一体，有人设想将意识上传，也就是放弃一些东西换取永生，这些方法好像都很厉害，可能也让人向往，可能融合后可以获得无穷的智力，可能上传后不再害怕身体的损坏，但是在这些设想里，人的个体性消失了，人成为了另一种东西，人被贡献了。在过去，人们曾经被渲染成为一种集体生物，予以一种美好的想象，但是在这个过程中，人总是发生了变化，个体的人被异化，在小说里，这样的人，失去了自我，不死不生，但是没有自我，现实里，人们失去了自己的人性，成为了动物。&lt;&#x2F;p&gt;
&lt;p&gt;June 25, 2022 地海孤儿&lt;&#x2F;p&gt;
&lt;p&gt;这一本好像是到目前为止最为日常的一本，但是我却最为喜欢，也最被吸引，睡觉的时候放不下，起床后放弃了手机上的社交网络。独居的女性，被虐待的女孩，失去力量的男性，三个社会的边缘人的故事。女性好像在社会里从来就没有力量，年幼的时候力量来自父亲，然后是丈夫，丈夫死去后就要依靠儿子了，这是社会的压迫。恬娜不断的思考，想要找到自己的力量，她一生经历一切，也曾有机会学习一切，她用自己的智慧保护瑟鲁，用自己的智慧保护格得，她有着男人没有的智慧，这就是她的力量。&lt;&#x2F;p&gt;
&lt;p&gt;June 27, 2022 地海故事集&lt;&#x2F;p&gt;
&lt;p&gt;作者的故事也从不过于复杂，默默的书写勇气，书写希望，之前的几本，作者可能凭借格得和其周围的人物来叙述，但是在这几个短篇中好像作者不必依靠格得了，作者笔下的那些不同的女人和男人，她们的相识和努力，好像都像是清风一般，缓缓的叙述一切，变化好似春风一般。的确是可以作为地海孤儿的后续的，不是什么狗尾续貂为了销量的作品，很值得一读。&lt;&#x2F;p&gt;
&lt;p&gt;June 28, 2022 地海奇风&lt;&#x2F;p&gt;
&lt;p&gt;死亡和黑暗不断的笼罩在这个世界，黑夜的黑暗好像并不令人恐惧，而法师的那个黑暗世界则令所有人恐惧，那个世界只有人，人的灵魂不生不灭，人类所有一切伟大的部分好像在其中毫无作用，包括爱和恨。平衡被打破了，死亡本应是生命的一部分，但是在那个地方死亡也被停滞了。前三部的确是自成一体，是冒险和成长的小说，而后面的三本则不同，好像是意有所指，讨论的是那些人类一直在探讨的问题，面对那些社会问题。现实社会并不玄幻，虽然有很多离奇而魔幻的事件，现实中的魔幻是和小说中的魔法不同的路径，魔法在小说中是一个真实存在的事物，好像魔法在现实并不存在，但是魔法也可以是人性的代表，人性的变化和奇诡，有何魔法有何不同呢？错误的魔法可能造成世界的灾难，而错误的人性只会造成比魔法更大的灾难，这在历史在当下都可以看见。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>癌症中的人 ——《癌症楼》读后感</title>
        <published>2022-06-20T00:00:00+00:00</published>
        <updated>2022-06-20T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/rakovyi-korpus-note/"/>
        <id>https://ghost.livexia.xyz/rakovyi-korpus-note/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/rakovyi-korpus-note/">&lt;p&gt;好像这并不是一个复杂的故事，一群身患绝症的人聚集到了癌症楼中，因为这样自己无法控制的原因，所以这群人有不同的背景，有不同的过去和未来，但是好像在现在他们都是一样的，都是病人，都面临着死亡的威胁。故事的背景是上个世纪五十年代的苏联，时值斯大林死后不久，意识形态的控制还处于一种惯性，这一段历史现在的维基百科中只有短短的一小段，但是在书里却很好的表现了这个时期的情况。&lt;&#x2F;p&gt;
&lt;p&gt;因为病房拥挤，病人数目众多，所以书里有很多人物，病人中有两个主要人物，经历过战争、劳改和流放的科斯托格洛托夫，以及从工厂里一步一步向上爬的人事官僚鲁萨诺夫。这两个人从入院第一天起就互看不顺眼了，科斯托格洛托夫看不惯鲁萨诺夫的官僚作态，而鲁萨诺夫则是看不惯科斯托格洛托夫的粗鲁和吓人的样貌。科斯托格洛托夫在读书时就被举报了，然后成为了政治团伙，于是流放天涯。鲁萨诺夫则通过各式各样的打小报告的方法，一步一步成为了一个官僚。二人的入院也有强烈的对比，科斯托格洛托夫是耍流氓似的住进了医院，而鲁萨诺夫则是走关系，对一切都不满意的入住了。&lt;&#x2F;p&gt;
&lt;p&gt;科斯托格洛托夫经历了很长时间的苦难，经历战争，因为一些错误的原因而成为政治犯，进入劳改营，而好像就要因为病痛而死去的时候，却又被流放，正当自己就要在流放地扎根的时候，病痛又开始折磨他，于是他只好为了自己的性命而来到癌症楼。经历过最初的痛苦，接受了放射治疗后，在医院里他好像重新开始意识到生命的美好，在结识女护士和女医生的过程中，他逐渐被她们所吸引，而二人也对他敞开了怀抱。在自己的身体逐渐变好的过程中，他也悄然的发现，社会环境好像也有变化，好像他的未来又有希望了，但是他却不敢完全拥抱这样的希望，害怕自己又落了空。在自己治疗的过程中，他的内心好像变的自由了，虽然自己身无一物，自己的未来好像依旧是那样的困苦，但是他的内心好像有些自由了，他重新学会了爱，虽然最后可能悄然错过，但是在结尾他的未来好像并不那么黑暗了。&lt;&#x2F;p&gt;
&lt;p&gt;鲁萨诺夫，这个人好像没有什么可以说的，最初他不相信自己可能死去，而自己生病这个现实越来越逼近他，他开始害怕。但是癌症好像不是他所害怕的，在得知那些他从前举报过的人有可能要回来的时候，他溃败了，这些人出现在他的梦境和幻觉里，但是他却不知道自己错了。在那个环境里生活，他成为了体制的一部分，他相信自己的的体制，他不觉得自己所写下的一封封密信是错误的，也没有意识到这样的密信可能给别人的生活有多么大的迫害。他不是傻子，他是叛徒。他背叛了自己的人性，虽然他凭借这样一种背叛，在人生的前半程可能生活顺利，但是他也不可能改变，不可能意识到自己的错误，也会被历史所碾压。&lt;&#x2F;p&gt;
&lt;p&gt;除了这两个主要的病人，还有很多的病人，这些病人来自不同的阶级，面对死亡好像有不同的态度，而面对医生也有不同的态度。当然除了病人，也有医生、护士和干杂活的。一切的人物在书中不断的行动、思考和谈话，构成了癌症楼的一切。这些人之间的谈话和思考，最后构成了一幅社会的图景。因为是在癌症楼，病人们总是能意识到自己是在生命的末期了，于是总是敢说一些真话，而想鲁萨诺夫这样的人，则也害怕死亡，而不再想要打小报告了，但是如果打小报告能让他不那么痛苦，我想肯定是会的。大体上应该是有四波人的，一波人是科斯托格洛托夫这样的，对当时的社会制度很不满，也就是几乎被社会所虐杀的人。然后就是鲁萨诺夫这样的，对社会制度及其认同，利用社会问题为自己增添福利，所想的是自己。一种就是那些真正有本事的医生这样的了，社会给他们压力，他们也面对社会的一系列的压迫，但是他们并不被社会所虐杀，他们做自己的事情，医生治病救人，青年地质学家瓦吉姆在自己生命最后的时刻还在学习，学生焦姆卡在医院中学习。最后就是一些普通人，他们生活，他们不谈论政治，不迫害其他人，自己也不努力，能够偷懒就偷懒。这一系列不同的人物，构成了癌症楼的所有成员，他们都在目睹生命走到最后时刻的可能场景，但是好像只有很少的人害怕癌症，他们害怕的是自己的生命被浪费了，过去的问题可能会要求现在的人付出代价。其实这一切早就在他们的生活，在社会中存在了，而癌症只不过是把这一切毫无隐藏的摆在他们面前。&lt;&#x2F;p&gt;
&lt;p&gt;读这本书之前，我并不知道作者是谁，生平如何，我猜想可能这是一本因为政治而获奖的书，但是读完之后我觉得自己完全的错了。的确，书中没有一个地方不是在指出那个社会环境中存在的问题和毒瘤，的确作者应当是在攻击那个时候的社会问题。但是社会问题固然可恶和令人痛恨，我觉得书中所体现的对人的关怀才是更加重要的部分，作者对科斯托格洛托夫的偏爱是可以看见的，而对无耻的鲁萨诺夫作者也不是没有同情心的，虽然最后鲁萨诺夫是怀着隐藏的阴影出院的，但是总是没有直接悲惨的死去。在那样的社会环境中，人的选择并不多，当然社会问题归根结底好像还是人的问题，但是作者还是在努力的想要相信人性，正如那个图书管理员舒卢宾，从一个农业大学教师，被迫害成为一个图书管理员，在社会的压迫下他选择了顺从，但是他的内心并不愉快，充满了挣扎和痛苦，我并不能简单的因为他在那样的环境里选择了听从当局而焚烧书籍，没有抗拒和斗争就咒骂他，我只有无比的同情。我们要相信，无论是多么黑暗的环境，人类的人性永远有善良的一面。&lt;&#x2F;p&gt;
&lt;p&gt;这次只能写这么多了，虽然自己很想谈论病痛和人的关系，想要谈论自己对病痛的恐惧，但是这些内容只有留待下一次再读了。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>消失的人 ——《荒野侦探》读后感</title>
        <published>2022-06-12T00:00:00+00:00</published>
        <updated>2022-06-12T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/los-detectives-salvajes-note/"/>
        <id>https://ghost.livexia.xyz/los-detectives-salvajes-note/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/los-detectives-salvajes-note/">&lt;p&gt;读的第二本波拉尼奥的书，前一本书是《2666》，读完这两本书我的感觉就是，我好像不知怎么的对不起这些书，可能是我读的太潦草了，没有把每个细节反复琢磨。《荒野侦探》由三个部分组成，第一个部分和第三个部分是一个青年学生的日记，第二个部分可能是对不同人物的访谈录，第一和第三部分时间跨度可能不超过三年，而第二个部分的时间跨度就达到了20年，第一和第三个部分的青年学生，没有在第二个部分中出现过，他在第二个部分消失了，在人们的口中消失了。&lt;&#x2F;p&gt;
&lt;p&gt;第一个部分青年学生放弃学习法律，选择了诗歌的道路，结识了两个本能现实主义者，成为了这个团体中的一个成员，青年学生是马德罗，两个本能现实主义诗人是贝拉诺和利马。在第一个部分马德罗爱上一个女孩，玛丽亚·芬特，但是最后却搞砸了这段关系，他太年轻了。在新年的午夜，为了帮助一个女孩，马德罗、贝拉诺、利马和鲁佩逃出墨西哥城，第一个部分就结束了。在第一个部分中，本能现实主义的团体，从小变大，由从大变小，贝拉诺和利马在追寻上一代的本能现实主义诗人蒂纳赫罗。诗人混乱而不稳定的生活也是第一个部分的重点内容，复杂的爱情关系，混乱的性交，都是第一部分的重点内容。&lt;&#x2F;p&gt;
&lt;p&gt;第二个部分好像跳过了贝诺拉和利马出逃之后的一段时间，不断的通过访谈录的形式说明二人的旅程，二人取得蒂纳赫罗唯一发表的诗，二人在世界各地的旅途。和出逃前不同，二人好像不再发表诗集，他们好像在不断的寻找生活，体验生活。第二个部分非常多，很多看似没有关联的事件，最后总是描绘出二人的生活状况。各色人物的访谈，总是指向贝诺拉和利马，从侧面描绘出二人的旅程。在这个部分，马德罗和佩鲁从来没有出现，阅读过程中不断的期待马德罗的现身，不断的等待四人出逃墨西哥城之后的事情，但是马德罗没有出现过一次，只有到最后的部分，在访谈一个研究本能现实主义者的人的时候，提问的的人问起了马德罗，但是没有答案。&lt;&#x2F;p&gt;
&lt;p&gt;第三个部分又回到马德罗的日记，时间线是和第一部分紧密相连的，四人逃出墨西哥城，一路躲避皮条客，一路继续寻找本能现实主义诗人蒂纳赫罗。终于找到蒂纳赫罗的时候，皮条客也出现了，贝诺拉和利马杀死了皮条客，但是蒂纳赫罗在过程中也死去，就此贝诺拉、利马二人于马德罗、佩鲁二人分道扬镳。全书以马德罗的一首诗结尾。&lt;&#x2F;p&gt;
&lt;p&gt;这本书对我来说有两个最大的问题，第一个是本能现实主义是什么，第二个就是马德罗和佩鲁后来怎么了。本能就是只天性，人的天性，肚子饿了就要吃饭，被异性吸引就想做爱，这就是本能。现实主义我想就是不在乎理想，现实生活才是重点。我想可能本能现实主义就是跟随本能生活，不追求伟大的理想。书中，我觉的有两首诗是本能现实主义诗歌的，第一首就是蒂纳赫罗的《锡安》，诗的内容在Kindle的电子书里都没有，我找到盗版的电子书才看到这首诗，这首诗有三个部分的图形，第一个部分是直线和一个方块，第二部分是波浪线和一个方块，最后的部分是折线和一个方块。为什么这是本能现实主义呢？看到这三个图像，我首先想到的就是不同情况下一艘船航行在大海上，直线、波浪和折线代表了平静、海浪和风暴的三种大海的状态，然后方块就是一艘船，这是一种本能的感觉。我觉得就像是火柴人，虽然火柴人不是细致的人，但是看见火柴人就知道那是一个人。然后是书最后的马德罗的诗，这首诗也应证了我的最后的猜测，那就是马德罗成为了真正的本能现实主义诗人，这也和马德罗为什么消失有关。&lt;&#x2F;p&gt;
&lt;p&gt;在四人找到蒂纳赫罗的时候，蒂纳赫罗也死去了，贝诺拉和利马意识到了自己的错误，他们走错了路，他们的追寻导致了蒂纳赫罗的死亡，而这样的寻找不是本能现实主义的道路，他们在追寻一个目标，一个理想人物，他们忘记了体验生活。这也是为什么在第二个部分中二人与第一个部分中二人的行为完全不同，他们不再沉迷于诗歌的争辩，不再沉迷于酒精、性爱和大麻，这些东西在第二个部分好像对他们都不重要了。在四人逃离和追寻的路上，马德罗给大家出了一个谜题，马德罗画图给四人猜测图中是什么，画的风格就和蒂纳赫罗的诗很像，这是征兆。马德罗想要找到蒂纳赫罗的欲并不强烈，他想要面对现实生活，他想要生活。在蒂纳赫罗死后，他和鲁佩回到蒂纳赫罗的小屋生活，消失在之前人的生活中，他也在最后写出了属于自己的本能现实主义诗歌。&lt;&#x2F;p&gt;
&lt;p&gt;第二个部分，我觉得是本能现实主义新的追随者追寻第二代本能现实主义的记录，主要寻找的就是贝诺拉和利马，就好像第四个部分他们追寻蒂纳赫罗一样。我想马德罗的消失是贝诺了和利马刻意为之，他们不告诉那些伙伴和朋友马德罗和鲁佩的去处，他们可能也隐约的意识到马德罗成为了新的本能现实主义诗人，成为了新的蒂纳赫罗。让马德罗消失，可能也是为了防止马德罗和蒂纳赫罗一样被找到后死去。这个说法当然有很多对不上的，但是我想可能这是一种解答吧。&lt;&#x2F;p&gt;
&lt;p&gt;荒野侦探，荒野并不难理解，但是侦探是什么呢？我想就是在追寻自我、生活吧，在荒野中流浪、生活，成为一个侦探，找到自己的路。昨天晚上读完，今天晚上才坐下来写下这些内容，这本书需要时间沉淀，我仅仅是简单的读了一次，我想必然是需要再读一次的。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>生活的刀锋 ——《刀锋》读后感</title>
        <published>2022-05-29T00:00:00+00:00</published>
        <updated>2022-05-29T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/the-razor-s-edge-note/"/>
        <id>https://ghost.livexia.xyz/the-razor-s-edge-note/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/the-razor-s-edge-note/">&lt;p&gt;刀锋并不是一个多么特殊的故事，一个人走上了离经叛道之路，而其他人物最后所求的都有了好结局。故事是由作者讲述的，作者不仅出现在书外，也在书里，作者就像是在写侦探小说，他自己就是侦探，将各个部分的故事串联起来，然后呈现在读者面前。拉里经历了战争，放弃了看似美好的生活，选择追求精神世界，游历异国，最后决定抛弃一切，在最普通的生活中实践自己。&lt;&#x2F;p&gt;
&lt;p&gt;拉里年幼就丧失了自己的父母，和社会的连结就是一些朋友和赡养人，他对这些人都没有责任，所以他可以追求一种自由。如果说精神上没有责任，那么他从小继承的财产，就让他避免了需要忧患生活。拉里的形象是很圣洁的，他对物质的态度是可有可无的，性格洒脱而随性，有点像中国老子的门徒。&lt;&#x2F;p&gt;
&lt;p&gt;拉里是不信教的，但是他其实充满了一种宗教气息。我也不相信宗教，我不相信任何一种意识形态，因为只有行为才能代表现实，我想这可能是和宗教的本意最为契合的，宗教的创造是为了让人们信仰，这就充满了矛盾。我不信教，是因为这些宗教充满了恶，并不是因为这些教义上存在恶，例如没事念一下《心经》是有好处的，但是这些教义，在一种广泛的实践中就存在恶，一种心灵上的追求，如何能够在一个世俗的组织中有所收获呢？&lt;&#x2F;p&gt;
&lt;p&gt;伊莎贝尔也是一个主要人物，她本是拉里的未婚妻，内心深处想要占有拉里。因为自己的背景，她接受母亲和舅舅的教育，所以她的人生目标是幸福美满，是拥有财富，是希望能够在身体和精神上拥有满足。很明显这和拉里的追求是不一样的，虽然他们和平的解除了婚约，但是二人却搅和不清。拉里虽然希望伊莎贝尔能忍受生活的寂寞，牺牲她对未来的考量，但是却也安静的离开。伊莎贝尔面对拉里好像要做出看似错误的选择的时候，却考量了她人的人性，做了一回上帝，于是拉里唯一的结婚对象抛弃了拉里，最后痛苦死去。她的占有欲，在她拥有了美好的生活，失去再拥有之后好像也没有减少。&lt;&#x2F;p&gt;
&lt;p&gt;还有一个非常重要的人物是艾略特，是伊莎贝尔的舅舅，他醉心于社交界，他追逐一种奢华不平等的人生。他的人生完全沉浸在一种物欲中，而且他也坚信这是唯一的道路，那么多伟大的作品，在他那里只是一个背景板，是一件装饰物，正如拉里所说的，贝多芬在创作乐曲的时候，必然不是为了讨好那伟大的存在，而艾略特的一生好像都在讨好，讨好伟大的主，讨好社交界的名流。他死去的时候，有一些悲剧色彩，但是最后在宗教极大的荣光中安息。作者描写艾略特最后弥留的场景让我想起《安娜·卡列尼娜》中列文哥哥死去的场景，其实毫不相干，但是我也意识到，一个人死去的时候，大都是相仿的。除了艾略特死去的场景，书中也提到了拉里前战友死去的场景，大致是这个人死的这么彻底，好像没有活过。死亡我想永远不是缓慢进行的，即使有最后一口气，也还是活着，突然间，这个人消失了，只剩下躯壳。&lt;&#x2F;p&gt;
&lt;p&gt;各色人物，他们的选择，他们的人生，如果要说这些人生是好是坏是很难的。不同的人追寻自己不同的生活，谁能说拉里追求的精神绝对，就比艾略特追求的物质奢华高尚呢？人生只是不同，每一段人生都展现出不同的色彩。我想有很多人会追求拉里的人生，但是这其实是极难的，拉里逐渐的去我，这很难，极其少数的人才有可能做的到。大多数人的生活在这两个极端中间摇摆，努力在物质生活中寻找出路的时候，偶尔望一眼天上的星星，希望那远古就死去的星光能增加一丝灵性。&lt;&#x2F;p&gt;
&lt;p&gt;拉里从对追问恶而开始，而当他和毛姆在咖啡店深夜交谈的时候，他仍然没有找到最初问题的答案。印度哲学追求一种出世，跳出轮回，而拉里最后确认为轮回才是绝对，他不想跳出轮回。我看到了尼采的身影，如果一切的恶，没有来源，没有终结，当善出现的时候，恶也在萌生，这样的生活，好像一切都是虚无，如果人注定轮回，而这些痛苦无法解答，那么生活是必要的吗？拉里在印度学到的哲学，并不是说算了吧，并不是一种放弃，出世并不是放弃，期望在每一个轮回中面对生活，面对这一切的善与恶，然后找到绝对，然后跳出轮回，这是印度的方法。拉里最后说他并不想跳出轮回，他想要生活，看起来好像和印度的方法一样，但是我总觉得不同。前一种方法好像还有着希望，这种希望好像和天主教没有差别，而后一种我觉得更像是尼采的哲学。一种充满了悲剧，但是却又无比乐观的哲学。&lt;&#x2F;p&gt;
&lt;p&gt;拉里经历了战争，目睹了战友的死亡，经历了悲剧。我们现在的生活安定，我还年轻，至少在我生活的地方，环境很安全，那么我不能经历拉里一样的悲剧。我的悲剧就只是分手，过去的一年半，这样的事情真的可以称得上是悲剧吗？我有的时候就在想，我是不是太自大了，我所经历的只不过是大部分人都可能经历的事情，虽然这个问题我自觉已经弥合，但是我却同拉里一样，不断的问自己，人生的意义是什么？这是一个很危险的问题，大部分人选择伊莎贝尔的生活可能会更加好。人生怎么过是一个很难的问题，而这个问题实际上是随着对这个问题的追逐越来越困难的，我觉得这个问题实际上就是刀锋，如果一个人为了打猎，那么刀锋很简单，用就是了，生活也是如此，根本不必想这么多，好好活吧，而如果一个人问为什么要用刀，为什么有刀锋，为什么要打猎，那么这个问题就复杂了起来，思考的太多生活好像静止不前，我要像拉里学习，无论是什么，除了思考，还要行动。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>人性的末日 ——《2666》读后感</title>
        <published>2022-05-25T00:00:00+00:00</published>
        <updated>2022-05-25T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/2666-note/"/>
        <id>https://ghost.livexia.xyz/2666-note/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/2666-note/">&lt;p&gt;这本书及其厚重，如果有人入室抢劫，想必可以用作防身，看了一下手上这个版本，是2013年印刷的版本，我可能是在2014年买的，那一年我高二，时间已经过去八年，我毕业，然后懵懵懂懂的工作，然后年少轻狂的辞职，最后浑浑噩噩的躲在家里读书。放的时间太久了，书页都有脱落的节奏了，而且这本书太厚重了，于是我不顾自己的经济状况，仍然是重新买了一本电子书，好在是老书，便宜。花了差不多一个月的时间，终于读完，中途多少次我想从头开始，不知道是从豆瓣还是哪里看到的评价，说这本书语言流畅，我想这大概不是真的，从第四部分开始，电子书就有一些错误，我想校对的人大概也是有点疲了，好在我有一本实体书，错误也并不严重，并不影响阅读，有一个有意思的地方，电子书有一处少了内容，我翻看实体书，没想到实体书在一模一样的位置，两页书没有裁开。虽然读完了，但是这本书必然是要重读的。&lt;&#x2F;p&gt;
&lt;p&gt;这本书有五个部分，每个部分看似毫无关联，但是却又在各个细小的地方存在连结。第一部分是四个文学评论家因为共同研究以为德国作家而结识，最后在墨西哥结束的故事。第二部分讲述一个在墨西哥慢慢发疯的教授的故事。第三个部分讲述一个美国记者去往墨西哥报道拳击赛，随后了解到这个城市所发生的悲剧，最后仓皇逃离的故事。第四个部分则是说明每一起发生在这座墨西哥城市的杀害妇女案件的记录。第五个部分则是那个德国作家的一生，最后这个德国作家去到墨西哥城市的故事。&lt;&#x2F;p&gt;
&lt;p&gt;第一个部分是最熟悉的，多年来每次拿起这本书，总是读了几页这个部分然后放弃，多年以前，文字还只是文字，所以文学评论家的故事一点也不吸引人，这个部分的悬念是德国作家阿琴波尔迪，四个人之间的关系不断变化和交织，终于在尾声故事开始变得奇怪了，四人前往墨西哥小城寻找作家，这个时候一个阴暗而恐怖的背景慢慢的展开了，在这个城市里，存在令人难以相信的恶行。故事好像从一个都市爱情故事，转变成为了一个让人也不能寐的恐怖故事。第二个部分的主角则是在第一个部分中出现过作为四个文学评论家的向导的墨西哥教授，教授逐渐陷入疯狂，痛苦的过去，压抑的现实，这个故事越来越压抑。&lt;&#x2F;p&gt;
&lt;p&gt;第三个部分好像出现了一个英雄，一个黑人记者，机缘巧合之下来到墨西哥报道一场拳击比赛，他遇到了第二个部分主人公的女儿，他也了解到在这个城市发生的残忍杀害妇女的案件，虽然他想进行报道，但是却受到了阻扰。他是一个英雄式的人物，闯入陌生而敌对的领域，拯救一个公主，但是这个英雄好像和所有的英雄一样，最后还是只能带着公主逃跑。&lt;&#x2F;p&gt;
&lt;p&gt;第四个部分对我来说是最为压抑的部分，这个部分读了可能两周时间，类似于档案记录的表达手法，期间穿插着各种故事，档案记录了在这座墨西哥城市中发生的一系列杀害妇女案件，每一个案件都很简短，说明必要内容。穿插的各种故事则是那些为了制止这一系列杀害妇女案件而徒劳无功的人们。阅读这个部分，每当看见那些站出来的人，走出好像有成效的努力，但最后却被环境吞噬，这是极为痛苦的，一切都让人压抑，但是还是会幻想能够找到做出这一切恶行的幕后黑手。&lt;&#x2F;p&gt;
&lt;p&gt;抱着能够找到凶手的目的，开始阅读第五部分，但是这个部分又从头开始了，讲述第一部分的悬念人物，阿琴波尔迪的人生。他出生于一战的末尾，然后参加二战，作为德国人，他很自然的成为了德国军人，于是见到了战争的残酷。在一次休假中，他发现了一个苏联作者的笔记，他见到了苏联的残酷。在战败投降之后，在战俘营里，他又听闻了屠犹的残酷，实施了人生的第一次杀人行为。回归自由之后，开始写作，遇见了愿意出版他作品的出版社社长，他成为了阿琴波尔迪。最后他的妹妹找到了他，请求他能够解救妹妹的儿子，那个在第三部分、第四部分都出现的那个被视为是需要为墨西哥小城惨案负责的凶手。他前往墨西哥小城，看看那里发生的事情。没有找到凶手，全书结束了。&lt;&#x2F;p&gt;
&lt;p&gt;那么究竟是谁在墨西哥小城犯下那么多的罪行呢？直到读完我都不明白，但是现在重新回顾了这一本书，我想我有些明白了。犯下这些罪行的，可能是某一个，或者某一些人，凶手很有可能是找不到的，因为这个凶手实际上和犯下屠犹罪行，和犯下任何罪行的人一样，很可能就是一个普通人。在第五部分中，阿琴波尔迪在战俘营中，有一个熟人，这个熟人最初以完全不同的名字展现在他的面前，可能和阿琴波尔迪一样，就是一个参加了战争的军人而已，虽然生活的一切都被毁灭了，但是好像未来还有盼头。直到审核逐渐加强，熟人逐渐崩溃了，他向阿琴波尔迪透露了自己屠犹的罪行，一种极其冷峻的手法讲述了极其残忍的事件。参与屠杀的人都是普通人，最后甚至还有少年，熟人可以把这个行为归罪于领导，警察、村长和少年可以把这个罪行归罪于熟人。他们在屠杀中是痛苦、不自然的，但是他们没有改变，也就是说在那个时刻，他们接受了这样的命运，接受了自己的罪行。并不是他们想要杀害这些人，他们是人性的受害者，他们被人性恶的部分所吞噬。在墨西哥小城，那些人性中仍有善的部分的人，是痛苦扭曲的，他们被人性的恶所压制，这样的人是少数，更多的是恶人，这些人看待人命潦草了事，甚至同流合污。人性中恶的部分做出了这些残忍的事件，屠犹中的执行者最后都浑浑噩噩，但是在墨西哥小城中，人们在监狱里还能保有一定的正常生活，这些人对恶已经习以为常，他们不再害怕恶，而是与恶同行。&lt;&#x2F;p&gt;
&lt;p&gt;2666这个书名从来没有出现在书中，看完译者写的，我想可能是作者的一种预言，预言人类的灭亡，可能是在2666年吧。虽然世界整体和平，但是世界充满了各种各样的苦痛。三个月前，发生了一场战争，但是各种声音充满了对立，大家都选择不看一些东西。在写下这个东西的时候，美国一所学校又发生了枪击事件，学校中充满了弱小的人类，有人选择在这样的地方释放自己的恶魔，这是怎样的行为，而人们还在争论。有多少事情，不能讨论，人类之间充满了矛盾，人性的恶不断的发生冲突，人们即使在什么是恶上都没有统一的看法。借用书里的一句话“由于他不能讲话，也就没提任何问题；”，在第五部分，阿琴波尔迪负伤休假，他喉咙受伤，所以无法对休假村子里犹太人的去处进行提问。虽然他负伤了，但是当他恢复的时候，他也没有提问。人性的恶正在注视着他，并不是因为不能讲话而无法提问，而是他早就清楚了问题是什么。在他少年的时候，他热爱大海，曾经想要在海中死去，我想这就是他的答案，这是答案，但并不是出路，此后的人生皆是在救赎。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>继续生活 ——《柏青哥》读后感</title>
        <published>2022-04-30T00:00:00+00:00</published>
        <updated>2022-04-30T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/pachinko-note/"/>
        <id>https://ghost.livexia.xyz/pachinko-note/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/pachinko-note/">&lt;p&gt;很久以前这本书就在我的收藏夹里了，但是一直没有买来读，直到最近我看见这本书改编的美剧在播出了，我才终于决定下一本书就是这本了。这本书开始很慢热，但是读到后面却无法自拔。&lt;&#x2F;p&gt;
&lt;p&gt;这本书的时间线从20世纪初到世纪末，80年的时间跨度，一个朝鲜家庭从朝鲜美丽的小岛，到日本大阪贫穷混乱的贫民窟，在历史的漩涡中，这个家庭经历苦难，在夹缝中生存。这本书是一个故事，这个故事没有那种伟大的道理，一切好像都很艰难，任何的努力好像都无法改变环境和环境的歧视。&lt;&#x2F;p&gt;
&lt;p&gt;我一直以为柏青哥是一个人的名字，直到我发现这是一种赌博游戏。在日本的朝鲜人有两种，一种是没有钱的，一种是有钱的，而有钱的这种往往就是和柏青哥有关系，这是一种日本社会的歧视，就好像所有生活在西方的亚洲人都善于数学一样。但是很讽刺的是，好像现实就是这样，顺子的两个儿子都开始从事柏青哥，而摩西的儿子，从美国回来的金融学生，摩西想要培养所罗成为一个在投行的精英，但是最后所罗还是回到了柏青哥。日本人歧视居住在日本的朝鲜人，鄙视他们的落后和不堪，看不起朝鲜人无法找到正经的工作，实际上这不正是日本人的问题吗？一边不在正经工作中招聘朝鲜人，一边又因为朝鲜人找不到正经工作而厌恶他们，这种歧视和朝鲜人什么关系都没有，这是日本人自己的问题。&lt;&#x2F;p&gt;
&lt;p&gt;那是一个很复杂的时代，不是我们现在那些选择去北上广漂泊的时代，那个时代的在日本的朝鲜人，从被日本人统治，朝鲜人被视为贱民，即使在日本战败后，朝鲜人还是不断的被歧视。流落到日本的朝鲜人，实际上是难民，居住在贫民窟，甚至要和牲畜一同入睡，原是朝鲜贵族的群体，只能做最苦累的活，拿最少的钱。战争结束前，朝鲜人会因为一些及其简单的事情而身陷囹圄，战争后，即使朝鲜人也是受害者，但是仍要不断的受到体制和社会的歧视。顺子的两个儿子，诺亚和摩西，诺亚是高汉秀的儿子，摩西则是白伊萨的儿子，诺亚从小起就决定要成为一个日本人，而摩西则从小就决定不在乎自己是否是朝鲜人了。&lt;&#x2F;p&gt;
&lt;p&gt;诺亚意识到自己是高汉秀的儿子的时候，他所坚持的成为日本人的理想破灭了，于是他逃离了，他想从那个肮脏的朝鲜生活中逃离，但是他却去了一个柏青哥老板手下打工。那个老板不招收外国人，但是所有人都隐隐的知道他是外国人，他的老板，他的岳母，他们都觉得只要别人不知道，就无所谓。诺亚好像从过去的生活逃离了，他甚至有了日本国籍，但是他还是不断的给母亲寄钱，每个月还去白伊萨的墓前。诺亚肯定也很愧疚，远离母亲，远离家人，我想这也是为什么他还会每个月去白伊萨的墓前，但是那是一种矛盾，自己的人生信念和现实的冲突，如果不逃避，他会灭亡，本能的求生欲让他逃离了。当他进行着常规的生活，拥有美好的家庭的生活，母亲突然出现，他通过逃避所构建的现实崩塌了，他没有办法继续逃避了，他也没有办法继续生活了，那么只有一种选择了。&lt;&#x2F;p&gt;
&lt;p&gt;摩西和诺亚不同，摩西很小的时候就意识到自己不会学习，而在学校期间他也不在乎自己是不是朝鲜人，拳头更加能够说明问题。他被生活锻造，他有简单的原则，不做坏事，赚钱养家，给母亲和祖母买一幢房子，让自己的孩子能够更加有尊严的生活。摩西辍学开始在柏青哥店打工，工作、恋爱和生活，这是他的一切，他不关心也不在乎自己是不是朝鲜人，他有一个日本朋友，这个朋友也不关心他是不是朝鲜人。&lt;&#x2F;p&gt;
&lt;p&gt;所罗是这个家庭里最新的一代，所罗没有经历过战争，他的生活是富足的，拥有良好的教育，出国接受精英教育。回国后所罗进入外资的日本投行，这个投行好像非常开放，大家看似都不在乎他的朝鲜人背景，但是隐隐的，好像这个朝鲜背景还是让他和同事们有隔阂。所罗看似和老板的关系良好，老板好像是他的尤达大师，所罗就是那个绝地武士，但是在一桩生意里，所罗被老板利用了，利用完所罗就被老板丢弃了，所罗的朝鲜人背景又暴露了出来，本应该是精英的罗门被歧视了。罗门被辞退后，在继母的女儿也是他的第一任女友花子的病床前，花子告诉了他一个真理：没有人是干净的，生活让你变脏。罗门决定回家接手父亲的生意。现实正是如此，历史上的日本，罗门被辞退的时候，正是日本经济泡沫的高点，正如花子说的，金融界并没有比柏青哥光鲜亮丽多少。&lt;&#x2F;p&gt;
&lt;p&gt;这是一本很复杂的书，充满了各种各样复杂的故事，每个故事都有不一样的结局，每个不同的人生都被展示出来，即使故事里的时代已经过去了很长时间，但是这些故事仍然能让我感同身受。民族是有意义的，民族带给我们生活方式和饮食习惯，但是民族是一个抽象概念，民族实际上是不在乎个体的，个体是被忽略的。多少人被民族困住，在日本的朝鲜中学生，被日本同学欺凌而自杀，诺亚意识到自己逃离不了朝鲜民族而饮弹自尽，他们都被民族困住了。我是民族的一部分，民族是我的一部分，但是民族不是我的全部，民族可能会辜负我，但是我还是要生活。&lt;&#x2F;p&gt;
&lt;p&gt;自从读完《一个青年艺术家的画像》，我就开始注意书里面的语言。有三种语言不断的出现在这本书里，朝鲜语、日语和英语，朝鲜语作为最为低下的语言，战争结束前日语是最重要的语言，战争结束后英语则成为了通向成功的语言。从小生活在美国的罗门的女朋友不会说日语，会说韩语和英语，但是从小生活在日本的罗门却只会一点点韩语，语言是一个民族的血脉，语言在冲突中成为了第一个受害者。&lt;&#x2F;p&gt;
&lt;p&gt;不知道自己写了什么，没有头绪没有条理，不代表这本书不好，我没有办法给这些人生故事梳理一条线，我只知道，无论情况多么糟糕，无论我多么不好，我需要继续生活。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>《那不勒斯四部曲》读后感</title>
        <published>2022-04-18T00:00:00+00:00</published>
        <updated>2022-04-18T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/neapolitan-novels-note/"/>
        <id>https://ghost.livexia.xyz/neapolitan-novels-note/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/neapolitan-novels-note/">&lt;p&gt;这是一个故事非常连贯的系列，所以统一放在一起进行记录，全部读完可能会有更加充分的记录。读完了最后一本，很多整本书的内容都写在了最后，前面三本的评论大都关于我对这些书的思考，而最后一本则关注在了具体内容，严重涉及剧透内容。这是一套让我五味杂陈的书，读来并不开心，有的时候很难受，有的时候让自己思考自己的人生和选择，但是读完最后自己是平静的。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wo-de-tian-cai-nu-you&quot;&gt;《我的天才女友》&lt;&#x2F;h2&gt;
&lt;p&gt;April 11, 2022&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ren-sheng-de-mei-li&quot;&gt;人生的魅力&lt;&#x2F;h3&gt;
&lt;p&gt;这是一个人叙述的故事，看到一半的时候我在想后面会不会有其他人的视角，但是等我看到后半部分，才发现叙述者的名字和作者的名字是多么的相似，而等我发现第二本是《新名字的故事》的时候，我才意识到很可能这个故事就会是一个人讲述的了。&lt;&#x2F;p&gt;
&lt;p&gt;故事中的那不勒有点像父母口中的生活，只不过父母他们持续的时间更久，更少人能逃离他们的人生。两个少女莉拉和埃莱娜的故事，生活在一个破败的社区，她们在学校中互相竞争互相帮助，她们的人生不知不觉的向不同的方向发展。&lt;&#x2F;p&gt;
&lt;p&gt;很多豆瓣的评论在说这本书讲述了一个没有关联、没有意义和太多女性视角的故事，所以并不是一本好书。的确这个故事和我的关联并不大，而没有意义这件事情在我看来根本不是问题，我觉得女性视角是这本书最大的亮点。虽然这本书和我的关联不大，但是我却从这个故事中看见了父母的身影，好像揭示了一种我从未了解过的她们的“从前”。父母们“从前”的故事我想是无法简单的用没有钱来说清楚的，那一个个成为泥瓦匠、修车师、鞋匠和肉铺老板的年轻人，不就是父母们吗？在法律不允许的年龄，成家立业养育后代，这不正是父母吗？&lt;&#x2F;p&gt;
&lt;p&gt;每一个选择都导致了人生路径的分裂，而女性视角则让这些选择更加真实。这并不是一个充满了跌宕起伏的故事，每个人物做着各自的选择，进行各自的改变，正是这种由选择而确定的人生路径让这本书具有吸引力。看似完美的选择，在未来会产生想象的结果吗，看似错误的选择是否真的会破坏人生呢，还是说选择根本就不应该用好坏来评价呢。这一点让我非常着迷，选择是无意义的吗，这种无意义是昭示了一种无限的人生还是一种绝望的人生呢？&lt;&#x2F;p&gt;
&lt;p&gt;每一本小说都让我思考这个问题，但是我却不敢进行解答，我无法进行解答，我只是在思考。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;xin-ming-zi-de-gu-shi&quot;&gt;《新名字的故事》&lt;&#x2F;h2&gt;
&lt;p&gt;还没读完，系列第二本，这不是那种开心的书，就好像吃药一样。可以感受到那种痛苦，充满了矛盾的选择，即使是在读的时候也让我很矛盾，甚至于我想放弃。我无法预测到可能的情节，无论这个故事的结局如何，这是一段艰辛的过程，这么轻易的窥视一段人生，让我觉得自己配不上这本书。&lt;&#x2F;p&gt;
&lt;p&gt;那不勒斯四部曲真的对我影响很大，梦境都是书里的情节。&lt;&#x2F;p&gt;
&lt;p&gt;April 13, 2022&lt;&#x2F;p&gt;
&lt;h3 id=&quot;wen-zi-de-li-liang&quot;&gt;文字的力量&lt;&#x2F;h3&gt;
&lt;p&gt;这是一本很有力量和很难读的书，不是那种难懂，而是那种充满艰难的书，还没读完这本书的时候，我就感觉自己一边在读这本书，一边这本书再给我喂药片。我无法预测到可能的情节，无论人物是否过上了美好的人生，这都是一段艰辛的过程，而这么轻易的阅读，让我觉得自己配不上这本书。&lt;&#x2F;p&gt;
&lt;p&gt;晚上睡觉的时候，书里那些事件都重新出现在我的梦境里，那些我的恐惧，书中的恐惧混杂在一起。这本书太重要了，自己因为这本书而开始流泪的时候，头也开始疼痛，我想是这本书太重要了，如果生命结束在我读完这个系列前那也太可惜了。&lt;&#x2F;p&gt;
&lt;p&gt;这本书真正的向我展示了语言和文字的力量，这种力量让我向往文字，连我脑海里的思考方式都开始遵循着书中的语言。读第一本的时候，那些批评的声音，还想让我进行辩解，但是读完第二本，我觉得这种辩解完全是不必要的，它们没有力量。&lt;&#x2F;p&gt;
&lt;p&gt;写不了太多，我也写不出那种令人信服的赞美，而且我还需要继续阅读，期待完成这个系列自己有怎么样的思考。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;chi-kai-de-liu-xia-de&quot;&gt;《离开的，留下的》&lt;&#x2F;h2&gt;
&lt;p&gt;这本书看的慢，一方面是因为我自己的拖延，另一方面我也意识到真的内容开始让我难受了，拥有上帝视角的我看这本书很难受，看到莱娜和尼诺半夜在自己家中睡到一起的时候，我非常的难受，我很生气，我甚至想把手机扔到墙上。&lt;&#x2F;p&gt;
&lt;p&gt;即使在读完第三本那不勒斯四部曲之后，如果是往常的我，我会打开一个视频，但是今天晚上我却完全不想，即使是这种令人难受的感觉，我也不想通过轻易的方式把这种感觉冲走，这种难受的感觉，让我觉得不应该浪费自己的时间，我不能把自己的时间浪费在没有意义的短视频里，如果那样我不如坐着不动，让自己的脑子思考，让自己的脑子难受。&lt;&#x2F;p&gt;
&lt;p&gt;April 16, 2022&lt;&#x2F;p&gt;
&lt;h3 id=&quot;cui-ruo-de-zi-wo&quot;&gt;脆弱的自我&lt;&#x2F;h3&gt;
&lt;p&gt;这本书的开头，女主凭借自己的成功和丈夫家庭的关系，拯救了莉拉，但是在结尾女主却抛弃了自己的生活，追寻心中的爱情。女主的成功是巨大的，第一本书就能够出版并且成为畅销书。婚后的生活，女主疲惫不堪的应对一切生活的琐事，自己的事业陷入了一个停滞期。在这个时候，莱娜一直暗恋的人出现了，尼诺好像将莱娜从这一切中拯救出来。莉拉的人生好像成了这本书的配角，莉拉在工厂的不公，在斗争中受到挤压的莉拉，尔后被莱娜所扭转的生活，莉拉的生活开始趋于平淡。&lt;&#x2F;p&gt;
&lt;p&gt;在写下这些内容的生活，我才想到莱娜的人生仍旧是追寻着莉拉，对孩子态度的变化， 对周围人对态度，对爱情的投入和付出。莱娜意识到自己的人生和莉拉的人生存在着一种拉扯，她想摆脱莉拉对她的影响，她想审视自己的人生，但是她最终还是陷入了一样的选择。莱娜在这个时候，她的导师都不见了，年少时的老师，她不再畏惧那些选择，这是成长，但是也意味着她的选择终于成为了自己的选择，她也将为自己的选择付出代价。&lt;&#x2F;p&gt;
&lt;p&gt;莱娜读了如此多的书，她也开始学会思考，但是这个思考还没有能够改变她。彼得罗、米凯莱和莉拉，他们有一种行事方式，他们按照自己的意愿行事，他们是那种难以受到周围人影响的人，他们的思考和行为是密切相关的。莱娜追求的是一种影响，她追求周围人的影响，她希望大姑子能给她影响，她希望莉拉能给她影响，她追求他人的思考，她意识不到自己的价值。成功的第一本书，没有让她认同自己，她将书的核心归功于莉拉，将书的成功归功于婆婆，这本书好像成为了她的耻辱。&lt;&#x2F;p&gt;
&lt;p&gt;莉拉和卡拉奇看似成功的婚姻，在新婚之夜就被打破。一次次对自己的否定，莉拉的否定，妹妹和自己所厌恶的人相恋，莱娜的成功也那么的脆弱。如果说莉拉和尼诺的相爱是一种斗争相爱，莱娜和尼诺的爱我看不到莱娜对丈夫的斗争，莱娜陷入的是自己的陷阱，莉拉和莱娜对与尼诺的爱恋并不是她们生活的答案，但是这种爱恋好像都给她们一种动力，一种脱离自己不满意生活的动力，她们满怀热情的期待，期待这能给生命开出新的道路。&lt;&#x2F;p&gt;
&lt;p&gt;尼诺并不像我们现在说的那种渣男，我觉得他的爱恋还是真实的，但这是激情的爱恋，他不顾后果的抛弃一切，无论是相爱还是不爱，相爱时越激情，逃离时留下的痛苦也就越多。这种激情的爱恋，也是尼诺逃离现有生活的一种方式，只不过这种方式对他的伤害少，而他能不断的寻找到热爱自己的人。尼诺对爱情的追求，越来越像他父亲了，他的行事也越来越像他父亲，而他也越来越谅解他父亲。他对爱情的追求，也不再那么义无反顾，在和莱娜出走时，他开始有顾虑了。尼诺最后必然会成为他父亲，在看到尼诺和莱娜两个女儿的相处，我就不禁想到尼诺父亲和莱娜的相处，让我不寒而栗。莱娜从一个混乱复杂的环境中成长，但是她却没有意识到这些混乱复杂并不是仅限于自己的，她没有意识到自己的孩子也会受到这一切的影响，正如她虽然远离了那混乱的街区，但是她和街区的联系，仍旧影响着她的生活。&lt;&#x2F;p&gt;
&lt;p&gt;在读完这本书的晚上，看到莱娜和尼诺出走的时候，非常的难受，我期望看到莱娜的自我成长，看到莱娜说自己要走自己的路的时候，我是多么的开心，看到莱娜将女儿托付给邻居就出走的时候，我又是多么的愤怒，我几乎就要将手机砸向墙壁。虽然愤怒和难受，我却无法批评莱娜，我拥有着上帝视角，我能够看到这一个个选择的后果。读完的时候，我想我要写下自己的爱情，但是我发现自己的爱情并没有那么曲折，即使如此，我还是在爱情中做出了错误的选择，我还是和莱娜一样，认定爱情是生活的出路，对方是生活中困难的答案，我无法以上帝视角，审视自己的生活。如果前任再次出现在我的生活中，我相信自己的生活仍旧会被牵引。&lt;&#x2F;p&gt;
&lt;p&gt;所有人都在追寻自我，都在追寻“真正”，但是一切都不是绝对的，自我是自我的吗，自己被一切所影响，是不是不存在自我，存在的只有选择和对应的结果，自我像是一个答案，而人是没有答案的，我是谁，坚信的自我很可能被瞬间打破。“真正”的爱情真的存在吗？“真正”的自我存在吗？&lt;&#x2F;p&gt;
&lt;h2 id=&quot;shi-zong-de-hai-zi&quot;&gt;《失踪的孩子》&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;gu-shi-de-zui-hou&quot;&gt;故事的最后&lt;&#x2F;h3&gt;
&lt;p&gt;我不喜欢这个结局，在这个系列的所有部分里，作者构造了一个极度真实的故事，知道最后尾声的部分，我甚至以为这是作者的回忆，然后我才意识到这也是故事的一部分。如此真实的故事，却存在着无比不确定的情节，蒂娜的消失不是自己决定的，莉拉的消失则是她自己的选择。看完整本书和看到大家的猜测，我还是无法确定蒂娜究竟是如何消失的，我想蒂娜是被那不勒斯所吞噬的。&lt;&#x2F;p&gt;
&lt;p&gt;我自己有一个猜测，帕斯卡莱的隐蔽生活和可能存在的激进的斗争，莱娜的大获成功，蒂娜的突然消失，然后是索拉拉兄弟被杀。我自己并不认为是索拉拉兄弟下的手，他们不太可能不认识拉娜的女儿，而如果希望通过威胁蒂娜而使得莉拉毁灭，我觉得他们会直接对莉拉动手。莱娜的书很成功，但是她的书始终没有真正的打击到索拉拉兄弟，索拉拉死后那些暴露的内容远比莱娜书中的内容更加严重和丰富。我不想把帕斯卡莱的塑造成一个坏人，但是我觉得这是很有可能的，娜迪雅和帕斯卡莱可能走向了不同的道路，在他们逃避到佛罗伦萨莱娜的生活中时就可以看见，莱娜并不是那个帕斯卡莱的朋友了，他们分离的太远。在莱娜的书被卡门起诉的时候，卡门受到索拉拉兄弟的胁迫，虽然情有可原，但是我不相信帕斯卡莱不知道这件事情，也就是说帕斯卡莱实际上已经屈服了。莱娜的出名，使得蒂娜会被大众认为她是她的女儿，如果是为了胁迫蒂娜而使得莱娜妥协，那么必然会有要求，但是不存在要求。能够实施如此完美的绑架计划的人，在意识到自己绑架了错误的人之后，没有任何的要求被提出，这是不合理的。我只能想象到一种激进分子的行为，绑架了蒂娜，意识到自己绑架了错误的人，而又不愿意因为释放蒂娜而暴露自己，于是选择了默不作声。这个激进分子很可能是那个环境下的一个人，但是也有可能是帕斯卡莱。&lt;&#x2F;p&gt;
&lt;p&gt;在第三本里，莱娜被莉拉骂了，莉拉认为莱娜还在追求一种不现实的真正，莉拉说自己已经学会了事件是因果关系的。蒂娜的消失的原因可能有很多，但是这种消失是不合理的，如果说蒂娜的消失是原因，那么就没有结果，蒂娜的消失并不像书中所有其他的故事一样，都有着明确的结果。蒂娜的消失让莉拉痛苦，让莉拉和恩佐的关系改变，让莉拉和周围的人的关系改变，让莉拉改变。如果说蒂娜的消失是结果，那么原因是什么呢？任何可能的原因都是不确定的，而且也存在着漏洞。我认为蒂娜消失的这件事情，是不连贯的，其中的因果关系并不连续。莉拉从小到的那一种“界限消失”的感觉，这种感觉不断的影响着莉拉，莉拉的选择因为这种感觉不断的改变。在莉拉还在香肠厂的时候，临近崩溃的时候，她的这种感觉应该是最明显的时刻，但是莱娜让她恢复正常了，她和抽象社会的界限消失了。地震的时候，莉拉又出现了强烈的界限消失的感觉，她和自然的界限消失了。我觉得在蒂娜消失的时候，除了蒂娜消失的痛苦，这种消失的不连贯，模糊的因果关系，莉拉和自己的界限都消失了，恩佐离开了她。莉拉通过和莱娜的女儿的交往，通过对自己热爱的城市那不勒斯的连结，她恢复了一些这种界限，但是这一切都是有限的。但是当莱娜的女儿成长，追求自己的生活的时候，于是莉拉的连结又减少了。在莱娜探索自己人生的意义，自己作品的意义的时候，莱娜打破了和莉拉的界限，讲述了莉拉的故事，于是莉拉最为重要的界限也消失了，这个时候莉拉的世界也就不存在界限了，这是一种彻底的消失。如此一来，莉拉的消失反而比蒂娜的消失更加存在因果关系了。我想象莉拉用她所有的财富处理了所有自己的联系，成为了最自由的人。我也想象莉拉可能通过对那不勒斯的认知，探寻了这座城市最为隐秘的角落，寻找到了属于自己的最好的角落。&lt;&#x2F;p&gt;
&lt;p&gt;我更倾向于前一种想象，在小说的结尾，莱娜收到了那两个娃娃的包裹，那是她们第一次成为朋友的契机，她们的连结从那个时候开始。我想是莉拉一个人重新去找回了这两个娃娃，那个看似黑暗的地下室很可能是莉拉的游玩地点，莉拉总是能够了解到城区的每一个细节。莉拉为什么在“我”最后写完书的时候，才寄出娃娃呢？我想是因为在那个时候她们的界限才消失，莉拉正如莱娜想象的一样，在不断的阅读这一切。莉拉在最后的时间，我想象她一定是在写书的，很可能莱娜所写的内容中，就有莉拉的内容，很可能这就是莉拉的计划。莉拉不希望莱娜书写她们的故事，但是内心肯定是满怀期待的，想要看看这究竟是一个怎么样的故事，莱娜写完的时候，莉拉也就读完了，莉拉和莱娜的连结消失了。在阅读过程中，我有一种感觉，那就是这本书并不是莱娜一个人完成的，越到后面，这个讲述者，这个书写者，逐渐成了莉拉和莱娜二者形象的融合，莱娜越来越独立，她意识到自己作品的追求，莉拉和莱娜连结消失的时候，她们也就融合一体了。娃娃是莱娜和那个莉拉连结的证明，莉拉和莱娜的连结消失了，所以莉拉不需要娃娃，而莱娜则需要娃娃。&lt;&#x2F;p&gt;
&lt;p&gt;在开始的时候我说我不喜欢这个结局，但是直到我写完这么一大段，我才意识到这样的结局可能是最好的了。在之前的评论中，我都没有长篇大论的谈及故事情节，我更多的谈及的是自己的感想。之前的故事中，那些故事更加实际，更加具有因果关系，那些故事充满了起伏，就像第一次读到一千零一夜一样，这些故事更多的影响我。但是在书的结尾，这些故事离我还很远，我没有体验过成功，我的爱情虽然很惨淡，但是也没有像故事中那么激烈，我的人生才开始，没有成家立业，没有经历过书中那种离别，这是我人生的缺失。在读到莱娜和尼诺在一起的时候，我很愤怒，我觉得莱娜的未来会被尼诺毁灭。但是终于莱娜和尼诺分开了，我才意识到，他们的爱情是终将会破裂的，当莱娜面对她自己女儿发生和她自己类似情况的时候，莱娜也意识到这段爱情难以阻止，但是最后终会破裂。在莱娜晚年的时候，那些年轻时错误或正确的选择都不再那么不堪，一切的选择都构造了自我，究竟是自我使得人做出了那些选择，还是选择构造了自我，这个问题并没有一个确切的答案，都是纠缠在一起的。&lt;&#x2F;p&gt;
&lt;p&gt;读完最后一本，我的内心并不像前面的几本一样，并不那么愤怒，并不那么难受，我看到莱娜和莉拉的人生，那些角色的人生，无论是好人还是坏人还是普通人，他们在死亡后离场，莉拉和蒂娜消失了，她们留了下来。这不是一个传统的故事，很难说这个故事是好结局还是坏结局，她们都有失去也有获得，就像是人生一样。故事最后，结局不重要了，她们都留下了，故事中她们的人生结束了，但是她们必将在我的心中继续存活，和我的记忆一同变化，可能在我的记忆中隐居，也可能在我的记忆中变形，而我也可能成为她们的影子。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>枷锁和意义 ——《人性的枷锁》读后感</title>
        <published>2022-04-09T00:00:00+00:00</published>
        <updated>2022-04-09T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/of-human-bondage-note/"/>
        <id>https://ghost.livexia.xyz/of-human-bondage-note/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/of-human-bondage-note/">&lt;p&gt;和《一个青年艺术家的画像》一样，《人性的枷锁》也是一本带有自传性质的成长小说，但是本书的主角更加主动，更加想要探索这个世界和自己的人生。&lt;&#x2F;p&gt;
&lt;p&gt;菲利普年幼丧父丧母，被迫在伯伯的家中成长，童年并不欢乐，他的未来在他的眼中也不断变化。最初想要为信仰贡献一生，却又想要能够出国学习超越同学，求学回来之后初入工作，但是却无法忍耐平凡而无聊的工作，决定前去巴黎学习绘画，但是却又意识到自己无法向这艺术投入自己的一生，于是毅然放弃并随意的选择了求医。求医也不是一帆风顺，年轻的菲利普陷入了对爱情的求索，明知不行而无法放弃爱情，付出了自己的一切，而后又因为大环境的影响陷入穷困潦倒。穷困潦倒之下，干起了一份他所不齿的工作，其间收到了来自好友的帮助。艰辛工作下，终于伯伯的离世留给他一笔遗产，他得以逃离这穷苦的生活，继续着他的医学生涯。医学生涯之后，他幻想着能够游离世界，想象着探索西班牙，自己能够给自己的生活编制一幅绚烂多彩的图画。在一次乡下旅行中，他和好友的女儿终于相爱，对平稳生活和对爱情的向往，他终于决定自己要放弃那西班牙的幻想，和心爱之人进行表白。&lt;&#x2F;p&gt;
&lt;p&gt;相比于出现在书名中的枷锁，书中更多的是人生的意义，菲利普生来就有一个缺陷，跛足让他无法交到朋友，在身体正常的同学中总是受到欺负和嘲笑。面对这来自身体上的缺陷，他的方法是不断的阅读，通过实现自己心智上的成熟来抵御同龄人的嘲笑。只不过这样的枷锁并不是那么容易的解除，即使到了最后，能够通过手术改善自己的状况，他仍旧还是有着深深的自卑感。&lt;&#x2F;p&gt;
&lt;p&gt;除了身体上的枷锁，他也有来自宗教的枷锁，伯伯是当地牧师，生活在一个牧师家庭，耳濡目染的他很早就有了宗教信仰，但是意识到宗教信仰并不能带来实际的作用，他开始和宗教信仰逐渐背离。在德国的学习之后，他彻底的放弃了自己的信仰，但是信仰的枷锁并没有被消除，他仍旧是一个拥有强烈道德感的人，他还是坚信那些美好的，厌恶那些虚伪的。在伯伯的最后弥留之际，他仍旧是没有揭开心中的疑惑，这些神圣的事务，有让伯伯在离开人世的时候保有慰藉吗？&lt;&#x2F;p&gt;
&lt;p&gt;他也有更加实际的枷锁，那就是阶级和经济的枷锁，出生和成长于中产阶级，他仍旧是进行着一种资产阶级的生活，良好的教育，出国学习的机会，追求艺术的人生，进入医学院，虽然也存在手头紧的时刻，但是他仍旧是大体上保持着一种中产阶级的生活，虽然他并不表面展示自己对那些低劣工作的鄙视，但是他也难以真正的放下自己的自尊心，即使是自己最为穷困潦倒的时候，他需要自己进行这样一份低劣的工作的时候，他还是和周围的人格格不入。没有钱的生活，让人性的阴暗面完全显露，在伯伯弥留之际，他甚至希望能伯伯能够早点离去，让他早日摆脱这贫苦而艰辛的生活。&lt;&#x2F;p&gt;
&lt;p&gt;除了这些枷锁，菲利普还有两个更加牢固和更加复杂的枷锁，其中一个是他的人性，他的人生，他自己就构成了这个枷锁。他不知道自己的目标，他不知道自己的意义，年少求学希望自己能成为一个牧师，青年时又希望自己能成为一名画家，但是又怀疑自己，选择放弃艺术道路，未经思索又踏上了学医的道路。他的人生从一条道路转移到一条道路，在这个过程中他不是越来越确信自己的未来，而是越来越不解。在得知此前好友的突然死亡，他终于意识到人生是没有意义的。意识到这一点，并没有让他陷入绝望，他意识到没有意义的人生实际上是最自由的，他决心将自己的人生编织为最美丽的图画。&lt;&#x2F;p&gt;
&lt;p&gt;他也陷入了爱情的枷锁之中，初入爱情时他让别人爱上他，但是却很快就疲劳和厌恶，让对方陷入痛苦。学习绘画时没有意识到同伴对他的爱恋，在同伴离世时才意识到这一点。在学医时，他爱上一个不爱她的女性，他疯狂的爱上米尔德丽德，这段爱情折磨着菲利普的人生，理智给感情让道，那些阅读和道理并不能制止他做出错误的决定，这是一段不幸和充满羞辱的爱情。即使在米尔德丽德离去之后，他认识了一个新的爱人，可以说是堪称完美的爱人，但是在米尔德丽德再次出现后，他义无反顾的选择了米尔德丽德。菲利普年幼丧母，而伯父伯母不能给他那种温馨的家庭，他无法注意到那些温暖平静的爱意，他的爱情总是充满着争论、痛苦和伤害，这样的爱情成了他心目中的爱情。米尔德丽德正好给他提供了这样一种激烈的爱情，即使是在无数次的伤害之后，即使每次伤害之后，作者总是写下菲利普再没听过米尔德丽德，即便如此，每一次菲利普看见一个类似的声音，他还是控制不了自己。即使他内心不再追逐那热情如火的爱情，他还是无法安放米尔德丽德所带来的枷锁。直到最后，他终于爱上萨利，在面对自己未来的选择的时候，他选择拥有一个稳定的时候，他奔向萨利告诉他的选择的时候，他还在街头看见了自己想象中的米尔德丽德，结果并不是她，我想在这个时刻米尔德丽德的枷锁才真正的放下。经历了痛苦的爱情，终于好像修复了他的畸形爱情观。&lt;&#x2F;p&gt;
&lt;p&gt;我把一本连续的书，拆成了一个一个点，实际上这些内容完全都是交织在一起，一切都互相影响。菲利普的成长中我不断的可以看见自己的身影，对自己前路的未知，对人生意义的探索，爱情所带来的痛苦。这不是一本充满正能量的书，主人公并不是有着各种各样的奇遇，虽然他也有自己的优势，中产阶级的背景不至于将他完全打入社会底层。看见菲利普失去所有的金钱，在路边过夜，最后被朋友收留，在一份无法发挥自己能力，在仅仅只够养活自己的艰苦工作中痛苦生存。我比菲利普幸运，我的家庭虽然没有菲利普那么的好，但是家里能让我有的吃有的睡，我不必露宿街头。而我所生活的环境和时代，并不像菲利普的时代充满了动荡。但是我能像菲利普在走投无路的时候，能够放下自己的自傲，去从事我不喜欢的工作吗？&lt;&#x2F;p&gt;
&lt;p&gt;我的爱情没有菲利普那么艰辛，但是对于我自己而言，仍是难以忍受的痛苦。失去的爱情好像夺走了我的生气，在年轻的时候，总是幻想拥有一个美好的爱情，能够和自己所喜爱的人前进。而当自己终于爱上一个人的时候，前路并不是想象中的那么美好，生活的压力，社会的预期，自己的不成熟，一切都没有那么美好。即便爱情充满了曲折，但是失去爱情的时候，仍是充满了痛苦，突然之间无所不言的人不见了，好像一片自己不见了。虽然失去爱情非常痛苦，但是时间的确能缓解这一切，虽然我还是幻想着爱情，但是我更加平静了。&lt;&#x2F;p&gt;
&lt;p&gt;这是一本让我不断自省的一本书，看着菲利普人生的每一个阶段，让我不断的思考自己的人生，但是这是不够的，仅仅思考自己的人生是不够的，行动更加重要。读完这本书，让我想改变自己的人生，想让自己前行，我想这大概说明了这是一本好书吧。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>成长的孤独 ——《一个青年艺术家的画像》读后感</title>
        <published>2022-04-05T00:00:00+00:00</published>
        <updated>2022-04-05T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/a-portrait-of-the-artist-as-a-young-man-note/"/>
        <id>https://ghost.livexia.xyz/a-portrait-of-the-artist-as-a-young-man-note/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/a-portrait-of-the-artist-as-a-young-man-note/">&lt;p&gt;这是一本来自，我认为晦涩难懂的作者的书，买了《尤利西斯》的实体书已经不止五年了，而我却从未能读完前两页，我是被那些评论而吓跑的。这本书并不容易，但是也应该没有想象中的那么难，但是我仍旧带着错误的念头开始读这本书，标题中的艺术家的画像，让我以为主人公会是一个画家，我也知道这是一本又自传性质的书，所以我是带着一个疑问开始阅读的，那就是一个作家怎么会写一本自传，其中主人公是一个画家。我的错误是没有意识到作家也是艺术家，是文字和语言的艺术家。&lt;&#x2F;p&gt;
&lt;p&gt;这是一本意识流的小说，所有的内容应该都是通过一个第三人称的视角来描述，但是这个第三人称和大部分的第三人称都不一样，这个第三人称所描述的方法和内容都从主人公的视角上出发的，类似于在脑海里想自己，一个看似高于自己的人称，但是所有内容都逃不开自己的限制。所以所有章节中的语言风格都和那个章节中主人公的。当描述主人公童年的生活时，是一种幼稚儿童的描述，更加跳跃和纯真。而在少年时期，则处处充满了一种自大的无知，这种无知禁不起考验。等到了青年时期，主人公终于成熟，拥有一种骄傲，一种对自我认可的骄傲。&lt;&#x2F;p&gt;
&lt;p&gt;主人公斯蒂芬，出生在富庶之家，少年时期家境衰败，他拥有的是一个多变的童年，不断的变换住处。斯蒂芬生活在一个多变的世界，童年时目睹爱尔兰的独立运动，和他的家庭一样，这种独立运动，在斯蒂芬的眼里也逐渐衰弱，到最后这个国家并不值得被拯救，于是选择离开自己的祖国，选择从外部来观察祖国。&lt;&#x2F;p&gt;
&lt;p&gt;成长中，家庭、民族、国家和宗教在斯蒂芬中的重量逐渐变重，但是到青年时这些在斯蒂芬的生命中应该已经失去了影响力。童年时期凭借家庭，斯蒂芬可以依赖于家庭，逃避那苛刻的求学生涯。在少年时期，斯蒂芬萌发的性欲可以依赖于自己的想象和妓女（社会）进行排解。而在为自己犯下的道德罪行而痛苦不堪的时候，他依赖着宗教对自己进行慰藉和缓解。而当斯蒂芬的宗教信仰因为世俗力量而瓦解的时候，这些事物就不再对斯蒂芬产生了影响，在思考是否要成为一个牧师的过程中，他意识到自己的人性是和宗教背离的，他终将堕落。他并不能感受到哪一种奇迹，宗教在他手中只是一种控制自己喷涌思绪的工具，而童年时期的封闭无法表达自我的生活，也让他对宗教产生了厌恶，以至于最后他都不肯以一种假装的形态参加宗教活动而和母亲产生争执。&lt;&#x2F;p&gt;
&lt;p&gt;从小到大，斯蒂芬见证了多少爱尔兰的英雄被抛弃，被人民抛弃，被宗教所鄙夷。他内心仍旧是热爱着爱尔兰，他认为他说着的英语是敌人的语言，他们被外国人所统治着。他和一个牧师讨论词语的不同意义的时候，他用通盘（Tundish）来指代一个牧师用漏斗（funnel）指代的物件，通盘来自古英语，而漏斗则是法语的外来语，很可能爱尔兰的文化早就被英国的文化所渗透了。&lt;&#x2F;p&gt;
&lt;p&gt;看似斯蒂芬不再受到国家、宗教的影响，但是斯蒂芬仍旧是承载着这一切，只不过一切不再是普遍意义上的了，他追寻的是一种内心的国家，一种内心的宗教，他人口中的国家和宗教不再是他的标准，他有自己的评判标准，这些一切实际上组成了他的翅膀，他借以飞出世界。&lt;&#x2F;p&gt;
&lt;p&gt;斯蒂芬最后成了一个青年艺术家，但是这个艺术家并不一定是一个伟大或者出名的艺术家，这并不是他的目标，他的未来仍旧充满可能，他的翅膀很可能会被折断，而他也很可能一事无成。斯蒂芬和那些追逐自己梦想的人并没有差别，这是一条艰险的道路，这并不是一条稳定而美好的路径。这是一条艰苦而漫长的道路，路上很可能不会有同伴，走到最后甚至自己也会怀疑自己。我很想说我也在这样的一条道路上，虽然我能在斯蒂芬身上看见自己，但是很可惜我只是逃避。&lt;&#x2F;p&gt;
&lt;p&gt;这是一本真实的书，既然有着自传性质，那么坐着的勇气也是令人佩服的，多少内心的黑暗自己都无法提起，而作者却能够将这其中的历程进行剖析，这种真实是我在记录的时候所力求的，但是很可惜我并没有这样的勇气，我暂时还无法做到。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>值得一读的故事 ——《文城》读后感</title>
        <published>2022-03-26T00:00:00+00:00</published>
        <updated>2022-03-26T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/wencheng-note/"/>
        <id>https://ghost.livexia.xyz/wencheng-note/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/wencheng-note/">&lt;p&gt;一本几乎是一口气读完的书，本来计划两天内读完，最后读到凌晨三点读完。书里的故事并不复杂，两条线交错进行，一条线是寻找文城，另一条则是带来文城，人物的刻画并不非常深刻，全书更像是一个水浒一样的故事，一波发展跟随着一波发展，书中的残酷来的更加直接，匪徒和北洋军的残忍无比的直接。那些隐秘的残酷在这些直接的残忍面前好像都是容易接受的了，我想这也是为什么最后小美死去的时候，用的是生于清末乱世之后，死后避开了军阀混战。&lt;&#x2F;p&gt;
&lt;p&gt;我的故乡和书名几乎是一致的，只不过是不同的城，在这本书刚出的时候，我就看到了有很多的差评，这次看完再去豆瓣浏览一圈，很明显还是两极化。我不知道该怎么评价这本书，因为这本书并没有讲述一个什么道理，就是讲了一个那个时代下的故事，每个人物之间的关系都自有其特点。这是一个史诗一样的故事，一个人为了什么做了什么，他的同伴又做了什么，主人公不能算是一个最为惨痛的人，一个理想主义者，他的身上存有主人公的传奇色彩。&lt;&#x2F;p&gt;
&lt;p&gt;这不是一个那种能够体现时代力量的故事，故事中的爱情元素也并不充足，那些埋下的细节随着故事的结束就消失了，这些细节让人反而更有期待。故事的后续也没有得到发展，我想也很难有发展，如果继续下去，我想这个故事可能会变成《平凡的世界》那种故事，我想作者他自己应该是并不愿意的。这个故事中的坏人，是那种一定活不久的，因为太坏而不自知，故事中的好人，也往往难以长久。相比于书中的男性角色，女性角色更有韧性，更加生活，她们有着自己的内心变化，她们是不断的改变的，这在小美身上展现的很明确。&lt;&#x2F;p&gt;
&lt;p&gt;不知道该说什么了，只能说这是一个值得一读的故事，读小说的目的不就是通过体验故事的人生，而助长自己的想象吗？&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>自由 ——《光年》读后感</title>
        <published>2022-03-25T00:00:00+00:00</published>
        <updated>2022-03-25T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/light-years-note/"/>
        <id>https://ghost.livexia.xyz/light-years-note/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/light-years-note/">&lt;p&gt;一切都藏在一种悲伤中，一边读这本书，脑海中逐渐被一种悲伤、空虚和远离的情绪占据，这是一种看到生活没有意义的情绪，我曾无数次的不断问自己，我的意义是什么，我无法思索出意义何在，我想这也是为什么在读到芮德娜和维瑞离婚之前，这种情绪不断的在我脑海中重播。我看着书中人物的生活，每个人物不断的登场离场，芮德娜的出轨，维瑞的出轨，这一切都好像在告诉我这一切没有意义。&lt;&#x2F;p&gt;
&lt;p&gt;除了亲情之爱能够躲过时间的猎杀，好像什么爱都逃不过时间，那一种想象中的永恒的爱不存在，留下的只有记忆。芮德娜对出轨对象的爱，总是在不断的流动。维瑞对卡亚看似浓厚和持久的爱恋，却也逐渐消失在记忆里。而在陌生国度对维瑞拯救的爱恋，最后却成了无比的束缚。我曾经以为爱是生命的唯一，但是实际上爱不比洗澡时的思考来的伟大。芮德娜的一生，逃离自己的出生之地，游离自己的成长之地，最后安然的离去。她不在乎周围人的看法，她不追求快乐，她渴望自由，这是一种何等的勇气，一种我不曾有的勇气，一种明知追求自由所会失去而决心承担的勇气，面对自己的选择，她只有安然。&lt;&#x2F;p&gt;
&lt;p&gt;维瑞的一切都是追随着芮德娜，出轨、旅游和爱恋，但是他没有自己的自由，出轨本是自由的追求，他却给自己加上一层锁。旅游本是放空自己，他却去到陌生的地方，继续做着一模一样的自己。爱恋来自她人的主动，他没有自由，他也不曾有快乐。&lt;&#x2F;p&gt;
&lt;p&gt;写作风格十分破碎，人名交错，一切都和一切交杂在一起，时间总是不断的改变。时间好像不存在，充满日常活动的只有日常活动，交际、购物和旅游，他们好像不在乎外在，他们在一起的时候从来不讨论学习、工作和事业，这些东西都是他们的点缀，他们身份的标识而已。这种风格在开始总是让我觉得难受，断断续续不连贯。但是我发现自己越读越快，这种风格反而自有一种流畅的感觉。深夜读的时候，总让自己有更加深刻的感觉，现在读完反而写不出那种感觉了，只有一把枯燥的文字。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>战损人生 ——《西线无战事》读后感</title>
        <published>2022-03-18T00:00:00+00:00</published>
        <updated>2022-03-18T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/im-westen-nichts-neues-note/"/>
        <id>https://ghost.livexia.xyz/im-westen-nichts-neues-note/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/im-westen-nichts-neues-note/">&lt;p&gt;战争离我太遥远了，我没有亲历战争，那些亲历战争的长辈都已离开，现在战争只是一个发生在新闻里的的事件，即使世界上真的发生了战争，那么最多也就是能影响一下油价，这就好像日常生活一样，只不过这个影响更加突然。即使有无数的影视和书籍都在描述战争，但是我们看见的战争仍是一种旁观者。所以我是不懂战争的，有很多的战争是被赞颂，也有很多的战争是被嫌弃的，在写下这个评论的时候，俄乌战争还在进行中，即使是在旁观者中，这个战争既有被人赞同的，也有人是批评和痛恨的，战争就是这样的分裂。有句话是说，技术是没有善恶的，使用它的人才有善恶，那么战争是什么呢？战争就是一种统治者使用的技术，这样描述战争实在是太冷酷了，一方的统治者厌恶另一方统治者发起的战争，而我并不是统治者，那么我能从这个角度来评判战争吗？我能说因为A国侵占了B国的利益，可能危害了B国的安全，就认为战争是好的吗？我不能，我对现在正在发生的事情，内心中有着无数的争辩，我受到来自两方的政治宣传的影响，而我意识到这其中太多的态度，太多高高在上的态度。我受到这写态度的影响，直到我透过视频看见那战争时平民百姓状况。混乱的出逃，小女孩在火车门口逆着人流想要寻找自己的家人，一个表情严肃的父亲肩上是一个略有愁容的女孩，这些让我从另一个角度来看待这些战争。&lt;&#x2F;p&gt;
&lt;p&gt;扯了一大堆的战争，如果想要好好的评价这本书，就需要先说明自己认识的战争，这本书没有一页是和战争没有关系的。一个普通的学生，被老师鼓吹的成了士兵，被战争机器碾压，被国家碾压，最后死去。“我”是一个有着文学气息的学生，热爱大自然，在战争中不断被损耗，那些理想和日常成为了不敢想象的可怕事物，那些平常的欲望却成了可能逼疯自己的症结，那些美好的未来都被战争打碎，自己的未来消失在战争中。&lt;&#x2F;p&gt;
&lt;p&gt;除了战争的残酷，书里面还有战友的情谊，战友们即使在最艰难的时刻，也尝试苦中作乐。在战火中享受仅有的美食，在战火中嬉笑怒骂。而即使是在战争这样的残酷事件中，也有着不平等，大兵头总是死的最快，吃的最烂，最没有选择，后方和平的人，支援士兵的人，他们可以一边有平静的生活，一边无知的谈论战争，而身在前线的士兵却不知道为了什么，不知道他们口中的国家是什么，不知道他们口中的民族是什么，也不知道为什么自己和敌方那些同样青涩脸庞的士兵为了什么在这里互相伤害，对于士兵来说战争好像是没有意义的。&lt;&#x2F;p&gt;
&lt;p&gt;在没看这本书的时候，我在内心挣扎着，挣扎着我要以哪一种态度来看待战争，是以一种为了国家安全而战争的态度来看待，还是以一种不人道的战争来看待。看完之后我意识到了，我是一个普罗大众，那么我只能以普罗大众的角度去看待战争，以无知的士兵，以受到炮火打击的百姓的角度去看待，这是一种无知傲慢的角度，无知傲慢到以为自己能在平静的岁月里感受他们的痛苦，但是如果不以这样的角度去反对战争，去可怜弱者，那么我能做什么呢？我只能像一只鸵鸟一样，把自己的脑袋埋到沙子里，不闻不问，好像我不明白经过这一场战争，将有多少人会和自己战损的人生走到尽头。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>除了自我别无留存 ——《奥古斯都》读后感</title>
        <published>2022-03-16T00:00:00+00:00</published>
        <updated>2022-03-16T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/augustus-note/"/>
        <id>https://ghost.livexia.xyz/augustus-note/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/augustus-note/">&lt;p&gt;作者的另外一本书《斯通纳》曾经是我视为最直接影响我人生，而我却没法说明的一本书，这次又读了这一本《奥古斯都》。这是一本书信体的小说，看见书前的人物介绍表，结合书信体，给我的第一印象是肯定会晦涩难读，这么多复杂而又相似的名字该如何记忆和梳理，而当我一不小心一下子就读完三分之一的时候，才明白自己的担心是毫无必要的。在读外国文学的时候，我向来不抱着一种我要无比准确的记住人物名字的态度，我通过一种我所看见的描述，结合隐约记住的名字，来认识这个人物，虽然很可能会有误认，但是我也觉得这种误人，即使是在现实生活也是有可能出现的。&lt;&#x2F;p&gt;
&lt;p&gt;书中的人物应该都可以算得上是大人物了，恺撒是一个让我生畏的名字，在我的记忆里恺撒是伴随着死亡和痛苦的名字，这些大人物在书里面好像脱离了一种虚幻感，我不需要先认识西塞罗是怎么样的一个人，我不需要明白西塞罗的政见和生平，虽然这个名字很耳熟。书信体没有让这本书难读，反而把各色人物串联的及其美满，将所发生的事件说明的及其清楚。在全书的第一和第二部分，没有出现过屋大维的自述，所有对他的描述都是通过朋友、家人和政敌。这就是他人眼中的恺撒，那么屋大维也就保有一丝神秘性，无论观察的如何细致，无论通过分析和判断他人的选择，都是一个他人眼中看见的人，角度再多也只是丰满了他的形象。在全书的末尾，终于出现了全书最长的一封书信，这就是屋大维写给他最后的朋友的书信，透过这个书信，恺撒的形象才是真正的被完整的塑造，自我的认知和他人认知在这个时刻得到结合。&lt;&#x2F;p&gt;
&lt;p&gt;透过最后的自述，恺撒没有成为自己想要成为的人，人的可能在人生的最后全部消失，那些期许和理想好像只能欺骗自己。我一直认为人是无法完全成为自己想成为的人的，一方面是这个想成为的人会不断的变化，而另一方面人所能控制的东西并不多。虽然一切都是我们所选择的，但是我们所选择的并不一定就是我们所想要的，一个人可能想要奋发上进，但是他却选择了再娱乐几分钟。所以真正停留的只是那些我们做过的事情，我们所希望所想象的并不能描述自己，只有那些选择能够描述自己。&lt;&#x2F;p&gt;
&lt;p&gt;在收到养父死亡的消息，屋大维的人生在短短的一瞬间发生了改变，他意识到他所追求的未来是什么，意识到自己将要放弃什么，而他坚定的选择了放弃。所以他再无法同朋友们畅所欲言，无法过上普通农夫的怡然生活，最亲的女儿也只能过通过流放而拯救她，他选择了罗马，而放弃了自己的小罗马。在人生的最后，他正视了这一切，没有自欺的告诉自己，我想要拯救一切，但是我却没有办到，他意识到自己的选择和失去，他存在后悔，弥留之际他说“我们不必原谅自己”，我想这正是人生，人生可以后悔，可以不原谅自己，人生除了自我，一无所有。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>人生复杂 ——《安娜·卡列尼娜》读后感</title>
        <published>2022-03-11T00:00:00+00:00</published>
        <updated>2022-03-11T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/anna-karenina-note/"/>
        <id>https://ghost.livexia.xyz/anna-karenina-note/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/anna-karenina-note/">&lt;p&gt;开始读这本书应该是在2022年春节前夕，而整个二月份我只读了不到三分之一，终于在40天后，我读完了。对这本书的感情是很复杂的，因为太有名，所以我已经知道了结局，对于阅读一本好像已经注定的书，我总是有一种复杂的感觉。&lt;&#x2F;p&gt;
&lt;p&gt;正如托尔斯泰所说的，安娜的死不是作者的可以安排，而是安娜自己的选择，人物的选择超出了作者的选择。只有一刹那，我在想安娜是不是可以不死，是不是可以脱离这一切，是不是可以追求自己的事业。但是仅仅只有一刹那，如果安娜那么做了，那么也就不是她，她也就不是生活在那个环境中的人了，那么安娜的魅力也就消失了。虽然安娜的死亡是悲剧，但是我总是忍不住想，想到在这之后俄国社会的变迁，也会觉得有些安慰，看到书结尾伏伦斯基作为志愿军的出征仿佛也是俄国未来的预兆。&lt;&#x2F;p&gt;
&lt;p&gt;书中的主要出场人物都是贵族和地主，大部分的人物都充满了贵族色彩，有着强烈的贵族意识形态，大部分在官场的人物，总是坐着无意义的正派事物。而从事土地生产的地主，也热衷于参与地方政治，地主生活好像也并不是那么完美。一切好像都充满了破败的感觉，无论是在莫斯科还是在彼得堡，贵族过着穷奢极欲的生活。&lt;&#x2F;p&gt;
&lt;p&gt;书中的故事主要就有两条线，一条是安娜，另一条是列文。他们两人的连接在于安娜的哥哥的妻子是列文妻子的姐姐，只有这样的关系，但是列文的篇幅却不逊于安娜。安娜爱上伏伦斯基，和丈夫决裂，却陷入了爱情日渐狂烈和对方日渐冷淡的回应的冲突中，而她对自己儿子的爱，更是让她充满了分裂。列文一出场就受到了爱情的挫败，挫败之后他决心把自己投身于工作上，最后仍是收获爱情，在经过不断的思索之后终于意识到自己的信仰何在，终于意识到自己该如何生活。&lt;&#x2F;p&gt;
&lt;p&gt;安娜的人生，就是爱情和后代，列文的人生则是爱情和事业，如果是安娜也有事业的话，我想那就是社交界的事业，但是安娜牺牲了这一事业而成全了爱情。安娜是不幸的，这个不幸不是由作者创作的，而是环境，女性人物的人生总是伴随着社交界和生育，那么当安娜自觉失去了爱情和儿子，她还能怎么办呢？她只好选择死亡。&lt;&#x2F;p&gt;
&lt;p&gt;安娜死前的心理描写是抓人的，完美的描绘了安娜在那个环境下的心理，安娜的形象无比的真实。安娜以一个完美的外在形象出现，内心却承受着无比的痛苦，无比的怀疑矛盾在撕裂着安娜。相比于安娜的心理描写，在书结尾对列文的心理描写也是极其出色的。列文学习各种自然科学，学习各种哲学，但是在尼古拉哥哥去世，在儿子诞生的时刻，仍旧是祈祷，仍旧是投向信仰，他自认是一个无信仰的人，但是又清楚地意识到没有信仰，他就要否认那些时刻。列文也充满了矛盾的内心，也曾想到去死。列文通过自己的劳动，从他人口中获得了解答，有人说列文最后信仰了东正教，但我却不这样认为，列文最后得到的信仰，是生活的态度，他知道自己该做什么，而这些并不需要什么宗教和哲学，这些是他身上的天赋，是人的天赋。安娜和列文都得到了解脱，两个真实的人通过两个不同的路径，都得到了内心的安宁。&lt;&#x2F;p&gt;
&lt;p&gt;除去这两条线，当时的社会背景也是一大重点，通过各色人物的行事，一个充满空想的社会展现着我们眼前。书中可能做了最实在的事情的人物就是安娜的丈夫卡列宁，但是他做的事情是什么呢？是想办法攻击对立阵营，创立更多的委员会，最后也沉迷在自己想象的宗教中。安娜的哥哥则好像是一个乐天派，最早的出场人物就是他了，好像每一个事件中都有他， 他也好像在每个事件中承担了不可或缺的责任，但是他却不忠与妻子，不在乎孩子的教育，更加不在乎如何生活，浪费了妻子的树林。即使如此他还是笑悠悠的，和每个人都相处的很好，到处去谋求一个实际上是空头的职位。各种会，各种讨论，充满的都是无法做实事的人，唯一一个尝试实事的人是列文，但是他早就发现参与这些会和讨论并不能解决任何问题，反而增加了更多的问题。整个社会充满了假大空，即使是最受社会尊敬的学者，也看不见未来的黑暗。安娜的哥哥从从彼得堡去莫斯科谋求美差的时候，社会的腐败和脆弱可见一斑，他欠钱两万就已在想寻求美差获得收入，而彼得堡的各色人物欠钱50万，也还是怡然自得，他享受这样的生活，这样的生活难道不是建立在他人的痛苦之上的吗。&lt;&#x2F;p&gt;
&lt;p&gt;在列文的儿子诞生前，列文也开始沉迷于莫斯科的这种社交生活，虽然他内心是讨厌的，但是却还是花钱如流水，并且也开始接受这种现实，不得已的退让了自己的利益，读到这些，我就想难道列文也要成为另外一个安娜的哥哥吗？他的真实难道也要被消除吗，好在儿子的诞生好像把他拉回了现实。&lt;&#x2F;p&gt;
&lt;p&gt;我没办法谈爱情和出轨，而这是这本书最重要的两个内容，我无法谈论这些事情，是因为我对爱情的态度也在变化，就如同安娜最后对爱情的看法，多少人追求爱情，但是却不知道爱情是多么的卑鄙。爱情好像是高于一切的事物，但是又好像很容易被一切事物轻易打败，爱情的复杂不是我能理解的，我也不想写下错误的文字，误导了爱情。和爱情同在的可能就是出轨，也就是背叛，社会总是嫌弃出轨者，即使是在书中的社会背景下，私下的出轨仿佛是一种推荐的行为，但是一旦想要把出轨放到主流，又会被人唾弃。我也不认同出轨，这是一条悲剧性的道路，但是我能说所有的出轨都是罪恶的吗？好像又不能这么简单的说明。正像人生一样，没有完全的恶人，也没有完全的好人，书中的所有人物都是这样，既可怜，又仿佛注定结局。&lt;&#x2F;p&gt;
&lt;p&gt;感觉写了很多，但是又有很多自己表达不出来，这本书是复杂的，每个人物有的时候总是觉得好像自己，并不会无比痛恨某一个人物。看见这些空想的人，我想到自己一年没有工作了，而我还在和自己说要乐观，这是真的好的吗？即使是社会环境已经发生了大的变化，但是我还是能凭借阅读进行所思所想，对自己进行认识，我想这在很大程度上就是阅读吧。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>离去不比留下容易 —— 难免疼痛观后感</title>
        <published>2022-03-06T00:00:00+00:00</published>
        <updated>2022-03-06T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/this-is-going-to-hurt/"/>
        <id>https://ghost.livexia.xyz/this-is-going-to-hurt/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/this-is-going-to-hurt/">&lt;p&gt;难免疼痛是一个充满了疼痛的故事。主角是一个在公立医院里不上不下的妇产科医生，上要对付领导的要求，下要教授实习医生，又要面对生活中除了工作的其他的事情。虽然主角对自己的工作很擅长，但是却还是不免出现问题，而这也让他意识到自己的责任和选择，而工作的痛苦逐渐渗透到了他的私人生活中。&lt;&#x2F;p&gt;
&lt;p&gt;所有能出错的地方都出错了。在NHS体系下的公立医院，面临着没有资金，没有医院，但是却全都是病人的情况，主角亚当和实习医生舒蒂直接面对着这一切。高级的顾问医生更少的面对病人，西装革履配上豪车，还能兼职私立医院。而作为护士的Tracy，虽然尽职尽责，但是她也很难理解医生的压力，认为亚当的问题，来自于他的自大，Tracy能安心的休假，但是亚当却无法自如的生活，的确可能没了亚当还有下一个，但是这是很冷血的说法。最后舒蒂的离开，她也只能哭着说不知道为什么。亚当知道自己是有错的，所以虽然他不满于Tracy的投诉，却也没极其针对她。&lt;&#x2F;p&gt;
&lt;p&gt;亚当不是一个高尚的人，他没有要做一个圣人的自知，所以他能心安理得的在报告里写上是顾问医生让他使病人离开的，但是他也不是一个罪不可恕的人，所以他没有办法在顾问医生把自己撇的一干二净的时候据理力争。最后在面对GMC的时候，他没有选择我想象中的两条路中的一种，即没有听顾问医生的把所有的责任都推卸到舒蒂身上，也没有完全的控诉到顾问医生身上。他进行了最为真实的控诉，的确是自己的自大导致了最后的问题，而且他也选择听从了顾问医生的建议，他知道自己不是最好的，但是他也知道这一切也不全是自己的错误，而这一切正是NHS的体制问题，所以他选择说出自己真实的想法，这个时候亚当不再是那个偶有妙语的医生，亚当俨然是想要改变这个体制的医生。&lt;&#x2F;p&gt;
&lt;p&gt;在最后揭露前，因为不知道亚当在面对GMC究竟采用了什么样的说辞，亚当还在正常工作，我以为他应该是听从了顾问医生的说法，即使我是这样觉得的，但是我没有办法怪罪他。最后在好友的婚礼上，亚当准备寻找新的几乎，前男友哈里迟迟未到，当他一人在喝闷酒的时候，看见姗姗来迟的前男友。两人抛下参加的婚礼，一起在湖边聊天。最后二人在湖里对话，亚当意识到自己的生活如果没有做医生，那么一切可能都会正常，但他也意识到自己是不可能放弃这个职业的，这不是为了钱，他热爱自己事业，通过努力拯救人命。最后二人相拥于湖中，都认同了双方的选择。&lt;&#x2F;p&gt;
&lt;p&gt;站在局外人的角度，我会觉得不如就放弃医生这份工作吧，亚当没有顾问医生那种能够排除压力和痛苦的能力，亚当的痛苦就是来自于他是一个普通人，一个情绪复杂的普通人。与大部分的医疗剧不同的是，疼痛难免塑造的是一个普通人，一个希望自己的工作不是简单的工作而已，是一个自己热爱的事业的普通人，那么如果这样必然会有疼痛，必然要为了自己的热爱放弃一些东西，也要为了自己的热爱忍受一些不理解，所以最后难免疼痛。&lt;&#x2F;p&gt;
&lt;p&gt;整部剧说的都是疼痛，但是最后却自愈了自己，处在人生的路上，总是想要自己能够平稳的前进，于是就会有很多的坎坷不想经历，于是就会逃避很多事物，但是自己也意识到疼痛是难免的，于是就陷入了两难。舒蒂正是这种选择的一种结果，她充满了所有医生需要的品质，但是她却也被这些品质所压迫，无法再承受这些压迫，她所热爱的事情逐渐被摧毁，如果我把舒蒂的结局告知家里的大人，大部分肯定会和我说，受不了就转行呗。这就是舒蒂身上受到的压力之一，这也是为什么她和顾问医生求教得到的答案之一，她看见了要成为顾问医生所需要的付出，需要把自己的同理心删去，需要油滑的面对生死。她热爱这一种新生命从自己手中诞生的感觉，但是她也害怕如果这个生命从自己手中流逝的后果。妇产科医生好像真的是一种炼狱，日夜折磨，人类从中延续，充满痛苦，舒蒂选择放弃，亚当选择继续。不要简单的说舒蒂的自尽是因为抑郁症，那也太小瞧她了，那是对人生做出无比沉重的思考后的选择，选择死亡并不选择活着容易。写到这里又想起尼采的那个轮回，如果人生中的所有痛苦、快乐和思想豆浆重复发生，那么你会选择再来一遍？&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>想象中的乐园</title>
        <published>2022-01-25T00:00:00+00:00</published>
        <updated>2022-01-25T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/fang-si-qi-s-first-love-paradise-note/"/>
        <id>https://ghost.livexia.xyz/fang-si-qi-s-first-love-paradise-note/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/fang-si-qi-s-first-love-paradise-note/">&lt;blockquote&gt;
&lt;p&gt;《房思琪的初恋乐园》-- 林奕含 读后感&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;这是一本极其痛苦的书，看了十分钟，突然间呼吸急促，心中有一股激愤，而十分钟前还是静心的音乐，现在却喧闹无比，一种听见被压抑的呐喊的愤怒和害怕的感觉出现在心中。读书的时候有一种出离的感觉，感觉周围的一切都在颠倒，自己在没有重力的环境里翻滚，无依无靠。&lt;&#x2F;p&gt;
&lt;p&gt;读完让人想要逃离文学，文学不是拯救，文学也是一种武器，房思琪的文学性的确在某种程度保护了自己，这让她痛苦的活到18岁，但是这也让她充满痛苦。一种极度和真实的视角，讲述一个真实的故事，我不知道我还能写什么。社会上的人对自杀者是鄙视的，就好像房思琪的发疯，也是因为读了太多的文学书，作者林奕含的自杀，仍有人对她是有着优越感的，而现在搜索的结果中，仍有补习老师说的我们是相恋的。很多书评，很多留言，都在指摘自杀这件事情，假如不是因为沉溺在文学里，那是不是不会死。假如真的能够不自杀，假如房思琪不会发疯，假如她们都能经历大痛苦而坚强的生活，我认为是小瞧了痛苦，不是所有的痛苦都是能够让人变得更好的，不是所有的痛苦都是能让凤凰涅槃的，也有的痛苦是毁灭性的，我不相信集中营中死去的人所受的痛苦，让他们成为更好的人了。有的痛苦是无法承受的，无论最后是自己选择死亡，还是死亡选择了自己，痛苦是切实存在的。假如一个人因为太过于纯净，而被社会伤害，我们不应该指责她太纯洁了，太热爱文学了，看不见这个社会的黑暗，而是应该想想为什么社会是这样的。&lt;&#x2F;p&gt;
&lt;p&gt;看了林奕含的专访，这是一个痛苦的人，极度痛苦以至于能够以最平静的话语讲诉最黑暗的事情。看到她生命最后所做的那些事情，泪流满面。林奕含说她想叩问的是，文学是不是从来就是巧言令色的，社会从小传达的是有文化，嘴上念着几千年的诗歌，实际上却做着禽兽的行为，这是文学的巧言令色吗？假如一个人浑身上下充满了道德，充满了世俗的好，那这个人是好的吗？&lt;&#x2F;p&gt;
&lt;p&gt;我从来都不相信道德，我见过太多的满口仁义道德，实际上是利益为先，假如一个人好色，那我觉得这个人好色，但是假如一个人动不动就说仁义道德，肯定是想要绑架你。不相信社会的道德，实际上是无法融入社会的，你无法在需要你表演的场合表演，充满了刺。&lt;&#x2F;p&gt;
&lt;p&gt;面对这样一本书，是无法说出任何希望的，在这样的事情里真的有希望吗？&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>生死疲劳，何须六道</title>
        <published>2022-01-24T00:00:00+00:00</published>
        <updated>2022-01-24T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/life-and-death-are-wearing-me-out-note/"/>
        <id>https://ghost.livexia.xyz/life-and-death-are-wearing-me-out-note/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/life-and-death-are-wearing-me-out-note/">&lt;blockquote&gt;
&lt;p&gt;《生死疲劳》-- 莫言 读后感&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;这是一本和《百年孤独》很像的书，一切的事情都发生在上个世纪50年代到这个世纪初，所有的事情都是通过三个讲述者完成的，一个是经历六道的大头娃娃，一个是几经沧桑的蓝解放，最后一个就是莫言了。经历过人、驴、牛、猪、狗、猴，最后成为大头娃娃，每一道都不同，与其说是动物，我觉得每一道都和人生的每个阶段很像，蓝解放没有经历六道的轮回，但是他也眼见高楼起，眼见他楼塌了，最盛大的葬礼他却无法出席，之后却都是抱着骨灰安葬，经历六道轮回的西门闹，和经历沧桑的蓝解放不都是生死疲劳吗？&lt;&#x2F;p&gt;
&lt;p&gt;故事随着轮回转世进行演进，每一道的性格都完美的体现了每一世动物的性格，驴是倔犟，牛是憨厚，猪是贪欲，狗是衷心，猴是顽劣，每一世时身上都有更少的西门闹的性格，更多的动物性。在成为猪的时候，更加的像一种新的人，追求更好的宿舍、吃食和另一半，受到压迫也能奋起反抗，也会复仇，但是也会心生恻隐之心牺牲自己。封面上写着，何须六道，当我读完牛的一生的时候，我已经感觉到了那一种疲劳，生死疲劳。一生的不甘和痛苦，难道都要经历六道的轮回才能消解，再次成为人吗？&lt;&#x2F;p&gt;
&lt;p&gt;魔幻和疯狂是贯穿全书的，互助的头发，六道的轮回，这都是魔幻，疯狂的事所有的人，疯狂的改变，疯狂的爱恋。在疯狂之中是没有人是没有人能独处暴风眼之中而不受影响的，金龙一生起起落落，最后和同样起起落落的老书记同归于尽。从小懂事、孝顺的开放，疯狂爱上自己的表妹，最后殒命。蓝脸冰天雪地中被救起，在最疯狂的年代，他也有自己的疯狂，一生单干，和那些同自己并肩的动物独自疯狂。&lt;&#x2F;p&gt;
&lt;p&gt;书中描述的多是苦难之事，但读来却往往让我大笑一场，一种幽默的笔触讲述最惨的世间。疯狂之中的悲剧好像被淡化了，人的命运自己就无法掌控，不是所有的人都能同蓝脸一般坚持，奔着一个好去的，最后却总是惨淡收场，但是蓝脸坚持做自己了，他的结尾又是幸福的吗？我总是觉得没有什么好的，人生就是活着，仅此而已。看到春苗说的那一句话，“有孩子来买小人书时我就卖小人书，没孩子买小人书我就看小人书，我感到很满足。”，我就觉得这就是人生啊，这就很满足。&lt;&#x2F;p&gt;
&lt;p&gt;莫言是一个旁观者，莫言不断的出现在自己的书中，真不知是走了后门还是真有本事。虽然有走后门的嫌疑，但是却也让这本书更有趣了。地狱在小说中是实在的，地狱好像就是同人世间一样，人间的改革也影响了地狱，轮回六道就是希望西门闹能有一个和谐的心，地狱其实也是无理的。西门闹在地狱的痛苦，只怕是比不上轮回六道中所收的痛苦。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>打破阶级的挣扎</title>
        <published>2022-01-16T00:00:00+00:00</published>
        <updated>2022-01-16T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/the-red-and-the-black-note/"/>
        <id>https://ghost.livexia.xyz/the-red-and-the-black-note/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/the-red-and-the-black-note/">&lt;blockquote&gt;
&lt;p&gt;《红与黑》-- 司汤达 读后感&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;《红与黑》就是一个年轻帅气的男人和两个完全不同的女人相恋的，最后死去的故事。男主角于连是木匠的儿子，热爱拿破仑，爱上的两个女子都是贵族，最初的爱恋并非是那种伟大的爱情，征服女人是于连虚荣心的一种象征，但是于连仍旧产生了爱恋。于连精心设计捕获了玛娣儿特的美人心，但是在生命最后的阶段，他才意识到人生最后阶段，虚假和伪装没有意义的，于是他才意识到自己更爱的是那个瑞那夫人。&lt;&#x2F;p&gt;
&lt;p&gt;于连不是一个伟光正的人，不断的诱使和操纵女子爱上自己，实际上不只是女子，他对所有人都是一样的，正是这样的行为，他从一个木匠的儿子，最后几乎成为了一个贵族。但是于连是痛恨这种行为的，他一边鄙视阶级低的人，一边又仇视贵族，他自身有着一种分裂的挣扎，一边逃避自己出生的阶级，一边又抗拒自己奔向的阶级。他是被社会撕裂的人，于连有着各种各样的机会，成为各种各样的人，他可以成为一个精明的木材商，也可以成为一个博学的教师，或者在军队中建功立业，亦或在教会中成长，甚至成为社会的上层贵族。但是于连对每一个选择都不满意，他对现实并不认同，每一个角色他都能扮演的很好，但是于连是不想演戏的，爱情仿佛是这个社会中的一个出路。在爱情中于连可以扮演每一个角色，但是同时他也可以是真实的。但是爱情总是会遇见现实，和瑞那妇人的爱情因为嫉妒而破裂，而和玛娣儿特的爱情则又因为阶级的差距和破裂，现实的拉扯破坏了于连的爱情。于连无法选择任意一个角色，最终他的结局只有死亡。&lt;&#x2F;p&gt;
&lt;p&gt;于连本质上是一个浪漫的人，假如生活在21世纪，他就是一个花花公子，勾搭有夫之妇是为社会所不齿的，但于连却年轻就失去生命。瑞那夫人是可怜的，她的爱意和挣扎是真实的，最后她虽然信守了诺言，但是仍旧失去了生命。于连在生命的最后，虽然即将死亡，但是他看见人生的真谛，也意识到自己的爱恋是真实的，所以于连虽然是悲剧收场，但是于连的寻找和挣扎在某种程度上是圆满了。而玛娣儿特最终也获得了自己想象和期望中那种凄美的爱情，玛娣儿特追求的真是这种悲剧的爱情。&lt;&#x2F;p&gt;
&lt;p&gt;即使是19世纪的书，放到现在只让我觉得司汤达对人物内心的描写实在是高明。于连的内心是想要成为英雄的，最后法庭上的那一番英雄式的陈词更是极具煽动。但是回到地牢，他又向瑞那妇人吐露了自己内心的懦弱和胆怯。我很容易就在于连中看见自己，对美色和权力的渴望，但是又对社会不公和阶级矛盾的不满，于连是复杂的，玛娣儿特也是复杂的，正如每一个人都是复杂的。我想这也是为什么不应该以简单的对错来评判于连，我希望自己也能有于连那种为爱的激情，那种少年爱人的美丽。每次看见于连对爱情的胡思乱想，对细节的心神不宁，我就想起自己的爱恋，而于连那一种为爱牺牲的勇敢，我也想起自己那些为爱生出的荒唐年头，我想这也是为什么两百年后还有人在读《红与黑》的原因吧。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>天朝能赢吗？</title>
        <published>2022-01-11T00:00:00+00:00</published>
        <updated>2022-01-11T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/the-collapse-of-the-heavenly-dynasty-note/"/>
        <id>https://ghost.livexia.xyz/the-collapse-of-the-heavenly-dynasty-note/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/the-collapse-of-the-heavenly-dynasty-note/">&lt;blockquote&gt;
&lt;p&gt;《天朝的崩溃：鸦片战争再研究》-- 茅海建 读后感&lt;&#x2F;p&gt;
&lt;p&gt;上传书评到豆瓣的时候，触发了豆瓣的审核机制，读此书时的一些感受突然又出现在脑海中。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;从现在的眼光来看，天朝在鸦片战争里是输的彻底的，但是好像在当时的当权者看来，只是受到了屈辱，最害怕的夷人进京的事情没有发生。作者的笔力很强，鸦片战争在以前在我的记忆里是一场对华的不平等战争，是近代屈辱史的开端。但是鸦片战争从来都是停留在高中历史书本和试卷上要记录的年份，只知道有卖国贼，还有林则徐。读完此书，才明白这一切远比那个不断背诵的年份要来的更加重要，所有现在在这片土地发生的一切，都可以说是源自于此。&lt;&#x2F;p&gt;
&lt;p&gt;这本书我查了一下应该是写就与1995年，我还记得在10年前，日本人对钓鱼岛的主权宣誓，而中国外交被我们戏称嘴上功夫，而在现在外交上已经无比强硬，但是我们现在却对外国人有一种更加老旧的态度了。假如是夸中国的外国人，就会被说明是英明，而那些批评的声音，则会被说是美分或者汉奸。仿佛又陷入了一种自大的地步，天朝好像又出现了，作者在书的最后留下了一个问题，现在中国和西方的差距，和鸦片战争时期相比，是变大还是变小了呢？我认为是变小了，中国的进步所有人都可以看见，但是也要警惕一种激进的民族国家主义。&lt;&#x2F;p&gt;
&lt;p&gt;读来一边为英国人的狡猾和无耻所愤怒，一边又为掌权者的懦弱和无知所愤慨，同时又为当时那些流血的士兵和群众所揪心，作者利用翔实的史料，展现了那场战争的所有事件，将那些处在事件中心的所有人物的经历描述的一清二楚。天朝实际上是一个停滞的王朝，遵循祖制，那么也不难明白为什么天朝会失败了。作者以天朝的崩溃作为书名，即使最后签订了如此之多的不平等条约，天朝那时也远不到崩溃的地步，对于天朝来说，仅仅是赔款和割地，道光皇帝所统治的天朝远远还没有崩溃。虽然鸦片战争没有让天朝分崩离析，但是鸦片战争正是天朝崩溃的起源。&lt;&#x2F;p&gt;
&lt;p&gt;天朝的崩溃不在于坚船利炮，坚船利炮打开的是一扇腐朽的门，即便不是英国人也有可能是俄国人，崩溃是肯定的，鸦片战争是必定会战败的，无论皇帝是谁，无论指导的大臣、将军是谁，我看不见一分成功的几率。这是一段屈辱史，读来比看几百部爱国电影都更加让人希望祖国强大，历史的作用不只是宣传某一种意识形态，真实可信的历史才是有价值的，但是历史往往成了宣传的手段，为了效果，往往又产生各种的解读。但是历史真的能够实现完全的客观吗？我觉得这是不可能做到的，我想这也是历史的魅力。但是这并不是说历史就是没有能够在讲述者的口中随意变化的，历史的真实性是第一条，在这个基础上再从多个角度切入的历史是有意义的。长久以来我一直在想一个问题，该如何面对痛苦，痛苦让人成长，那么应该痛恨痛苦呢，还是感谢痛苦呢？读完这本书我又有了一个新的答案，应该直面痛苦，痛苦是历史的一部分，直面才有价值，直面才能成长，无论是痛苦还是快乐，过去的一切都应该正视，一昧的否认和吹捧都只能让人迷失，历史也是如此，直面历史才能成长。天朝是不可能赢的，现在人人都说赢麻了，是真的吗？&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>构建二叉树解决Advent of Code 2021 18天</title>
        <published>2021-12-28T00:00:00+00:00</published>
        <updated>2021-12-28T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/build-a-binary-tree-to-solve-aoc-ay18/"/>
        <id>https://ghost.livexia.xyz/build-a-binary-tree-to-solve-aoc-ay18/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/build-a-binary-tree-to-solve-aoc-ay18/">&lt;p&gt;记录在2021.12.28日，利用 Rust 构建二叉树解决 Advent of Code 2021 18天。&lt;&#x2F;p&gt;
&lt;p&gt;代码仓库：&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;livexia&#x2F;advent-of-code-2021&#x2F;blob&#x2F;main&#x2F;aoc18&quot;&gt;livexia&#x2F;advent-of-code-2021 Day 18&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Advent of Code 网站：&lt;a href=&quot;https:&#x2F;&#x2F;adventofcode.com&#x2F;2021&#x2F;day&#x2F;18&quot;&gt;Advent of Code 2021 Day 18&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;在题目最初放出的时候，我曾就考虑过利用构建树来解决。但是那个时候我没有足够的耐心来理清楚所有的所有权的情况，于是最后我选择使用字符串解析的方式来完成。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;shu-jie-gou&quot;&gt;树结构&lt;&#x2F;h2&gt;
&lt;p&gt;根据题目所要求的，对于每个二叉树的节点的成员如下：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;可能有或者没有value&lt;&#x2F;li&gt;
&lt;li&gt;可能有或者没有左、右子节点&lt;&#x2F;li&gt;
&lt;li&gt;需要记录树的高度（深度）&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;所以我们可以这样描述树节点：(&lt;code&gt;Int&lt;&#x2F;code&gt; 是我指定的 &lt;code&gt;u8&lt;&#x2F;code&gt; 的别名)&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;Number {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;value&lt;&#x2F;span&gt;&lt;span&gt;: Option&amp;lt;Int&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;left&lt;&#x2F;span&gt;&lt;span&gt;: Option&amp;lt;Box&amp;lt;Number&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;right&lt;&#x2F;span&gt;&lt;span&gt;: Option&amp;lt;Box&amp;lt;Number&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;height&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;因为 Rust 无法确定一个结构体递归的包含自己时的大小，所以需要用 Box 将左右节点进行包装，也就是说编译器在编译的时候，知道这里是一个指针（Box）。在写这篇文章的时候， 我查到还有利用数组进行构造二叉树的情况。参见：&lt;a href=&quot;https:&#x2F;&#x2F;users.rust-lang.org&#x2F;t&#x2F;when-to-use-arrays-and-when-to-box-trees&#x2F;24805&quot;&gt;When to use arrays and when to box trees?&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jie-xi-zi-fu-chuan-gou-zao-shu-jie-dian&quot;&gt;解析字符串构造树节点&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;zi-fu-chuan-yu-chu-li&quot;&gt;字符串预处理&lt;&#x2F;h3&gt;
&lt;p&gt;读入的数据为字符串，每一行为一个数字。将字符串的每个字符转为对应的数字，并进行倒叙存储。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;from_str&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;s&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;str&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;Option&amp;lt;Box&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; stack: Vec&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; = s
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bytes&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;filter&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;c&lt;&#x2F;span&gt;&lt;span&gt;| !c.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;is_ascii_whitespace&lt;&#x2F;span&gt;&lt;span&gt;())
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;rev&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;collect&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;pop&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    Ok(Number::from_stack(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; stack))
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;di-gui-sheng-cheng-shu&quot;&gt;递归生成树&lt;&#x2F;h3&gt;
&lt;p&gt;弹出栈内容（这个时候弹出顺序应该是初始字符串的倒叙），针对所有可能的字符有如下的处理方式：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;‘[’ as u8：存在子节点，将剩余栈递归传入。&lt;&#x2F;li&gt;
&lt;li&gt;‘]’ as u8：当前节点所有成员构造完成，返回当前节点。&lt;&#x2F;li&gt;
&lt;li&gt;‘,’ as u8：当前节点只完成了左节点构造，仍需等待右节点。&lt;&#x2F;li&gt;
&lt;li&gt;数字：是当前节点的一个不存在左右节点，但是value为数字值的子节点（叶子节点）。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;from_stack&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;stack&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span&gt;Vec&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;) -&amp;gt; Option&amp;lt;Box&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; number = Number::new(None, None, None);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;while let &lt;&#x2F;span&gt;&lt;span&gt;Some(b) = stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;pop&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; b == &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;]&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39; as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;break&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else if&lt;&#x2F;span&gt;&lt;span&gt; b == &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39; as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;continue&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else if&lt;&#x2F;span&gt;&lt;span&gt; b == &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39; as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            number.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;add_child&lt;&#x2F;span&gt;&lt;span&gt;(Number::from_stack(stack));
&lt;&#x2F;span&gt;&lt;span&gt;        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            number.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;add_child&lt;&#x2F;span&gt;&lt;span&gt;(Some(Box::new(Number::with_value(b - &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39; as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;))));
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    number.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;update_height&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    Some(Box::new(number))
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;zeng-jia-zi-jie-dian&quot;&gt;增加子节点&lt;&#x2F;h3&gt;
&lt;p&gt;因为是倒叙弹出，那么每次增加节点的时候，必然是先增加左节点，然后是右节点，然后返回当前节点。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;add_child&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;child&lt;&#x2F;span&gt;&lt;span&gt;: Option&amp;lt;Box&amp;lt;Number&amp;gt;&amp;gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.left.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;is_none&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.left = child
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.right = child
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;ji-lu-shen-du&quot;&gt;记录深度&lt;&#x2F;h3&gt;
&lt;p&gt;因为后续需要根据节点深度判断是否进行操作，所以我选择以根节点深度为0，而叶子节点的深度最大的形式来存储节点深度。递归的对子树的深度进行更新。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;update_height&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Some(left) = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.left.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_mut&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;        left.height = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.height + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        left.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;update_height&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Some(right) = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.right.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_mut&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;        right.height = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.height + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        right.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;update_height&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;dui-shu-jin-xing-bao-zha&quot;&gt;对树进行爆炸&lt;&#x2F;h2&gt;
&lt;p&gt;根据题目的说明，理论上只有当节点的两个子节点都是叶子节点时才会出现爆炸的情况。&lt;&#x2F;p&gt;
&lt;p&gt;爆炸处理，就是当一个节点的高度大于3（从0开始）的时候，需要将该节点左子树的值给该子树左边最近的叶子节点，该节点右子树的值给该子树右边最近的叶子节点。对于树的遍历，存在前序、中序、后序和层次遍历四种，其中前序、中序、后序中大致都是先遍历左子树，然后遍历右子树的顺序，理论上在这里选择任意一种都无所谓，因为无论是哪一种情况都需要更新最新的最左边的节点。而层次遍历并无法针对题目的要求有何优点，不考虑。&lt;&#x2F;p&gt;
&lt;p&gt;针对当前节点深度大于3的情况，那么需要将当前节点的左子树的值传给最近的左子树，如果是从左到右的顺序，那么理论上我们可以更新一个变量，这个变量记录最左边的叶子节点的地址，因为需要对这个叶子节点进行修改，所以需要是 &lt;code&gt;mut&lt;&#x2F;code&gt; 。理论上，当前节点爆炸之后，当前节点无论再何种情况下都是会变成值为0的叶子节点。&lt;&#x2F;p&gt;
&lt;p&gt;假如当前的节点深度小于4，那么针对左右子树进行递归的搜索即可。针对题目的要求，每一次最多只有一个节点会爆炸，所以传递一个变量 exploded 记录是否已经出现过爆炸，如果已经出现过，那么不再进行爆炸。实际上假如不加入这个变量，那么在处于同一棵树下的两个子树的深度都大于3的情况时，会导致两次爆炸进行干扰。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;explode&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;(
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;&amp;#39;a mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;leftmost&lt;&#x2F;span&gt;&lt;span&gt;: Option&amp;lt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;&amp;#39;a mut &lt;&#x2F;span&gt;&lt;span&gt;Option&amp;lt;Box&amp;lt;Number&amp;gt;&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;right_value&lt;&#x2F;span&gt;&lt;span&gt;: Option&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;exploded&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; (Option&amp;lt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;&amp;#39;a mut &lt;&#x2F;span&gt;&lt;span&gt;Option&amp;lt;Box&amp;lt;Number&amp;gt;&amp;gt;&amp;gt;, Option&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.height &amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3 &lt;&#x2F;span&gt;&lt;span&gt;&amp;amp;&amp;amp; !exploded {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; right_value = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.right.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;take&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;().value;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.value = Some(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Some(left_value) = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.left.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;take&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;().value {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Some(Some(leftmost)) = leftmost {
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Some(value) = leftmost.value {
&lt;&#x2F;span&gt;&lt;span&gt;                    leftmost.value = Some(value + left_value);
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        (None, right_value, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;(leftmost, right_value, exploded) =
&lt;&#x2F;span&gt;&lt;span&gt;            Number::find_right(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.left, leftmost, right_value, exploded);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;(leftmost, right_value, exploded) =
&lt;&#x2F;span&gt;&lt;span&gt;            Number::find_right(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.right, leftmost, right_value, exploded);
&lt;&#x2F;span&gt;&lt;span&gt;        (leftmost, right_value, exploded)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;那么如何找到右边的第一个叶子节点呢？继续进行遍历，找到的第一个叶子节点就是当前节点右边的第一个子树。当找到时，修改该叶子节点的值。假如当前节点不是叶子节点时，对当前节点进行爆炸操作。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;find_right&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;(
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;child&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;&amp;#39;a mut &lt;&#x2F;span&gt;&lt;span&gt;Option&amp;lt;Box&amp;lt;Number&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;leftmost&lt;&#x2F;span&gt;&lt;span&gt;: Option&amp;lt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;&amp;#39;a mut &lt;&#x2F;span&gt;&lt;span&gt;Option&amp;lt;Box&amp;lt;Number&amp;gt;&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;right_value&lt;&#x2F;span&gt;&lt;span&gt;: Option&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;exploded&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; (Option&amp;lt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;&amp;#39;a mut &lt;&#x2F;span&gt;&lt;span&gt;Option&amp;lt;Box&amp;lt;Number&amp;gt;&amp;gt;&amp;gt;, Option&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; value = right_value.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; child.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ref&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;().value.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;is_some&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Some(value) = value {
&lt;&#x2F;span&gt;&lt;span&gt;            child.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_mut&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;().value =
&lt;&#x2F;span&gt;&lt;span&gt;                Some(child.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ref&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;().value.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;() + value);
&lt;&#x2F;span&gt;&lt;span&gt;            (leftmost, None, exploded)
&lt;&#x2F;span&gt;&lt;span&gt;        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            (Some(child), right_value, exploded)
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        child
&lt;&#x2F;span&gt;&lt;span&gt;            .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_mut&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;            .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;            .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;explode&lt;&#x2F;span&gt;&lt;span&gt;(leftmost, right_value, exploded)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;dui-shu-jin-xing-fen-lie&quot;&gt;对树进行分裂&lt;&#x2F;h2&gt;
&lt;p&gt;假如当前树存在叶子节点的值大于9的时候，需要对该叶子节点进行分裂。注意每次分裂，根据题目要求，只能对一个叶子节点进行分裂。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;split&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;bool &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Some(value) = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.value {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; value &amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;9 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; left_value = value &#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;add_child&lt;&#x2F;span&gt;&lt;span&gt;(Some(Box::new(Number::with_value(left_value))));
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;add_child&lt;&#x2F;span&gt;&lt;span&gt;(Some(Box::new(Number::with_value(value - left_value))));
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.value = None;
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;update_height&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;false
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.left.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_mut&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;split&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.right.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_mut&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;split&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;false
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;reducecao-zuo&quot;&gt;Reduce操作&lt;&#x2F;h2&gt;
&lt;p&gt;Reduce的流程是，不停的进行爆炸，直到树的深度都不大于3的时候，对树进行分裂，当树无法爆炸和分裂的时候，reduce完成。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;reduce&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; reduced = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;false&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;while &lt;&#x2F;span&gt;&lt;span&gt;!reduced {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; result = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;explode&lt;&#x2F;span&gt;&lt;span&gt;(None, None, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;false&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; result.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            reduced = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;false&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;continue&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        reduced = !&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;split&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;ji-suan-magnitude&quot;&gt;计算magnitude&lt;&#x2F;h2&gt;
&lt;p&gt;假如当前节点是叶子节点，直接返回节点的值。节点的magnitude，是左节点magnitude的3倍和右节点magnitude的2倍的和。递归进行计算即可。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;calc_magnitude&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Some(value) = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.value {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; value as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; result = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    result += &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3 &lt;&#x2F;span&gt;&lt;span&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.left.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ref&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;calc_magnitude&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    result += &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.right.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ref&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;calc_magnitude&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    result
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;zong-jie&quot;&gt;总结&lt;&#x2F;h2&gt;
&lt;p&gt;这次花了大概8个小时完成了这个遗留的任务，现在完成了反过来看，倒是没有那么复杂了。最复杂的地方就是爆炸遍历树的时候，需要记录并修改已经遍历过的节点，这就难倒了我。通过这次的重复练习，我对 Rust 中关于所有权和生命周期的理解更深了一点，对于利用迭代解决问题的思维更加熟悉了。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;针对涉及到的所有权和生命周期的几个小点：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对于 &lt;code&gt;Option&amp;lt;Box&amp;lt;TreeNode&amp;gt;&amp;gt;&lt;&#x2F;code&gt; 这样的节点 &lt;code&gt;node&lt;&#x2F;code&gt; ，假如需要修改这个节点，那么需要使用 &lt;code&gt;node.as_mut().unwrap()&lt;&#x2F;code&gt; 取得 &lt;code&gt;&amp;amp;mut Box&amp;lt;TreeNode&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;对于需要取得子节点的值，并设子节点为 &lt;code&gt;None&lt;&#x2F;code&gt; 的情况，可以使用 &lt;code&gt;take&lt;&#x2F;code&gt; 。这个时候的子节点的所有权就从节点中取得了，子节点生命周期不再同节点有关。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; node = Some(Box::new(TreeNode::new()));
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; left = node.left.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;take&lt;&#x2F;span&gt;&lt;span&gt;();    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; node.left.is_none();
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;对于需要将引用作为函数参数的情况中，不用害怕加上生命周期标志，特别是需要修改子树的情况中。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;对于涉及到递归的情况：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;注意递归在什么情况下会停止
&lt;ol&gt;
&lt;li&gt;在计算深度的时候，当不存在子节点的时候，递归就不再深入了。&lt;&#x2F;li&gt;
&lt;li&gt;在计算magnitude的情况中，当遇到叶子节点的时候，递归就不再深入了。&lt;&#x2F;li&gt;
&lt;li&gt;在进行分裂的情况中，当分裂已经发生时，递归就不再深入了。&lt;&#x2F;li&gt;
&lt;li&gt;在爆炸过程中，当左右叶子节点的值都耗尽时，递归就不再深入了。但是为了方便，我利用变量 exploded 来表示，实际上当爆炸发生过后，实际上递归就不再深入了。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;当前状态和下一个状态的关系
&lt;ol&gt;
&lt;li&gt;在计算深度的时候，子节点的深度是父节点的深度加一。&lt;&#x2F;li&gt;
&lt;li&gt;在计算magnitude的情况中，父节点的magnitude是子节点的magnitude计算而来。&lt;&#x2F;li&gt;
&lt;li&gt;在进行分裂的情况中，叶子节点的构造取决于父节点的值。&lt;&#x2F;li&gt;
&lt;li&gt;在爆炸过程中，下一个叶子节点的值需要加上当前节点的右叶子节点的值。对于左叶子，实际上是当前的左叶子的引用是由上一个状态更新的引用值。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;can-kao&quot;&gt;参考&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;gist.github.com&#x2F;aidanhs&#x2F;5ac9088ca0f6bdd4a370&quot;&gt;https:&#x2F;&#x2F;gist.github.com&#x2F;aidanhs&#x2F;5ac9088ca0f6bdd4a370&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86&quot;&gt;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;树的遍历&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;users.rust-lang.org&#x2F;t&#x2F;when-to-use-arrays-and-when-to-box-trees&#x2F;24805&#x2F;1&quot;&gt;https:&#x2F;&#x2F;users.rust-lang.org&#x2F;t&#x2F;when-to-use-arrays-and-when-to-box-trees&#x2F;24805&#x2F;1&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>参加2021年Advent of Code</title>
        <published>2021-12-25T00:00:00+00:00</published>
        <updated>2021-12-25T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/adventofcode2021/"/>
        <id>https://ghost.livexia.xyz/adventofcode2021/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/adventofcode2021/">&lt;p&gt;记录从2021.12.1日到2021.12.25日参与的Advent of Code。以下内容是记录在我的代码仓库中的。&lt;&#x2F;p&gt;
&lt;p&gt;代码仓库：&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;livexia&#x2F;advent-of-code-2021&quot;&gt;livexia&#x2F;advent-of-code-2021&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Advent of Code 网站：&lt;a href=&quot;https:&#x2F;&#x2F;adventofcode.com&quot;&gt;https:&#x2F;&#x2F;adventofcode.com&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;上一次参加的时候是在年初希望通过参加学习Rust，那个时候参加的是2018年的。今年这次是第一次即时参与，大部分的题目都是自己完成的，下面涉及到的这些题目都或多或少我有不足的部分，但是通过重写代码，并把思路写出来，也很好的帮助我理解题目和涉及到的算法， 当然有很多还是因为自己的不熟悉和思维定势。我也没有多少耐心，很容易想到一个解决办法，发现走不通然后换方法的时候，这种时候这个题目往往就做不出了。期待明年的题目。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;xu-yao-zhong-xin-kao-lu-de&quot;&gt;需要重新考虑的&lt;&#x2F;h2&gt;
&lt;p&gt;部分题目我采用了非常规的做法（day 18），或者用了题目输入输出的偶然性（day 19）而完成。这些题目我需要进一步的重新编写。记录中的题目虽然大部分都是有所不足的，但是这些不足更多的是在实现上有效率的问题，大体上是不存在严重问题的，而列表内的题目则是方法有误，所以最好能进行重写。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;del&gt;Day 18&lt;&#x2F;del&gt;: &lt;a href=&quot;&#x2F;build-a-binary-tree-to-solve-aoc-ay18&quot;&gt;构建二叉树解决Advent of Code 2021 18天&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Day 19&lt;&#x2F;li&gt;
&lt;li&gt;Day 23&lt;&#x2F;li&gt;
&lt;li&gt;Day 24&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;xu-yao-ti-sheng-de-neng-li&quot;&gt;需要提升的能力&lt;&#x2F;h2&gt;
&lt;p&gt;通过参加AdventOfCode，我发现自己有很多Rust、算法相关的短板。&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;利用 Rust 实现树结构和相关的操作&lt;&#x2F;li&gt;
&lt;li&gt;Rust 的 Itertools、hashbrown&lt;&#x2F;li&gt;
&lt;li&gt;更加熟练的递归&lt;&#x2F;li&gt;
&lt;li&gt;更加耐心和坚持的分析&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;ji-lu&quot;&gt;记录&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;day-14&quot;&gt;Day 14&lt;&#x2F;h3&gt;
&lt;p&gt;最初的想法是将规则存入一个HashMap，而将聚合物存入列表。对于每一次聚合，遍历聚合物的两个元素，根据元素从规则中找到新的三个聚合元素，并存入新的聚合物列表，遍历结束后再将新的聚合物列表替换原有的聚合物列表。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;&#x2F;strong&gt; 这个实现方式的效率极低，因为每次遍历的次数都是前一次的两倍，实际上是一个指数级的增长。那么对于N个元素，M次聚合，第N次需要至少遍历2^n个元素，总共的复杂度应该是 O(M*2^N)。&lt;&#x2F;p&gt;
&lt;p&gt;在无法快速取得结果后，我尝试观察每一次的结果，而花了大量的时间尝试寻找其中的规律。最后我只好求助于社区的答案，于是在twitter上找到了 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;dcreemer&#x2F;adventofcode&quot;&gt;dcreemer&#x2F;adventofcode&lt;&#x2F;a&gt; 的答案。我根据我看到的解决办法，利用 Rust 写了新的答案。&lt;&#x2F;p&gt;
&lt;p&gt;同样是将规则存入HashMap，但是这次以键是聚合物对，值是聚合物对出现的次数，将聚合物存入HashMap。对于每一次聚合，新建一个与聚合物相同的HashMap，遍历聚合物的两个元素，也就是一个聚合对，根据规则实际上一个聚合对在一次聚合之后，会生成两个新的聚合，那么新生成的两个聚合对的次数也就是旧友聚合对的次数，将新的聚合对和次数存入新的HashMap。每次聚合结束之后，再替换旧的聚合物HashMap为新的HashMap。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;&#x2F;strong&gt; 对于输入，总有10个元素，那么总共有100个元素对，对于每次聚合，元素对的总数不变，也就是只需要进行200次的HashMap插入操作。那么对于N个元素，M次聚合，总共的复杂度应该是 O(MN^2) 。这个方法的复杂度较我自己的方法是一个指数时间和二次时间的差别。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;对于计数的复杂度分析：&lt;&#x2F;strong&gt; 利用一个键为元素，值为个数的HashMap来对元素对出现次数进行统计，对于每一次聚合中的每一个聚合对，实际上只是增加了一个元素，那么在这时对HashMap的元素次数加一即可。总共进行 O(2^N) 次HashMap次数更新。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;day-15&quot;&gt;Day 15&lt;&#x2F;h3&gt;
&lt;p&gt;使用 Dijkstra 算法。使用 BinaryHeap 和 Reverse 实现一个最小堆，加快遍历速度。&lt;&#x2F;p&gt;
&lt;p&gt;参考：https:&#x2F;&#x2F;oi-wiki.org&#x2F;graph&#x2F;shortest-path&#x2F;#dijkstra&lt;&#x2F;p&gt;
&lt;h3 id=&quot;day-17&quot;&gt;Day 17&lt;&#x2F;h3&gt;
&lt;p&gt;花了很多时间尝试推导出初始速度的范围，&lt;del&gt;但是实际上暴力就可以解决了&lt;&#x2F;del&gt;，需要进行裁切，具体裁切的过程和分析请看代码注释。（物理的知识完全没有记住）&lt;&#x2F;p&gt;
&lt;p&gt;的确物理知识有些忘记了，但是题目中的探针实际上在每一个单一方向上并不是匀变速直线运动，所以不能使用匀变速直线运动的规律来确定速度范围。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;考虑x方向上的初始速度范围：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;当x方向上的速度减小到0时，还无法进入x的范围时，该初始速度无论如何无法达到目标范围。
&lt;strong&gt;也就是所在x方向上，对于每一个特定的初始速度，总有一个探针能在x方向上行进的最大距离。&lt;&#x2F;strong&gt;
当这个最大距离小于目标范围时，该初始速度一定无法使探针进入目标区域。
当x方向速度为0的时候，设x方向的初始速度为v，经过每一步速度减少1，那么总共经过v步速度为0。
那么实际上当x方向速度为0时，每一步经过的距离是公差为-1的等差数列。
所以x方向上探针经过的距离为 (v * v + v) &#x2F; 2，设为s。
那么对于任意的v，假如s小于目标区域的最小的x范围，该速度v无论如何无法达到目标范围。
实际上就是求解 (v * v + v) &#x2F; 2 &amp;gt;= x_min 这样一个一元二次不等式。
当x方向上的速度大于x的最大范围时，1步之后，探针就超出了x的目标范围。
那么x方向上的最大速度为x的最大范围。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;考虑y方向上的初始速度范围：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;因为初始位置不在区域范围内，所以至少需要1步 才能使探针在y方向的范围内。
无论探针初始速度是向上的还是向下的，那么最后总是需要以y向下的速度进入目标区域，因为目标区域在y=0之下。
&lt;strong&gt;当探针从y=0或者经过y=0向下运动时，每一步经过的距离实际上是以公差为1的等差数列。&lt;&#x2F;strong&gt;
所以在y向下的方向上，实际上不存在探针能探索的最大距离，与x方向不同。
那么即使当y=0的时候，x方向的速度为0，且x在目标范围内，探针一定能进入目标区域。
所以对于y方向，探针存在一个最大的同向、反向速度，但是不存在最小的同向、反向速度。&lt;&#x2F;p&gt;
&lt;p&gt;事实上对于一个特定的x方向的初始速度，存在一个时间范围，在这个时间范围内，探针能保证探针的x位置是位于目标范围内
那么理论上就可以根据这个时间范围和y的目标范围，推论出y的初始速度范围，&lt;strong&gt;需要增加运算复杂度，在此可以不看&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;考虑初始时y向下的大最大初始速度，也就是不论方向的最小初始速度
设y方向的范围为y1..y2，且y1 &amp;lt; y2, y2 &amp;lt; 0
那么当y方向的速度为 y1 - 1 的时候，只需要1步，探针就已经超出了y方向的范围
所以y方向的最小初始速度(同方向的最大速度)是 y1&lt;&#x2F;p&gt;
&lt;p&gt;考虑y方向的最大初始速度，这个时候探针应当是做向上的抛物线运动
那么探针会两次经过 y = 0 的位置
而第二次经过时探针y方向的速度应当与初始y方向的速度大小相同、方向相反，记为 v0&#x27;
假设第二次经过 y = 0，之后至少需要1步才能进入目标范围
那么当 v0&#x27; &amp;gt; y1 的时候只需要1步探针就超出了y方向的范围
故 y 的最大初始速度(反方向最大速度)应该是 -v0，也就是 -y1&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;可以看见实际上无论初始速度是向上还是向下的，最大的初始速度数值是一致的&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;day-18&quot;&gt;Day 18&lt;&#x2F;h3&gt;
&lt;p&gt;今天的题目大致上应该有两种方法解决，一是建立二叉树，二是对字符串进行处理&lt;&#x2F;p&gt;
&lt;p&gt;利用二叉树方法时，我没想到如何解决寻找附近节点的方法，花了一下午的时间，于是我决定简单的处理字符串的方式解决。&lt;&#x2F;p&gt;
&lt;p&gt;字符串的方式比较清晰，只有在细节上需要想的特别清楚。&lt;&#x2F;p&gt;
&lt;p&gt;现在想起来字符串的方法应该就是树的层次遍历（广度优先）。但是我对利用 Rust 来编写二叉树还是有很多的不理解，涉及到对子节点的修改时我就蒙圈了，需要加强这个方面的学习，如果明天还有时间就继续把建立二叉树的方法也完成吧。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;文件说明&lt;&#x2F;strong&gt;：&lt;&#x2F;p&gt;
&lt;p&gt;aoc18: 二叉树方法，失败中。&lt;&#x2F;p&gt;
&lt;p&gt;aoc18_with_string: 字符串方法，成功通过part1和part2，并且含有相应函数的测试。&lt;&#x2F;p&gt;
&lt;p&gt;参考：https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;rizw2c&#x2F;2021_day_18_solutions&lt;&#x2F;p&gt;
&lt;h3 id=&quot;day-19&quot;&gt;Day 19&lt;&#x2F;h3&gt;
&lt;p&gt;这个题目其实并不难，但是有好几个关键的部分，第一个部分是，坐标系的转动是如何的，第二个部分是如何确定两个scanner中的beacon是重叠的。&lt;&#x2F;p&gt;
&lt;p&gt;第一个部分，我假定对于每一个坐标位置，可能是x y z中的一种，然后它的符号可能是+、-中的一个，根据这样得出总共有48种可能性，但是题目中说明实际上只存在24种可能。我猜测是和旋转有关，48种可能性种应该有大量的情况是不可能发生的。我没有花大量的时间在确定具体是哪24种，我就按照48种进行了计算。我在Reddit上找到一个关于旋转的说明，大意是有一半的坐标系是不存在与真实世界的，参见：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;rjpf7f&#x2F;comment&#x2F;hp7tpyf&#x2F;?utm_source=share&amp;amp;utm_medium=web2x&amp;amp;context=3
https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;%E5%8F%B3%E6%89%8B%E5%AE%9A%E5%89%87&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;第二个部分，理论上对于一个已知的scanner的所有beacon坐标，和未知的scanner的一种旋转方式的坐标，从这两个集合中，进行选择组合，对每一个组合进行差值计算，得到一个新的坐标，利用HashMap统计每个新的坐标的出现次数，假如其中一个坐标出现次数超过12，那么这个坐标就是未知scanner的坐标。在这里我还是偷懒了，在选择组合的时候，我进行了全组合，也就是说，已知scanner中的每一个beacon都和未知scanner的一种选择的每一个beacon进行了差值计算，在这个基础上进行统计。我的方法严格上是不正确的，假设已知scanner有25个beacon，而未知sacnner的一种旋转方式也有25个beacon，那么理论上已知scanner的beacon对应未知scanner的beacon的选择组合，总共有 25！种组合方式，这还仅仅是一种旋转方式，然后对每一种组合方式分别进行统计。而我的方法实际上对于一种旋转方式只存在一种组合，组合的数量是25*25。虽然最后取得了正确的答案，但是实际上应该还是侥幸了。&lt;&#x2F;p&gt;
&lt;p&gt;关于这一点，我看了很多的Reddit上的解答，大部分的人都有一个假定，假如beacon A、B都出现在 scanner X 和 Y 中，那么A、B的顺序应该在两个scanner 中是一致的，也就是说对于这个假设的情况下是不需要进行组合测试的。&lt;&#x2F;p&gt;
&lt;p&gt;第二个部分我看到Reddit中有更加好的解决办法，只能留待后续继续实现了。参考 https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;rjpf7f&#x2F;comment&#x2F;hp8btm1&#x2F;?utm_source=share&amp;amp;utm_medium=web2x&amp;amp;context=3&lt;&#x2F;p&gt;
&lt;p&gt;参考：https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;rjpf7f&#x2F;2021_day_19_solutions&lt;&#x2F;p&gt;
&lt;h3 id=&quot;day-20&quot;&gt;Day 20&lt;&#x2F;h3&gt;
&lt;p&gt;对于给定的输入，实际上每一次图像增强之后，无限区域的像素会进行翻转，理论上这个条件下是无法给出每一次图像中所有亮着的像素点的数量的。但是题目求解的都是偶数次的情况，在偶数次时亮起的像素点是一个固定的数量，是可以进行求解的。&lt;&#x2F;p&gt;
&lt;p&gt;问题在于每次像素增强，输入图像一周的两个宽度的所有像素点都会受到影响，假如在一次像素增强中，所有周围的像素都没有被更新，那么理论上是不需要扩展图像的。假如不关心这一点，每次都将图像的一边增加2，那么50次之后，图像的大小将是200*200。而每次增强实际上是需要遍历其中每一个点的，那么就会导致运行时间极大的增加。&lt;&#x2F;p&gt;
&lt;p&gt;当前我对这个问题的优化是，先增加边界，当每一次增强结束时，再判断处于边界内的点是否完全都是dark。因为涉及到存在无限像素点翻转的情况，所以只在偶数次对本次和上一次边界内的点进行判断，也就是假如边界内的点全是dark，而偶数次时无限的像素点都是dark，所以实际上边界和无限是一样的，所以缩减边界。&lt;&#x2F;p&gt;
&lt;p&gt;在Debug下的运行时间从10s减少到5s。虽然有时间上的提升，但是很明显我这样的方法是浪费了很多的效率，也就是先扩展再缩减，很明显存在问题。需要思考更加合适的优化形式。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;将每次边界增加控制为1的时候，运行结果不变，不需要额外优化，时间既是5s。我找了一些网上的其他解决答案，测试了一下并没有发现比我自己的解决办法快多少。为什么只需要加1？因为我最初的理解有误，实际上只有周围的一个会收到影响，也就是3x3矩阵的中间会收到边上值的影响，这个时候边上和中间实际上只有差1。对于对角的值来说，它们之间互相不存在影响。所以每次边界只需要扩大1即可。在这种情况下，就不需要进行判断了，判断的成本较高，增加了代码的复杂度。&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;day-21&quot;&gt;Day 21&lt;&#x2F;h3&gt;
&lt;p&gt;第二个部分，每投掷一次骰子会生成3个宇宙，每一个宇宙骰子的结果分别是1、2、3。那么对于一个玩家投掷3次骰子，结束之后会有27个宇宙。如果直接按照这个思路进行实现，程序运行的极其慢。分析这27个宇宙可以发现实际上最终只有七种不同的结果，从3到9，每种结果对应有一个次数，也就是这个结果出现的次数。假设结果为6的宇宙7个，假设第一次玩家1投掷出了6，那么对于玩家2来说，无论玩家2投掷出什么，玩家2的投掷结果都已经出现了7次（7个宇宙中，玩家1都投掷出了6），以此类推，每次都累积当前玩家的出现次数，在取胜时统计结果即可。&lt;&#x2F;p&gt;
&lt;p&gt;看了Reddit上的一些解法，他们利用HashMap进行cached，减少计算的次数。参考：https:&#x2F;&#x2F;github.com&#x2F;AxlLind&#x2F;AdventOfCode2021&#x2F;blob&#x2F;main&#x2F;src&#x2F;bin&#x2F;21.rs&lt;&#x2F;p&gt;
&lt;p&gt;我自己参考实现了一下，我的理解是这个缓存从最底下开始进行，对于一次投掷的所有情况进行考虑，统计在这种情况下，各赢多少并累加。然后再把这个数字和这个投掷出现的次数进行相乘，也就是假如上一次投掷的结果是现在这样的，会有多少赢家。每次把当下的位置和当前的得分以及这个位置和得分下输赢情况存入缓存，那么下次再遇到直接取用即可。逐渐从投掷一次就赢的情况计算至输入时的情况，最后输入的得分就是两个玩家赢的次数。&lt;&#x2F;p&gt;
&lt;p&gt;投掷的时候不需要对两个玩家进行循环，实际上每次只要对一个位置的玩家进行投掷移动处理，然后把两个玩家交换位置即可，减少需要记录的内容。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;day-22&quot;&gt;Day 22&lt;&#x2F;h3&gt;
&lt;p&gt;应该是到目前为止我觉得最难的题目了，这道题目最直观的方法就是暴力，遍历所有可能的点，然后根据每一步取得最终的状态，但是很明显第一部分都足够的慢了，于是第二个部分肯定是不能用这种方法了。&lt;&#x2F;p&gt;
&lt;p&gt;其实第二个方法也不难想到，那就是把每一行的输入都看作一个长方体，这个长方体存在四个属性，长方体里的小立方体的状态、x、y和z的范围。长方体的体积就是立方体的数量。&lt;&#x2F;p&gt;
&lt;p&gt;考虑体积为 a 是长方体 A 和体积为 b 的长方体 B，假如A和B存在重叠，那么重叠的部分应该也是一个长方体，设重叠部分的长方体为体积为c的长方体 C。对于 A 和 B 存在以下四种情况：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;A 和 B 的状态都是 on，那么A和B中总共包含的立方体数量就是，a + b - c&lt;&#x2F;li&gt;
&lt;li&gt;A 是 on，B 是 off，那么A和B中总共包含的立方体数量就是，a - c&lt;&#x2F;li&gt;
&lt;li&gt;A 是 off，B 是 on，那么A和B中总共包含的立方体数量就是，b&lt;&#x2F;li&gt;
&lt;li&gt;A 是 off，B 是 off，那么A和B中总共包含的立方体数量就是 0&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;看起来很简单，但是实际上存在其他的问题。对于题目的输入，初始时不存在长方体，那么对于输入中的第一条为on的长方体应该就是最初的长方体。接下来这个初始长方体会进行下一步，取得下一步输入的立方体，无论这个输入的长方体的状态为何，当这一步结束的时候，输出的已经不再是长方体了，而是多个长方体的组合。而这个长方体的组合，又要接受新的输入，所以简单计算每一次输入之后体积的变化是不够的，因为后续还需要对之前的长方体进行变换。&lt;&#x2F;p&gt;
&lt;p&gt;以下是这个部分的 Rust 代码：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;Rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-Rust &quot;&gt;&lt;code class=&quot;language-Rust&quot; data-lang=&quot;Rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; stack: Vec&amp;lt;Cuboid&amp;gt; = vec![]; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 初始化空栈，用来存储每次变化之后所有的长方体
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; next_cuboid in &amp;amp;cuboids[..] {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 遍历每一次变化的长方体
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; new_stack = vec![]; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 建立新栈，防止在后续遍历对栈的直接修改，导致逻辑错误
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; cuboid in &amp;amp;stack {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 循环遍历栈中的长方体
&lt;&#x2F;span&gt;&lt;span&gt;            new_stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;(cuboid.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;()); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 直接在新栈中存入当前的长方体
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Some(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; sub_cuboid) = cuboid.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;sub_cuboid&lt;&#x2F;span&gt;&lt;span&gt;(next_cuboid) {
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 计算当前长方体和输入长方体的重叠区域
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 防止累加两次重叠和减去两次重叠
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; cuboid.state == next_cuboid.state {
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 假如当前长方体和输入长方体的状态一致，重叠长方体的状态应该取反
&lt;&#x2F;span&gt;&lt;span&gt;                    sub_cuboid.state = !next_cuboid.state;
&lt;&#x2F;span&gt;&lt;span&gt;                } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 状态不一致时，重叠区域的状态应该和输入长方体的状态一致
&lt;&#x2F;span&gt;&lt;span&gt;                    sub_cuboid.state = next_cuboid.state;
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;                new_stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;(sub_cuboid); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 把重叠区域的长方体放入栈中
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; next_cuboid.state {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 假如输入的长方体状态为打开，那么直接把输入推入栈中即可
&lt;&#x2F;span&gt;&lt;span&gt;            new_stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;(next_cuboid.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;());
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        stack = new_stack; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 更新栈
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;具体说明：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;最初的栈中没有任何的长方体，当遇到输入的长方体为 on 的时候，将输入长方体推入栈。当栈中存在长方体时，需要进一步考虑。&lt;&#x2F;p&gt;
&lt;p&gt;考虑当前栈中的长方体 A 和输入长方体 B，假如A和B存在重叠，那么重叠的部分应该也是一个长方体，设重叠部分的长方体为长方体 C。对于 A 和 B 存在以下四种情况：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;A 和 B 的状态都是 on，&lt;strong&gt;长方体 A 和 B 都会被推入栈中&lt;&#x2F;strong&gt;，但是这个时候，A 和 B 的重叠区域就被重复计算了两次，所以向栈中&lt;strong&gt;推入状态为 off 的 长方体 C&lt;&#x2F;strong&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;A 是 on，B 是 off，&lt;strong&gt;长方体 A 会被推入栈中&lt;&#x2F;strong&gt;，但是这个时候，A 和 B 的重叠区域就被重复计算了，所以向栈中&lt;strong&gt;推入状态为 off 的 长方体 C&lt;&#x2F;strong&gt;，表示重叠区域 C 是需要被减去的。&lt;&#x2F;li&gt;
&lt;li&gt;A 是 off，B 是 on，&lt;strong&gt;长方体 B 会被推入栈中&lt;&#x2F;strong&gt;，因为是新的输入覆盖老的输入，所以向栈中&lt;strong&gt;推入状态为 on 的 长方体 C&lt;&#x2F;strong&gt;，表示重叠区域 C 是需要被加上的。&lt;&#x2F;li&gt;
&lt;li&gt;A 是 off，B 是 off，&lt;strong&gt;长方体 A 和 B 会不被推入栈中&lt;&#x2F;strong&gt;，栈中的所状态为 off 的长方体都是由重叠产生的，那么 A 和 B 的重叠区 C 已经在重叠区域中表示了。所以向栈中&lt;strong&gt;推入状态为 on 的 长方体 C&lt;&#x2F;strong&gt;，表示新的重叠区域 C 是需要被加上的，防止重复减去重叠区域。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;最后只需要对栈中所有的长方体进行体积计算，加上状态为 on 的长方体体积，减去状态为 off 的长方体体积，最后的结果就是所有步骤之后立方体的数量。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;计算重叠区域的长方体&lt;&#x2F;strong&gt;：这个部分是我觉得最难的地方，因为我想的太复杂了，没有想着从一条边的情况开始考虑，实际上长方体就是长方形的累积，长方形就是线段的累积，线段的累积是好分分析的，那么只需要从线段开始，就可以轻易得出重叠部分。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;考虑一条线段的重叠情况&lt;&#x2F;strong&gt;：假如一个线段的起点落在另一个线段中，那么这两个线段就存在重叠区域。具体计算和说明见以下 Rust 代码：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;Rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-Rust &quot;&gt;&lt;code class=&quot;language-Rust&quot; data-lang=&quot;Rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;sub_edge&lt;&#x2F;span&gt;&lt;span&gt;((&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;): (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i64&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i64&lt;&#x2F;span&gt;&lt;span&gt;), (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;low&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;high&lt;&#x2F;span&gt;&lt;span&gt;): (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i64&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i64&lt;&#x2F;span&gt;&lt;span&gt;)) -&amp;gt; Option&amp;lt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i64&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i64&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; a &amp;gt; high {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 假如一条线段的最小端大于另一条线段的最大端，则不存在重叠区域
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;None;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; b &amp;lt; low {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 假如一条线段的最大端小于另一条线段的最小端，则不存在重叠区域
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;None;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; low = low.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;max&lt;&#x2F;span&gt;&lt;span&gt;(a); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 重叠线段的最小端是，两条线段最小端中较大的那个
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; high = high.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;min&lt;&#x2F;span&gt;&lt;span&gt;(b); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 重叠线段的最大端是，两条线段最大端中较小的那个
&lt;&#x2F;span&gt;&lt;span&gt;    Some((low, high))
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;考虑长方形的重叠情况&lt;&#x2F;strong&gt;：假如两个长方体的一边都不存在重叠区域，那么两个长方体肯定不会重叠。而重叠区域的计算，应该就是两条边分别计算重叠边，这两条重叠边的区域就是重叠区域。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;考虑长方体的重叠情况&lt;&#x2F;strong&gt;：根据长方形的情况类推即可，代码见如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;Rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-Rust &quot;&gt;&lt;code class=&quot;language-Rust&quot; data-lang=&quot;Rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;sub_cuboid&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;other&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;Cuboid) -&amp;gt; Option&amp;lt;Cuboid&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; x = Cuboid::sub_edge(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.x, other.x)?;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; y = Cuboid::sub_edge(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.y, other.y)?;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; z = Cuboid::sub_edge(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.z, other.z)?;
&lt;&#x2F;span&gt;&lt;span&gt;    Some(Cuboid {
&lt;&#x2F;span&gt;&lt;span&gt;        state: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.state,
&lt;&#x2F;span&gt;&lt;span&gt;        x,
&lt;&#x2F;span&gt;&lt;span&gt;        y,
&lt;&#x2F;span&gt;&lt;span&gt;        z,
&lt;&#x2F;span&gt;&lt;span&gt;    })
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;优化&lt;&#x2F;strong&gt;：
在计算的过程中，我利用栈来进行统计，实际上可以用HashMap来加快统计，代码见如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;Rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-Rust &quot;&gt;&lt;code class=&quot;language-Rust&quot; data-lang=&quot;Rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;calc_volume_with_hashmap&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;cuboids&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;[Cuboid]) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i64 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; counters: HashMap&amp;lt;Cuboid, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i64&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; = HashMap::new(); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 初始化空表，用来存储每次变化之后所有的长方体和长方体出现的次数
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; next_cuboid in &amp;amp;cuboids[..] {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; new_counters = counters.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;(); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 复制为新的HashMap，防止遍历HashMap的过程中对其进行修改，导致逻辑错误
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;(cuboid, count) in counters {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 遍历上一次的长方体
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Some(sub_cuboid) = cuboid.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;sub_cuboid&lt;&#x2F;span&gt;&lt;span&gt;(next_cuboid) {
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 计算重叠区域
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 重叠区域的次数为减去当前长方体的次数
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 类似于利用栈实现的时候，新的长方体的状态为当前长方体的取反，具体见栈的实现的说明
&lt;&#x2F;span&gt;&lt;span&gt;                *new_counters.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;entry&lt;&#x2F;span&gt;&lt;span&gt;(sub_cuboid).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;or_insert&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;) -= count;
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; next_cuboid.state {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 假如输入长方体状态为 on， 直接将表中的长方体的值加一，即出现次数加1
&lt;&#x2F;span&gt;&lt;span&gt;            *new_counters.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;entry&lt;&#x2F;span&gt;&lt;span&gt;(next_cuboid.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;()).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;or_insert&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;) += &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        counters = new_counters;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 计算总体积的时候，要将长方体的体积乘上长方体出现的次数
&lt;&#x2F;span&gt;&lt;span&gt;    counters.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;iter&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;map&lt;&#x2F;span&gt;&lt;span&gt;(|(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;c&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;w&lt;&#x2F;span&gt;&lt;span&gt;)| c.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;volume&lt;&#x2F;span&gt;&lt;span&gt;() * w).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;sum&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;结果&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;shell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-shell &quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span&gt;there is 420 steps
&lt;&#x2F;span&gt;&lt;span&gt;Part1: ther is 648681 cubes are on the initialization procedure region
&lt;&#x2F;span&gt;&lt;span&gt;Part 1 took 8.63525ms to computer
&lt;&#x2F;span&gt;&lt;span&gt;Part2: there is 1302784472088899 cubes
&lt;&#x2F;span&gt;&lt;span&gt;Part 2 with stack took 790.735791ms to computer
&lt;&#x2F;span&gt;&lt;span&gt;Part2: there is 1302784472088899 cubes
&lt;&#x2F;span&gt;&lt;span&gt;Part 2 with HashMap took 264.527791ms to computer
&lt;&#x2F;span&gt;&lt;span&gt;cargo run &amp;lt; input&#x2F;input.txt  1.28s user 0.37s system 75% cpu 2.177 total
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看见 HashMap 的时间快了很多，理论上还能进行优化，但是这些优化都是极小的，所以就不再引入了。&lt;&#x2F;p&gt;
&lt;p&gt;参考：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;rlxhmg&#x2F;2021_day_22_solutions&#x2F;
https:&#x2F;&#x2F;github.com&#x2F;satylogin&#x2F;aoc&#x2F;blob&#x2F;main&#x2F;archive-2021&#x2F;day_22.rs&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;day-23&quot;&gt;Day 23&lt;&#x2F;h3&gt;
&lt;p&gt;今天不知为何没有写代码的状态，下午在电脑前面挠头抓额还是没好好的写。今天的题目是我不喜欢的那种题目，麻烦。&lt;&#x2F;p&gt;
&lt;p&gt;计算出当前状态的所有下一步的可能性和这些下一步所需要的能量。存入HashMap和最小堆。&lt;&#x2F;p&gt;
&lt;p&gt;初始时最小堆中仅有初始状态，每次对最小堆的顶部进行下一步操作，假如顶部的元素能够满足最终状态的要求，那么此时的答案就是最终的结果。假如不满足继续进行移动，假如当前堆顶已经在HashMap中出现过，且当前堆顶的能量消耗大于HashMap中对应当前堆顶元素的能力，说明当前堆顶并非最优解的一部分，之后的移动可以不看。&lt;&#x2F;p&gt;
&lt;p&gt;计算当前堆顶的所有下一步的可能状态，同样在HashMap中查找是否出现过，假如出现过且下一步的能量大于HashMap中对应的能量，这个下一步也不是最优解的一部分，可以直接舍弃。将所有可能是最优解的下一步可能存入最小堆和HashMap。最终即可找到最优解。&lt;&#x2F;p&gt;
&lt;p&gt;HashMap是用来减少计算次数的，也就是剪枝叶。最小堆也是为了减少计算复杂度的，优先计算当前最少的能量消耗的下一步，更有可能找到答案。这两个部分其实都不麻烦，即使我想不到用其他的方法也应该能得到类似的结果，但是为什么我没这么做呢？&lt;&#x2F;p&gt;
&lt;p&gt;我花了大量的时间在想要怎么表示输入的数据，是把过道和房间分开看、还是合起来看。结果我都想试一下，然后发现走不通的时候，我又想换一个表示形式，当我想到不如直接用二阶char数组表示的时候，我的耐心已经没有了。花了太多的时间在这个上面，于是也没有仔细想那些移动的可能性。最后我翻了翻Reddit，上面很多人都是手推的，那我想我也试试看吧。&lt;&#x2F;p&gt;
&lt;p&gt;第一部分自己手推，推出了答案，但是第二部分我就推不出来了，所以在网上找了一个人的代码，直接抄袭的。&lt;&#x2F;p&gt;
&lt;p&gt;虽然结果是出来了，但是我并没有学到什么，应该说浪费了很多时间。晚上我不再想花时间进去了，刚刚看的代码还记忆犹新，明天早上再来自己实现吧。&lt;&#x2F;p&gt;
&lt;p&gt;24号早上自己实现了一下，相比原有代码加强了规则的限定，具体移动参见代码部分注释，在此不进行列出。&lt;&#x2F;p&gt;
&lt;p&gt;参考：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;rmnozs&#x2F;2021_day_23_solutions&#x2F;
https:&#x2F;&#x2F;github.com&#x2F;AxlLind&#x2F;AdventOfCode2021&#x2F;blob&#x2F;main&#x2F;src&#x2F;bin&#x2F;23.rs
https:&#x2F;&#x2F;oi-wiki.org&#x2F;graph&#x2F;shortest-path&#x2F;#dijkstra&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;day-24&quot;&gt;Day 24&lt;&#x2F;h3&gt;
&lt;p&gt;背景都很容易，解释执行类似于汇编语言的指令。但是求解的目标是计算出能通过输入程序的最大值，输入是14位长的由1～9构成的数字，暴力遍历。暴力的速度实在不够，&lt;&#x2F;p&gt;
&lt;p&gt;之前写的aoc也有类似的题目，我记得那个题目是分析了输入，优化了输入中的循环。所以我又花了及其多的时间，分析输入。输入是由14组类似的代码块组成的，每一块只有三个部分不同。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;asm&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-asm &quot;&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;inp w
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mul &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;add &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;x z
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;mod x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;26    
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;div &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;z &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;26&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;26&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;26&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;26&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;26&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;26&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;26&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;add &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;15&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;14&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;15&lt;&#x2F;span&gt;&lt;span&gt;, -&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span&gt;, -&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;16&lt;&#x2F;span&gt;&lt;span&gt;, -&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;11&lt;&#x2F;span&gt;&lt;span&gt;, -&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;12&lt;&#x2F;span&gt;&lt;span&gt;, -&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;7&lt;&#x2F;span&gt;&lt;span&gt;, -&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;15&lt;&#x2F;span&gt;&lt;span&gt;, -&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;7
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;eql x w
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;eql x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mul &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;y &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;add &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;y &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;25
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mul &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;y x
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;add &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;y &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mul &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;z y
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mul &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;y &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;add &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;y w
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;add &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;y &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;16&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;9&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;12&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;6&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;6&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;9&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mul &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;y x
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;add &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;z y
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;化简成Rust代码大致如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;Rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-Rust &quot;&gt;&lt;code class=&quot;language-Rust&quot; data-lang=&quot;Rust&quot;&gt;&lt;span&gt;x = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;x = z % &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;26&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;z &#x2F;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 1, 1, 1, 1, 26, 1, 26, 26, 1, 26, 1, 26, 26, 26,
&lt;&#x2F;span&gt;&lt;span&gt;x += &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 10, 15, 14, 15, -8, 10, -16, -4, 11, -3, 12, -7, -15, -7
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;x = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; x == w { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;} &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;z = z * (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;25 &lt;&#x2F;span&gt;&lt;span&gt;* x + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; x 为 0 或 1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; x == 0 =&amp;gt; z = z
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; x == 1 =&amp;gt; z = 26 * z
&lt;&#x2F;span&gt;&lt;span&gt;z = z + (w + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;) * x; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; k: 2, 16, 9, 0, 1, 12, 6, 6, 3, 5, 9, 3, 2, 3
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; x == 0 =&amp;gt; z = z
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; x == 1 =&amp;gt; z = z + w + k
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;我瞪着这个代码看了大概一个小时，没有想到任何能让z保持0的情况，理论上只有当 x == w 的时候，z才不会增长，那么假如z初始就为0，而且每次x都和w相同，那么就没有问题。假如z=0，那么x += 10那一条语句就极其重要了，因为这个时候，x就完全等于所赋的值，但是可以看到这个值不可能是输入w，所以这个方法显然是有问题的。&lt;&#x2F;p&gt;
&lt;p&gt;无果之后我决定求助Reddit，这个时候我已经没有耐心再看大家的分析了，于是我决定找一份代码来研究研究，参见：https:&#x2F;&#x2F;github.com&#x2F;AxlLind&#x2F;AdventOfCode2021&#x2F;blob&#x2F;main&#x2F;src&#x2F;bin&#x2F;24.rs。&lt;&#x2F;p&gt;
&lt;p&gt;代码很直接，暴力加上缓存。因为第一部分是求解最大的输入，那么从9开始进行判断，遇到的第一个通过的数字应该是最大的数字。下面是我的实现，参见代码注释：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;Rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-Rust &quot;&gt;&lt;code class=&quot;language-Rust&quot; data-lang=&quot;Rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;find_model_number&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;cache&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span&gt;HashMap&amp;lt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i64&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;), Option&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i64&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;alu&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; ALU,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;blocks&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;[Vec&amp;lt;Instruction&amp;gt;],
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;index&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;digits&lt;&#x2F;span&gt;&lt;span&gt;: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i64&lt;&#x2F;span&gt;&lt;span&gt;; 9],
&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Option&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i64&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; cache：HashMap实现的缓存，key是z的值和当前运行到的代码块，value是当前的输入数字的倒叙
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; alu：计算单元，含有四个变量，理论上可以用z代替，因为每次计算之后，实际上只有z的值是重要的，wxy的值都会在下一次运行被清零
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; blocks：所有的代码块
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; index：当前运行的代码块
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; digits：所有可能的数字排列
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 首先保存当前的z值
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; z = alu.variables[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Some(&amp;amp;answer) = cache.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;get&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;(z, index)) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; answer;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; d in digits {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 修改alu的z值为上一个代码块运行后的z值
&lt;&#x2F;span&gt;&lt;span&gt;        alu.variables[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;] = z;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 执行新的代码块
&lt;&#x2F;span&gt;&lt;span&gt;        alu.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;execute&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;[d], &amp;amp;blocks[index]);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 记录新的z值为new_z
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; new_z = alu.variables[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; index + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;== blocks.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; index为13的时候，说明当前的输入已经达到了14位数字
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; new_z == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 假如这个时候的z值为0，实际上这个时候应该就是所要求的值了，不论是最大还是最小的
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 但是注意这里返回的是第十四位的数字
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 可以看出来，需要走到这里才能找到完整的输入数字
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 将结果存入缓存&#x2F;记忆
&lt;&#x2F;span&gt;&lt;span&gt;                cache.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;insert&lt;&#x2F;span&gt;&lt;span&gt;((new_z, index), Some(d));
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 返回当前数字，用来拼接完整的数字
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;Some(d);
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;continue&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Some(best) = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;find_model_number&lt;&#x2F;span&gt;&lt;span&gt;(cache, alu, blocks, index + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, digits) {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 找到下一个满足要求的数字
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 实际上这里得到的应该是倒叙算出的数字
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 将结果存入缓存&#x2F;记忆
&lt;&#x2F;span&gt;&lt;span&gt;            cache.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;insert&lt;&#x2F;span&gt;&lt;span&gt;((new_z, index), Some(best * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10 &lt;&#x2F;span&gt;&lt;span&gt;+ d));
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; best是计算是之后的输入数字，将best乘10再加上当前的数字
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 就是截止目前为止的所有输入
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;Some(best * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10 &lt;&#x2F;span&gt;&lt;span&gt;+ d);
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 假如没有找到，直接返回None
&lt;&#x2F;span&gt;&lt;span&gt;    cache.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;insert&lt;&#x2F;span&gt;&lt;span&gt;((z, index), None);
&lt;&#x2F;span&gt;&lt;span&gt;    None
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;写完之后其实发现并不是很复杂，但是为什么我没有想到呢？第一方面我对递归还是认知太少，写的太少了。我在运动的时候还在想这个题目，实际上我已经知道大致是这样一个暴力加记忆的优化，但是我没有想到很到的怎么组合14个数字，没想到用递归实现。&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;等我写完代码之后，我突然意识到实际上z变为0除了每次z都是0之外，还有在指令 div z 1（div z 26）的时候。但是我还是不想一个一个分析，不过倒是可以把上面的分析代码化，直接通过函数算出z值，就不再通过ALU了。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;Rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-Rust &quot;&gt;&lt;code class=&quot;language-Rust&quot; data-lang=&quot;Rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;calc&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;w&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i64&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;z&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i64&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;index&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i64 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; div z [k]
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; k = [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;26&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;26&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;26&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;26&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;26&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;26&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;26&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; add x [p]
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; p = [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;15&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;14&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;15&lt;&#x2F;span&gt;&lt;span&gt;, -&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span&gt;, -&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;16&lt;&#x2F;span&gt;&lt;span&gt;, -&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;11&lt;&#x2F;span&gt;&lt;span&gt;, -&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;12&lt;&#x2F;span&gt;&lt;span&gt;, -&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;7&lt;&#x2F;span&gt;&lt;span&gt;, -&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;15&lt;&#x2F;span&gt;&lt;span&gt;, -&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;7&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; add y [q]
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; q = [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;16&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;9&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;12&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;6&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;6&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;9&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; x = z % &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;26 &lt;&#x2F;span&gt;&lt;span&gt;+ p[index];
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; z = z &#x2F; k[index];
&lt;&#x2F;span&gt;&lt;span&gt;    x = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; x == w { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;} &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;    z = z * (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;25 &lt;&#x2F;span&gt;&lt;span&gt;* x + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    z = z + (w + q[index]) * x;
&lt;&#x2F;span&gt;&lt;span&gt;    z
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;结果&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Part1: &quot;98491959997994&quot;, took: 846.150333ms
Part1 with trimed func: &quot;98491959997994&quot;, took: 103.46275ms
Part2: &quot;61191516111321&quot;, took: 24.101829375s
Part2 with trimed func: &quot;61191516111321&quot;, took: 3.891638208s&lt;&#x2F;p&gt;
&lt;p&gt;自己裁减的函数的运行速度，快了很多。假如我能想到用递归的方式遍历，也许我也能自己实现了。&lt;&#x2F;p&gt;
&lt;p&gt;参考：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;adventofcode&#x2F;comments&#x2F;rnejv5&#x2F;2021_day_24_solutions&#x2F;
https:&#x2F;&#x2F;github.com&#x2F;AxlLind&#x2F;AdventOfCode2021&#x2F;blob&#x2F;main&#x2F;src&#x2F;bin&#x2F;24.rs
https:&#x2F;&#x2F;github.com&#x2F;dphilipson&#x2F;advent-of-code-2021&#x2F;blob&#x2F;master&#x2F;src&#x2F;days&#x2F;day24.rs
https:&#x2F;&#x2F;oi-wiki.org&#x2F;dp&#x2F;memo&#x2F;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>长日将尽，安稳入睡</title>
        <published>2021-12-22T00:00:00+00:00</published>
        <updated>2021-12-22T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/the-remain-of-the-day-note/"/>
        <id>https://ghost.livexia.xyz/the-remain-of-the-day-note/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/the-remain-of-the-day-note/">&lt;blockquote&gt;
&lt;p&gt;《长日将尽》-- 石黑一雄 读后感&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;he-zhe-ben-shu-de-ji-yu&quot;&gt;和这本书的际遇&lt;&#x2F;h2&gt;
&lt;p&gt;查了一下记录这本书是在2018年买的，那个时候我还是一个无知懵懂的大学生，期待着能走出学校在自己擅长的领域作出努力。到2019年的时候，我已经如愿进入了大企业，和大学的时候一样，我的生活不能说完美，但是也没有很多的悔恨和痛苦。于是在刚买这本书的时候，我没能坚持看下去，当我决定在19年再读的时候，我发现我还是没有办法继续阅读，即使我又在Kindle上买了这本书。&lt;&#x2F;p&gt;
&lt;p&gt;那么是什么让我在2021年年末阅读完了这本书呢？一方面是因为我先读了石黑一雄的《克拉拉与太阳》，读完之后我觉得很喜欢，但是在七月读完之后，我没有去看任何的书评，在我决定重新拿起《长日将尽》的时候，我决定去看一眼其他人对《克拉拉与太阳》的书评，我才意识到我没有发现石黑一雄的写作手法，也就是我没有意识到书里的第一人称的观察者，是有不可靠的可能性的。&lt;&#x2F;p&gt;
&lt;p&gt;观察者是必然自带其当局限性的，一旦把我们自己代入观察者的角色，我们也会有这样的问题，自己的记录也是如此。一旦我意识到了这一点，我就对石黑一雄的作品产生了极大的兴趣，今年我开始对自己的生活进行记录，我也意识到了自己写下的，总是会存在闪躲，我想看看石黑一雄笔下的文字是否也是如此。&lt;&#x2F;p&gt;
&lt;p&gt;另一方面是因为我自己的境遇也发生了变化，相比于读书和刚开始工作时，那种没有什么烦忧的生活，在2020年我的生活因为一件事情产生了极大的变化。这是一件很俗套的事情，我的初恋和我分手了，而当我一个人坐在那个9平米不到的出租屋里，我意识到我没办法在这样的状态中继续前进，于是我终于决定离开我想要离开的公司，我以神奇的速度，打包好了所有的东西，然后在离职后的周末我就回到了家里。除了这件事情，工作越来越无法让我感觉自己有价值，我的效率被消耗在没人能够拍板的事情中，我开始做我不喜欢的事情。而2020年初仿佛是逃难一般的从家乡回到城市工作，回到城市又因为现实情况被拦截在小区门口，那个下午我站在小区门口和大家一样不知如何是好的时候，我的手机把所有能打的酒店电话都打了个遍，而当我就以为自己要去公园露宿的时候，终于我找到了愿意接受我的酒店，于是我开始了14天的酒店隔离。经历这一切加上我开始被安排到我毫无认知的工作中的时候，我开始对工作产生了厌恶，但是出于自身的怯懦，我却迟迟无法下决心。而当我的亲密关系破裂的时候，我突然意识到我的时候是有问题的，于是我抛开一切回到家里无所事事，每天做的事情就是看书、思考和记录。自己境遇的变化让我能够更加有耐心的读书，这是让我坚持阅读的很重要的原因。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;shi-ji-shu-ping&quot;&gt;实际书评&lt;&#x2F;h2&gt;
&lt;p&gt;首先石黑一雄和译者的文字能力实在是强，即使是我意识到了这个观察者是不可靠的，管家的形象是完美的体现了出来，有的时候我并不是当作小说来读，我是当作日记来读。这本书并没有讲述一个宏大的故事，所有事情都是围绕着管家展开的，毕竟他就是这本书的主人公，也是观察者和讲述者。管家现在生活的时代是在二战之后，那个日不落的帝国衰落了，而管家的服务对象也从英国本土的显赫勋爵变成了一个美国人，手下的仆从也只剩下四五人。管家的回忆中的事件大都发生在一战和二战之间，回忆中和发生在庄园中能够影响国际政治的大事件一同发生的就是管家自己的生活。第一次大事件发生的生活，管家的父亲逝世了。第二次大事件发生的时候，管家和肯顿小姐的姻缘就此消散。&lt;&#x2F;p&gt;
&lt;p&gt;管家为了恪守自己的行为准则，那就是要有“尊严”的为一个伟大的主人服务，直到这个主人实现了自己的伟大抱负。他一心觉得自己寻找的主人是伟大的，但是却为主人的不足进行了各种辩解。管家他的确是服务了一个不错的主人，但是从他自己的话语中，也可以看出他是对这一点有怀疑的，他不断的探讨怎么样才是一个有”尊严“的伟大管家，但是却两次否认自己曾经服务过前任勋爵。&lt;&#x2F;p&gt;
&lt;p&gt;除了他希望自己的事业是属于伟大的行列的，但是却并没有如同他想象的那般。他自己的私人生活也是荒废的，他说一个伟大的管家，只有一个人独处的时候，才是不需要尽职尽责的。在这样的教条下，他是无法在父亲逝世的时候有所感情流露的，而他也是无法在肯顿小姐最后的表白中进行回应的。这些事情都成了他评价自己是一个伟大管家的注脚，正是因为这些压力，而他也在这些压力下很好的实现了自己的职责。&lt;&#x2F;p&gt;
&lt;p&gt;石黑一雄通过塑造一个不可靠的观察者，把管家的一生描绘在了读者眼前，管家的追求和挣扎都透过他自己的叙述被展现了出来，即使他的记录是存在模糊和不确定的，即使他想掩藏哪些真相，还是被他的文字体现出来了。所有的旅程和回忆都是来自肯顿小姐的一封信，他凭借着这样一封信就觉得肯顿小姐想要和他一同共事，旅途上他不断的记起那些她和肯顿小姐的过往。这些模糊和不确定的事物，实际上就是每个人都有的痛苦和挣扎，人如果想要往前，那么必须要面对这些痛苦。但是痛苦是无法直接写出的，必然会有模糊和躲闪，那么写下来的事物也就失去了意义。假如这一切都是管家的记录和幻想，他收到了肯顿小姐的来信，但是他并没有真的出发，他凭借那本《英格兰奇景》描绘了一路的所见所闻，而最后的会谈也是他尝试理清自己痛苦的努力，最后在长日将尽的时刻，他决定不再回首，而是进一步学习如何说俏皮话，以让新的雇主满意。&lt;&#x2F;p&gt;
&lt;p&gt;译后记里，译者写到石黑一雄说他写《长日将尽》的出发点是想书写“你是如何为了成就事业而荒废了你的人生，又是如何在个人的层面上蹉跎了一辈子的”。我是很讨厌宏大使命的，我不相信这种东西，我不会觉得我晚上十点下班回家，是为了一个什么宏大的目标而在努力的，但是假如加班费足够丰厚我可能会考虑。&lt;&#x2F;p&gt;
&lt;p&gt;在书的结尾，长日将尽的时候，管家实际上在回想自己的一生的时候，应该是充满了后悔的，但是他也受到了陌生人的鼓励，看见码头上成群结队的陌生人，因为夜晚的到来而欢呼，他也有了慰藉。我想人生之中必然会有所蹉跎和错过，但是在长日将尽的时刻，究竟是觉得自己浪费了人生，还是认定自己有着一个美满的人生，实际上并不重要，重要的是能否安然入睡吧。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>利用Zola将博客从Ghost迁移到Github Pages</title>
        <published>2021-12-20T00:00:00+00:00</published>
        <updated>2021-12-20T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/migrate-blogs-from-ghost-to-github-page-with-zola/"/>
        <id>https://ghost.livexia.xyz/migrate-blogs-from-ghost-to-github-page-with-zola/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/migrate-blogs-from-ghost-to-github-page-with-zola/">&lt;p&gt;目前采用的Ghost博客框架，是搭建在DigitalOcean上的，每个月需要花费我5刀。而我只把这个服务器用作博客，我也不需要服务器用做其他的事情，而且架设在服务器上需要更多的精力进行维护，那么不如就把博客迁移到Github Pages好了，成本低，而且也解决了博客内容备份的问题。&lt;&#x2F;p&gt;
&lt;p&gt;在写下这篇文章的时候，我习惯于把所有的记录都写在Notion中，不论是私人的还是公开的，后续大概也是如此。这一篇文章也是先在Notion上完成，然后黏贴到md文件中，进一步再上传至Github Pages。目前这篇文章的效果我觉得还是不错的，这也加强了后续我更新博客动力。&lt;&#x2F;p&gt;
&lt;p&gt;暂时发现的问题就是通过 Github Action 来进行网站构建，虽然不能说特别慢，但是在推送完代码之后还是需要等待一段时间。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;静态网站生成器：Zola &lt;a href=&quot;https:&#x2F;&#x2F;www.getzola.org&#x2F;documentation&#x2F;getting-started&#x2F;overview&#x2F;&quot;&gt;https:&#x2F;&#x2F;www.getzola.org&#x2F;documentation&#x2F;getting-started&#x2F;overview&#x2F;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;zolahuan-jing-da-jian&quot;&gt;Zola环境搭建&lt;&#x2F;h2&gt;
&lt;p&gt;以下操作均在macOS上完成&lt;&#x2F;p&gt;
&lt;p&gt;Setp1: 安装Zola&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;brew install zola&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Setp2: 初始化Zola仓库&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;zola init ghost.livexia.xyz&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Setp3: 一些简单的zola命令&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;构建网站  &lt;code&gt;zola build&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;本地预览 &lt;code&gt;zola serve&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;编译检查 &lt;code&gt;zola check&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;an-zhuang-zhu-ti&quot;&gt;安装主题&lt;&#x2F;h2&gt;
&lt;p&gt;参考的博客的主题应该是手写的？不确定我能在短期内实现，先选择一个主题，后续再看看是否有自己定制化的需求。&lt;&#x2F;p&gt;
&lt;p&gt;简单使用主题 even&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;cd themes&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;git clone https:&#x2F;&#x2F;github.com&#x2F;getzola&#x2F;even&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;在 &lt;code&gt;config.toml&lt;&#x2F;code&gt; 中启用:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;theme = &quot;even&quot;&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;根据even文档，进一步修改 &lt;code&gt;config.toml&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;并不是特别喜欢这个主题的样式，可能会找时间将我参考的博客的主题进行复制修改&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ghostnei-rong-qian-yi&quot;&gt;&lt;strong&gt;Ghost内容迁移&lt;&#x2F;strong&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;在Ghost管理页面上导出数据，导出后应该是一个json文件。&lt;&#x2F;p&gt;
&lt;p&gt;利用工具&lt;code&gt;ghost-to-md&lt;&#x2F;code&gt; 批量转换：&lt;&#x2F;p&gt;
&lt;p&gt;Step1：安装工具 &lt;code&gt;npm install -g ghost-to-md&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Step2: 在Ghost管理面板中导出数据，执行命令批量转换。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;ghost-to-md cheng-xu-yuan-de-sheng-huo.ghost.2021-12-20-00-54-57.json&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;虽然利用工具能转换大部分的内容到 markdown，但是仍有部分错误需要手动修复。工具转出的markdown 头部的信息是yaml格式，为了和Rust的语言生态保持一致，修改yaml格式的markdown为toml。&lt;&#x2F;p&gt;
&lt;p&gt;进一步梳理博客中的内容，将部分博客文章删除，并分类了未完成的文章。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;githubcang-ku-jia-she&quot;&gt;&lt;strong&gt;Github仓库架设&lt;&#x2F;strong&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;详细说明参见：&lt;&#x2F;strong&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.getzola.org&#x2F;documentation&#x2F;deployment&#x2F;github-pages&#x2F;&quot;&gt;https:&#x2F;&#x2F;www.getzola.org&#x2F;documentation&#x2F;deployment&#x2F;github-pages&#x2F;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Step1：执行git submodule 来包含主题仓库。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;git submodule add https:&#x2F;&#x2F;github.com&#x2F;getzola&#x2F;even.git themes&#x2F;even&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Step2：生成github personal token&lt;&#x2F;p&gt;
&lt;p&gt;Step4：在仓库的 Secert 里添加token，注意要取和下一步Action 脚本中的 Token 一样的名字。&lt;&#x2F;p&gt;
&lt;p&gt;Step5：添加Github Actions&lt;&#x2F;p&gt;
&lt;h2 id=&quot;yu-ming-que-ding-he-jie-xi-diao-zheng&quot;&gt;&lt;strong&gt;域名确定和解析调整&lt;&#x2F;strong&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;原有域名为 &lt;a href=&quot;https:&#x2F;&#x2F;ghost.livexia.xyz&#x2F;&quot;&gt;https:&#x2F;&#x2F;ghost.livexia.xyz&#x2F;&lt;&#x2F;a&gt; 需要调整ghost为其他的什么吗？暂时保持不动吧。&lt;&#x2F;p&gt;
&lt;p&gt;将ghost.livexia.xyz的域名解析进行修改，原有dns解析是在 &lt;a href=&quot;https:&#x2F;&#x2F;dns.he.net&#x2F;&quot;&gt;https:&#x2F;&#x2F;dns.he.net&#x2F;&lt;&#x2F;a&gt; （注意不是&lt;a href=&quot;https:&#x2F;&#x2F;he.net&#x2F;&quot;&gt;https:&#x2F;&#x2F;he.net&#x2F;&lt;&#x2F;a&gt;）&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;删除原有的A类域名解析&lt;&#x2F;li&gt;
&lt;li&gt;添加CNAME域名解析，到github.io 页面&lt;&#x2F;li&gt;
&lt;li&gt;在仓库的Pages页面中增加域名即可，参见：&quot;&lt;a href=&quot;https:&#x2F;&#x2F;docs.github.com&#x2F;en&#x2F;articles&#x2F;managing-a-custom-domain-for-your-github-pages-site#configuring-a-subdomain&quot;&gt;Managing a custom domain for your GitHub Pages site&lt;&#x2F;a&gt;.&quot;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;an-zhuang-ping-lun-cha-jian&quot;&gt;&lt;strong&gt;安装评论插件&lt;&#x2F;strong&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;参考：&lt;a href=&quot;https:&#x2F;&#x2F;utteranc.es&#x2F;&quot;&gt;https:&#x2F;&#x2F;utteranc.es&#x2F;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;在安装教程里，我看见需要修改博客的模版文件，我不想去动even的模版文件，大概率我自己会写一个和参考博客的类似的模版，所以这个部分暂时挂起。&lt;&#x2F;p&gt;
&lt;p&gt;ToDo&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tian-jia-google-analysticdao-mo-ban-zhong&quot;&gt;添加Google Analystic到模版中&lt;&#x2F;h2&gt;
&lt;p&gt;ToDo&lt;&#x2F;p&gt;
&lt;h2 id=&quot;digitaloceantui-fei&quot;&gt;&lt;strong&gt;DigitalOcean退费&lt;&#x2F;strong&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;收到第二封回复，告知我能够将我账户上的未使用的余额进行退款，而我需要在账单到期后进行余额补足。&lt;&#x2F;p&gt;
&lt;p&gt;账户中的所有余额都已经完成退费，而这个月的账单是3.43美元，如果我用PayPal进行支付，我需要最少支付5美元。&lt;&#x2F;p&gt;
&lt;p&gt;参考：&lt;a href=&quot;https:&#x2F;&#x2F;fasterthanli.me&#x2F;articles&#x2F;a-new-website-for-2020&quot;&gt;https:&#x2F;&#x2F;fasterthanli.me&#x2F;articles&#x2F;a-new-website-for-2020&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>《漫长的告别》读后感</title>
        <published>2021-12-20T00:00:00+00:00</published>
        <updated>2021-12-20T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/the-long-goodbye-note/"/>
        <id>https://ghost.livexia.xyz/the-long-goodbye-note/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/the-long-goodbye-note/">&lt;p&gt;&lt;strong&gt;Update:&lt;&#x2F;strong&gt; 2019-09-03：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;说一声再见，就是死去一点点。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Update:&lt;&#x2F;strong&gt; 2021-9-14 完成重新阅读，2021-12-20 更新&lt;&#x2F;p&gt;
&lt;h2 id=&quot;xiang-chang-yi-bei-luo-si-qi-zi&quot;&gt;想尝一杯螺丝起子&lt;&#x2F;h2&gt;
&lt;p&gt;这是一本很久以前就读过的书，但是除了我模糊还记得硬汉马洛之外，这本书我就啥也不记得了，仿佛没有看过一样。很平淡的一本书，除去平淡就是一种悲伤，读完我的内心并没有什么大起伏。看完之后在豆瓣看了一篇书评，一星，我看了大致我是不认同的，超过一半的部分都是在讨论翻译和宣发，也涉及部分作者本人的言论，但是我并没能发现对书的具体批评，但是毕竟萝卜白菜各有所爱吧。其实我也说不出这本书有多好，好在哪，但是我绝对不觉得这是一本一星的书。马洛结交了一个新的酒友，围绕着酒友的过去和现在，马洛被卷入了一些事件，马洛行事也有着自己的标准，那就硬汉，他不肯让这一切随风而去都是为了能够好好的说再见，最后的确也完成了最后的再见。上一次读完啥也没记住，而这次我也不想写很多的剧情相关，如果下次想知道就去查一下好了，我想我也没有说从中看出什么无敌的深意，我只是看了一本书，短暂的经历了一个不一样的人生。即使下一次再看见这本书，发现自己又啥也不记得了，我想我也不会后悔再读一次。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Ghost博客升级</title>
        <published>2021-12-03T13:03:29+00:00</published>
        <updated>2021-12-03T13:03:29+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/ghostv4-update/"/>
        <id>https://ghost.livexia.xyz/ghostv4-update/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/ghostv4-update/">&lt;p&gt;&lt;strong&gt;背景&lt;&#x2F;strong&gt;：很长时间都没有看过我的博客了，今天偶然用ipad连上了服务器，就想着升级一下吧，由于涉及到很多曲折的历程，于是特此做个简单记录。&lt;&#x2F;p&gt;
&lt;p&gt;服务器是搭建在DigitalOcean的vps上的，远程连接之后需要切换用户，并进入&#x2F;var&#x2F;www&#x2F;ghost目录进行操作升级。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Step1&lt;&#x2F;strong&gt;：目录下执行 &lt;code&gt;ghost update&lt;&#x2F;code&gt;，提示node.js版本不够，于是需要先升级nodejs。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Step2&lt;&#x2F;strong&gt;：升级NodeJs&lt;&#x2F;p&gt;
&lt;p&gt;我不太熟悉NodeJs，于是找了一圈没找到很好的方法，结果我发现服务器是Ubuntu的18.04版本，决定先吧服务器升级到20.04。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Step3&lt;&#x2F;strong&gt;：升级服务器到20.04&lt;&#x2F;p&gt;
&lt;p&gt;参考：&lt;a href=&quot;https:&#x2F;&#x2F;www.digitalocean.com&#x2F;community&#x2F;tutorials&#x2F;how-to-upgrade-to-ubuntu-20-04-focal-fossa&quot;&gt;https:&#x2F;&#x2F;www.digitalocean.com&#x2F;community&#x2F;tutorials&#x2F;how-to-upgrade-to-ubuntu-20-04-focal-fossa&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;执行：&lt;code&gt;sudo do-release-upgrade&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;执行时程序会创建一个screen session保证不会因为ssh断开而中断升级，期间的确发生了ssh断链的情况，安装中会提示升级各种服务，包括mysql，这是一个坑，我都选择了跟随发行版。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Step4&lt;&#x2F;strong&gt;：在20.04下继续升级，nodejs并没有自动升级，所以ghost继续报错，然后我仔细阅读了如何升级nodejs，方法是&lt;code&gt;sudo n 12.22.1&lt;&#x2F;code&gt;。我根据提示升级了多个版本的nodejs，但是最后选择了这个版本。&lt;&#x2F;p&gt;
&lt;p&gt;因为较长时间没有升级，我是从v3升级到v4，版本跨度较大，默认自动升级到v4，当我安装了nodejs 17.x 版本的时候，提示我需要先升级到最新版本的v3。使用命令&lt;code&gt;ghost update v3&lt;&#x2F;code&gt;，提示我nodejs版本不兼容，于是参照提示又安装了12.x的版本。最后成功升级v3，然后执行&lt;code&gt;ghost update&lt;&#x2F;code&gt; 升级v4，升级没有其他的错误，但是运行发生了严重的错误。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Step5&lt;&#x2F;strong&gt;：运行&lt;code&gt;ghost start&lt;&#x2F;code&gt;时，提示数据库的一个错误，根据关键词我找到了一篇解决的社区讨论，参见：&lt;a href=&quot;https:&#x2F;&#x2F;forum.ghost.org&#x2F;t&#x2F;ghost-4-1-0-errored-during-boot&#x2F;21006&#x2F;5&quot;&gt;https:&#x2F;&#x2F;forum.ghost.org&#x2F;t&#x2F;ghost-4-1-0-errored-during-boot&#x2F;21006&#x2F;5&lt;&#x2F;a&gt; 。利用提及的方法，我修改了数据库的默认collation，参见如下sql代码。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;SELECT SCHEMA_NAME,
&lt;&#x2F;span&gt;&lt;span&gt;DEFAULT_CHARACTER_SET_NAME,
&lt;&#x2F;span&gt;&lt;span&gt;DEFAULT_COLLATION_NAME
&lt;&#x2F;span&gt;&lt;span&gt;FROM INFORMATION_SCHEMA.SCHEMATA
&lt;&#x2F;span&gt;&lt;span&gt;WHERE SCHEMA_NAME=&amp;#39;ghost_production&amp;#39;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;ALTER DATABASE `ghost_production`
&lt;&#x2F;span&gt;&lt;span&gt;DEFAULT CHARACTER SET utf8mb4
&lt;&#x2F;span&gt;&lt;span&gt;DEFAULT COLLATE utf8mb4_general_ci;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;执行之后，错误信息发生了变化。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Step6&lt;&#x2F;strong&gt;：继续解决新出现的错误。&lt;&#x2F;p&gt;
&lt;p&gt;根据错误信息我找到了另外一篇的社区讨论，参见：&lt;a href=&quot;https:&#x2F;&#x2F;forum.ghost.org&#x2F;t&#x2F;unable-to-upgrade-ghost-from-v4-2-0-to-v4-3-0-cascade-unknown-code-please-report&#x2F;22086&#x2F;56&quot;&gt;https:&#x2F;&#x2F;forum.ghost.org&#x2F;t&#x2F;unable-to-upgrade-ghost-from-v4-2-0-to-v4-3-0-cascade-unknown-code-please-report&#x2F;22086&#x2F;56&lt;&#x2F;a&gt; 。根据这篇讨论和上一篇讨论，我大致明白发生了什么，简单说下。在我升级服务器的时候，MySQL也升级了，而在8.0中数据库的默认collation是utf8mb4_0900_ai_ci，而遗留的数据表则是utf8mb4_general_ci。所以我需要修改mysql的配置，如讨论中所说，我也需要修改已有数据库的默认collation，但是在我改完也添加完配置文件后，错误依旧。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Step7&lt;&#x2F;strong&gt;：因为MySQL较长时间没有用了，很多语句都忘记了使用方式，但是经过两篇文章我大概明白了为什么，即使我运行&lt;code&gt;ghost update --force&lt;&#x2F;code&gt;强制重新升级也无法解决错误，因为在修改完配置和数据库设置后，就算我重新强制升级，也只是在创建新表的时候，采用了新的collation，而那些老的表，则无法自动修改，于是我需要一个一个表进行修改。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Step8&lt;&#x2F;strong&gt;：修改数据表的collation。&lt;&#x2F;p&gt;
&lt;p&gt;参考：&lt;a href=&quot;https:&#x2F;&#x2F;betterprogramming.pub&#x2F;how-to-check-and-change-the-collation-of-mysql-tables-6095fada0ebd&quot;&gt;https:&#x2F;&#x2F;betterprogramming.pub&#x2F;how-to-check-and-change-the-collation-of-mysql-tables-6095fada0ebd&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;mysql中执行命令 &lt;code&gt;SELECT TABLE_CATALOG, TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME, COLLATION_NAME FROM INFORMATION_SCHEMA.COLUMNS where COLLATION_NAME like &#x27;utf8mb4_0900_ai_ci&#x27;;&lt;&#x2F;code&gt; 找到仍旧是采用utf8mb4_0900_ai_ci的所有与ghost相关的数据表。&lt;&#x2F;p&gt;
&lt;p&gt;执行命令 &lt;code&gt;ALTER TABLE &amp;lt;table_name&amp;gt; CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;&lt;&#x2F;code&gt; 把所有与ghost相关的采用utf8mb4_0900_ai_ci的数据表，进行修改。修改后 ghost 启动正常。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;参考链接：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;forum.ghost.org&#x2F;t&#x2F;ghost-4-1-0-errored-during-boot&#x2F;21006&#x2F;5&quot;&gt;https:&#x2F;&#x2F;forum.ghost.org&#x2F;t&#x2F;ghost-4-1-0-errored-during-boot&#x2F;21006&#x2F;5&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;forum.ghost.org&#x2F;t&#x2F;unable-to-upgrade-ghost-from-v4-2-0-to-v4-3-0-cascade-unknown-code-please-report&#x2F;22086&#x2F;56&quot;&gt;https:&#x2F;&#x2F;forum.ghost.org&#x2F;t&#x2F;unable-to-upgrade-ghost-from-v4-2-0-to-v4-3-0-cascade-unknown-code-please-report&#x2F;22086&#x2F;56&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;TryGhost&#x2F;Ghost-CLI&#x2F;issues&#x2F;1359&quot;&gt;https:&#x2F;&#x2F;github.com&#x2F;TryGhost&#x2F;Ghost-CLI&#x2F;issues&#x2F;1359&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;betterprogramming.pub&#x2F;how-to-check-and-change-the-collation-of-mysql-tables-6095fada0ebd&quot;&gt;https:&#x2F;&#x2F;betterprogramming.pub&#x2F;how-to-check-and-change-the-collation-of-mysql-tables-6095fada0ebd&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Linux下set、env、export的不同</title>
        <published>2020-11-26T14:50:17+00:00</published>
        <updated>2020-11-26T14:50:17+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/set-env-export/"/>
        <id>https://ghost.livexia.xyz/set-env-export/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/set-env-export/">&lt;p&gt;&lt;strong&gt;此文转载而来，在工作时对Linux下的各种环境变量设置有所疑惑，以下是对原文的翻译&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;https:&#x2F;&#x2F;askubuntu.com&#x2F;a&#x2F;205698&quot;&gt;What&#x27;s the difference between set, export and env and when should I use each?&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;让我们考虑以下这个特定的例子，&lt;code&gt;grep&lt;&#x2F;code&gt;命令利用一个&lt;code&gt;GREP_OPTIONS&lt;&#x2F;code&gt; 环境变量（environment variable）来设置默认的选项。&lt;&#x2F;p&gt;
&lt;p&gt;现在，给定一个文件 &lt;code&gt;test.txt&lt;&#x2F;code&gt; 含有以下行：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;line one
&lt;&#x2F;span&gt;&lt;span&gt;line two
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;运行命令 &lt;code&gt;grep one test.xt&lt;&#x2F;code&gt; 将会返回以下内容：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;line one
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如果你运行 &lt;code&gt;grep&lt;&#x2F;code&gt; 时附带 &lt;code&gt;-v&lt;&#x2F;code&gt; 参数，将会返回所有不匹配的行，所以输出如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;line two
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;wo-men-jiang-chang-shi-li-yong-huan-jing-bian-liang-she-ding-zhe-ge-xuan-xiang&quot;&gt;&lt;strong&gt;我们将尝试利用环境变量设定这个选项&lt;&#x2F;strong&gt;&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;不利用 &lt;code&gt;export&lt;&#x2F;code&gt; 设定环境变量&lt;&#x2F;strong&gt; 将不会被你调用命令的环境所继承。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;GREP_OPTIONS=&amp;#39;-v&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;grep one test.txt
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;结果：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;line one
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;很显然，参数 &lt;code&gt;-v&lt;&#x2F;code&gt; 没有成功的传入&lt;code&gt;grep&lt;&#x2F;code&gt;程序中&lt;&#x2F;p&gt;
&lt;p&gt;*只有在你希望设定一个变量仅在当前运行shell内生效时才采用这种形式，例如在&lt;code&gt;for i in \* ; do&lt;&#x2F;code&gt;中你不会希望  &lt;code&gt; export $i&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;然而，这个变量将会被传给当前命令的运行环境中，所以你也可以这样做使其生效：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;GREP_OPTIONS=&amp;#39;-v&amp;#39; grep one test.txt
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这样就会返回预期的结果了&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;line two
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;em&gt;当你想临时改变当前运行实例程序的环境时，采用这种方法。&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;code&gt;export&lt;&#x2F;code&gt; 一个变量会使得这个变量被继承:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;export GREP_OPTIONS=&amp;#39;-v&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;grep one test.txt
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;现在返回&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;line two
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;em&gt;这种形式最常见的使用场景是在，在shell中设置变量以供随后启动的进程使用&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;这里所说的都是在bash中的实现。 &lt;code&gt;export&lt;&#x2F;code&gt; 是bash的内建方法; &lt;code&gt;VAR=whatever&lt;&#x2F;code&gt; 则是bash的语法。 &lt;code&gt;env&lt;&#x2F;code&gt;, 在另一方面来说, 自己就是一个程序。当 &lt;code&gt;env&lt;&#x2F;code&gt; 被调用时, 下列事情将会发生:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;命令 &lt;code&gt;env&lt;&#x2F;code&gt; 被作为新的进程进行执行&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;env&lt;&#x2F;code&gt; 修改环境的同时&lt;&#x2F;li&gt;
&lt;li&gt;调起作为参数传入的命令， &lt;code&gt;env&lt;&#x2F;code&gt; 进程被 &lt;code&gt;command&lt;&#x2F;code&gt; 进程替换&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Example:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;env GREP_OPTIONS=&amp;#39;-v&amp;#39; grep one test.txt
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个命令会启动两个进程: (i) env and (ii) grep (实际上，第二个进程会替代第一个进程). 从 &lt;code&gt;grep&lt;&#x2F;code&gt; 进程的角度来看, 运行的结果与运行下面的命令一模一样：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;GREP_OPTIONS=&amp;#39;-v&amp;#39; grep one test.txt
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;然而，当你不在bash内或者不希望唤起另一个shell时，你可以使用这个方法 (例如，当你使用 &lt;code&gt;exec()&lt;&#x2F;code&gt; 类似的函数而不是 &lt;code&gt;system()&lt;&#x2F;code&gt; 调用).&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;关于 &lt;code&gt;#!&#x2F;usr&#x2F;bin&#x2F;env&lt;&#x2F;code&gt; 的附加说明&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;这也是为什么， 使用&lt;code&gt;#!&#x2F;usr&#x2F;bin&#x2F;env interpreter&lt;&#x2F;code&gt; 而不是 &lt;code&gt;#!&#x2F;usr&#x2F;bin&#x2F;interpreter&lt;&#x2F;code&gt;. &lt;code&gt;env&lt;&#x2F;code&gt; 并不需要完整的程序路径, 因为它使用 &lt;code&gt;execvp()&lt;&#x2F;code&gt; 函数遍历的搜索 &lt;code&gt;PATH&lt;&#x2F;code&gt; 变量，就像shell会做的一样,  然后将运行命令替换自身。 因此，它可以用作寻找解释器 (例如 perl、 python) 的&quot;位置&quot;.&lt;&#x2F;p&gt;
&lt;p&gt;这也表示，通过修改当前的PATH变量，你可以影响到哪个python的程序会被调用。这使得下列命令有可能执行成功：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;echo -e &amp;#39;#!&#x2F;usr&#x2F;bin&#x2F;bash\n\necho I am an evil interpreter!&amp;#39; &amp;gt; python
&lt;&#x2F;span&gt;&lt;span&gt;chmod a+x .&#x2F;python
&lt;&#x2F;span&gt;&lt;span&gt;export PATH=.
&lt;&#x2F;span&gt;&lt;span&gt;calibre
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;会返回如下结果，而不是调起Calibre&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;I am an evil interpreter!
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;说明：Calibre是一个自由开源的电子书软件套装，由python编写，需要依赖python解释器才能运行&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>2020阅读记录</title>
        <published>2020-05-21T13:27:23+00:00</published>
        <updated>2020-05-21T13:27:23+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/2020-reading-list/"/>
        <id>https://ghost.livexia.xyz/2020-reading-list/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/2020-reading-list/">&lt;h2 id=&quot;zheng-zai-yue-du&quot;&gt;正在阅读&lt;&#x2F;h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;作者&lt;&#x2F;th&gt;&lt;th style=&quot;text-align: center&quot;&gt;书名&lt;&#x2F;th&gt;&lt;th style=&quot;text-align: right&quot;&gt;进度&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;蒂莫西·泰勒斯&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: center&quot;&gt;坦福极简经济学：如何果断地权衡利益得失&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: right&quot;&gt;0%&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h2 id=&quot;wu-yue-fen-yi-yue-du&quot;&gt;五月份已阅读&lt;&#x2F;h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;作者&lt;&#x2F;th&gt;&lt;th style=&quot;text-align: center&quot;&gt;书名&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;贾德·戴蒙&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: center&quot;&gt;枪炮、病菌与钢铁：人类社会的命运&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h2 id=&quot;si-yue-fen-yi-yue-du&quot;&gt;四月份已阅读&lt;&#x2F;h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;作者&lt;&#x2F;th&gt;&lt;th style=&quot;text-align: center&quot;&gt;书名&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;王小波&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: center&quot;&gt;黄金时代&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;加西亚·马尔克斯&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: center&quot;&gt;米格尔在智利的地下行动&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h2 id=&quot;san-yue-fen-yi-yue-du&quot;&gt;三月份已阅读&lt;&#x2F;h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;作者&lt;&#x2F;th&gt;&lt;th style=&quot;text-align: center&quot;&gt;书名&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;小川糸&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: center&quot;&gt;山茶文具店&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;小川糸&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: center&quot;&gt;闪闪发光的人生&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;白先勇&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: center&quot;&gt;台北人&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;白岩松&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: center&quot;&gt;痛并快乐着&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;加缪&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: center&quot;&gt;鼠疫&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;王小波&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: center&quot;&gt;沉默的大多数&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;柳原汉雅&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: center&quot;&gt;渺小一生&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Python如何实现大数</title>
        <published>2020-04-11T09:58:23+00:00</published>
        <updated>2020-04-11T09:58:23+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/how-python-implements-super-long-integers/"/>
        <id>https://ghost.livexia.xyz/how-python-implements-super-long-integers/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/how-python-implements-super-long-integers/">&lt;h2 id=&quot;wen-zhang-shuo-ming&quot;&gt;文章说明&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;来自电台 &lt;a href=&quot;https:&#x2F;&#x2F;pythonbytes.fm&#x2F;&quot;&gt;Python Bytes Podcast&lt;&#x2F;a&gt;&lt;a href=&quot;https:&#x2F;&#x2F;pythonbytes.fm&#x2F;episodes&#x2F;show&#x2F;176&#x2F;how-python-implements-super-long-integers&quot;&gt;Episode #176: How python implements super long integers&lt;&#x2F;a&gt; 的推荐&lt;&#x2F;li&gt;
&lt;li&gt;文章链接：&lt;a href=&quot;https:&#x2F;&#x2F;arpitbhayani.me&#x2F;blogs&#x2F;super-long-integers&quot;&gt;How python implements super long integers?&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;以下是对文章的翻译和部分个人的理解&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;fan-yi-shuo-ming&quot;&gt;翻译说明&lt;&#x2F;h2&gt;
&lt;p&gt;直到存储节的内容都是由我自己进行翻译，但是存储之后的部分都是在翻译工具 &lt;a href=&quot;https:&#x2F;&#x2F;www.deepl.com&#x2F;translator&quot;&gt;Deppl&lt;&#x2F;a&gt; 的基础上润色而来，如想要支持原作者请前往原文链接，或者文章底部的相关位置对作者进行支持。&lt;&#x2F;p&gt;
&lt;p&gt;在此推荐这个翻译工具，翻译质量的确是比我之前使用的工具都要好很多，翻译时间也没有明显的落后。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;yin-yan&quot;&gt;引言&lt;&#x2F;h2&gt;
&lt;p&gt;当你在例如C语言的底层语言上进行编码，你需要担心为你的整数选择正确的数据类型与限定词。在每一步中，您都需要考虑 &lt;code&gt;int&lt;&#x2F;code&gt; 是否足够，还是应该选择 &lt;code&gt;long &lt;&#x2F;code&gt;，甚至更长的 &lt;code&gt;long double&lt;&#x2F;code&gt; ？但是当你利用  python 进行编码时，你不需要担心这些 “不重要的” 细节，因为python支持任意大小的整数。&lt;&#x2F;p&gt;
&lt;p&gt;在C语言中，当你尝试利用内置的 &lt;code&gt;powl&lt;&#x2F;code&gt; 函数计算 2^20000 时，将会给出 &lt;code&gt;inf&lt;&#x2F;code&gt; 作为输出&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;#include &amp;lt;stdio.h&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;#include &amp;lt;math.h&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;int main(void) {
&lt;&#x2F;span&gt;&lt;span&gt;  printf(&amp;quot;%Lf\n&amp;quot;, powl(2, 20000));
&lt;&#x2F;span&gt;&lt;span&gt;  return 0;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;$ .&#x2F;a.out
&lt;&#x2F;span&gt;&lt;span&gt;inf
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;但是对于python来说，真的是小菜一碟&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; 2 ** 20000
&lt;&#x2F;span&gt;&lt;span&gt;39802768403379665923543072061912024537047727804924259387134 ...
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;... 6021 digits long ...
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;6309376
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Python一定在内部做了一些美妙的事情来支持容易大小的整数，今天就让我们一探究竟吧！&lt;&#x2F;p&gt;
&lt;h2 id=&quot;xing-shi-yu-ding-yi&quot;&gt;形式与定义&lt;&#x2F;h2&gt;
&lt;p&gt;Python中的一个整数实际上是一个C的结构体，定义如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;struct _longobject {
&lt;&#x2F;span&gt;&lt;span&gt;    PyObject_VAR_HEAD
&lt;&#x2F;span&gt;&lt;span&gt;    digit ob_digit[1];
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;PyObject_VAR_HEAD&lt;&#x2F;code&gt; 是一个宏，这个宏将会展开成为一个 &lt;code&gt;PyVarObject&lt;&#x2F;code&gt; ，结构如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;typedef struct {
&lt;&#x2F;span&gt;&lt;span&gt;    PyObject ob_base;
&lt;&#x2F;span&gt;&lt;span&gt;    Py_ssize_t ob_size; &#x2F;* Number of items in variable part *&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;} PyVarObject;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其他拥有 &lt;code&gt;PyObject_VAR_HEAD&lt;&#x2F;code&gt; 的类型是：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PyBytesObject&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;PyTupleObject&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;PyListObject&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;这表明一个整数，就像一个 &lt;code&gt;tuple&lt;&#x2F;code&gt; 或一个 &lt;code&gt;list&lt;&#x2F;code&gt; 一样，其长度是可变的，是我们对它如何支持巨型长整数的第一认识。 宏扩展后的 &lt;code&gt;_longobject&lt;&#x2F;code&gt; 可以粗略地看成视作以下定义：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;struct _longobject {
&lt;&#x2F;span&gt;&lt;span&gt;    PyObject ob_base;
&lt;&#x2F;span&gt;&lt;span&gt;    Py_ssize_t ob_size; &#x2F;* Number of items in variable part *&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;    digit ob_digit[1];
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;有一些在 &lt;code&gt;PyObject&lt;&#x2F;code&gt; 结构体中字段,  将会在引用计数（垃圾回收）中被使用，详细讲解这些字段就需要一篇独立的文章。我们目前主要关注的字段是  &lt;code&gt;ob_digit&lt;&#x2F;code&gt; 和一定程度的 &lt;code&gt;ob_size&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jie-ma-ob-digit&quot;&gt;解码 &lt;code&gt;ob_digit&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;code&gt;ob_size&lt;&#x2F;code&gt;表示 &lt;code&gt;ob_digit&lt;&#x2F;code&gt; 中实际元素的个数。为了在给数组 &lt;code&gt;ob_digit&lt;&#x2F;code&gt; 分配内存时更加高效，python会预留数组长度，同时依赖 &lt;code&gt;ob_size&lt;&#x2F;code&gt; 的值来决定实际有多少元素在数组中。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;cun-chu&quot;&gt;存储&lt;&#x2F;h2&gt;
&lt;p&gt;存储一个整形最简单的方式是在，数组中每一个元素存储一个十进制中数的每位，然后就可像小学数学一样进行加减法等运算操作。&lt;&#x2F;p&gt;
&lt;p&gt;用这种方法，数字 &lt;code&gt;5238&lt;&#x2F;code&gt; 将会被存储为： &lt;code&gt;8325&lt;&#x2F;code&gt;，如下图：
&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;15051530&#x2F;79039986-ae626f00-7c17-11ea-9d8c-9a6618f85e9c.png&quot; alt=&quot;image&quot; &#x2F;&gt;
这种方法效率很低，因为我们将耗费32位（uint32_t）来存储一个小数位，而实际上这个小数位的范围只有0到9，本来可以很容易地用4位来表示。写出像python这样多功能的语言，作为一个核心开发人员必须要能够更加有效的利用资源。&lt;&#x2F;p&gt;
&lt;p&gt;那么，我们能不能做得更好呢？ 当然可以，否则，这篇文章在互联网上应该是没有立足之地的。下面我们就来深入了解一下python是如何存储超长整数的。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;pythonicde-fang-shi&quot;&gt;Pythonic的方式&lt;&#x2F;h2&gt;
&lt;p&gt;python并不是在数组 &lt;code&gt;ob_digit&lt;&#x2F;code&gt; 的每一个项目中只存储一个十进制数字，而是将数字从基数10转换为基数2^30 ，数组中每个元素的范围是从为从0到2^30 - 1的数字。&lt;&#x2F;p&gt;
&lt;p&gt;在十六进制的数字系统中，基数是16~2^4，这意味着十六进制数字的每个  &lt;code&gt;bit&lt;&#x2F;code&gt; 的范围是0~15。同样，对于python来说，&quot;digit &quot;的基数是2^30 ，这意味着它的范围也就是十进制从 &lt;code&gt;0 ~ 2^30 - 1= 1073741823&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;这样一来，python几乎有效地使用了每个位数32位的分配空间，并且保持了自身的资源优势，仍然可以像小学数学一样执行加减法等操作。&lt;&#x2F;p&gt;
&lt;p&gt;根据平台的不同，Python使用的是32位无符号整数组的30位数位，或者16位无符号整数组的15位数位。它需要几个位来执行操作，这些操作将在以后的一些文章中讨论。&lt;&#x2F;p&gt;
&lt;p&gt;例子：1152921504606846976&lt;&#x2F;p&gt;
&lt;p&gt;如前所述，对于Python来说，一个 &quot;数字 &quot;是基数2^30 ，因此如果将1152921504606846976转换为基数2^30，则得到100&lt;&#x2F;p&gt;
&lt;p&gt;1152921504606846976 = 1 * (2^30)2 + 0 * (2^30)1 + 0 * (2^30)0&lt;&#x2F;p&gt;
&lt;p&gt;由于 &lt;code&gt;ob_digit&lt;&#x2F;code&gt; 先将其最低位保留下来，所以它将被存储为 &lt;code&gt;001&lt;&#x2F;code&gt;，存储为3个不同的位数。&lt;&#x2F;p&gt;
&lt;p&gt;这个值的 &lt;code&gt;_longobject&lt;&#x2F;code&gt; 结构将持有&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;code&gt;ob_size &lt;&#x2F;code&gt;为 &lt;code&gt;3&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;code&gt;ob_digit &lt;&#x2F;code&gt;为 &lt;code&gt;[0, 0, 1]&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;15051530&#x2F;79039977-a5719d80-7c17-11ea-8163-35c93dbd28e7.png&quot; alt=&quot;image&quot; &#x2F;&gt;
原作者创建了一个解释器展示 &lt;a href=&quot;https:&#x2F;&#x2F;repl.it&#x2F;@arpitbbhayani&#x2F;super-long-int?language=python3&quot;&gt;demo REPL&lt;&#x2F;a&gt; ，它将输出python内部存储整数的方式，同时也有对结构成员的引用，如 &lt;code&gt;ob_size &lt;&#x2F;code&gt;、&lt;code&gt;ob_refcount &lt;&#x2F;code&gt;等。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;da-shu-de-yun-suan&quot;&gt;大数的运算&lt;&#x2F;h1&gt;
&lt;p&gt;现在我们对python如何支持和实现任意精度整数有了一定的了解，是时候了解各种数学运算是如何在它们实现的。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jia-fa&quot;&gt;加法&lt;&#x2F;h2&gt;
&lt;p&gt;I整数是以 &quot;数位为单位 &quot;进行持久化，这意味着加法就像我们在小学时学过的那样简单，而python的源码告诉我们，它也正是这样实现的.。文件&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;arpitbbhayani&#x2F;cpython&#x2F;blob&#x2F;0-base&#x2F;Objects&#x2F;longobject.c&quot;&gt;longobject.c&lt;&#x2F;a&gt;中名为&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;arpitbbhayani&#x2F;cpython&#x2F;blob&#x2F;0-base&#x2F;Objects&#x2F;longobject.c#L3116&quot;&gt;x_add&lt;&#x2F;a&gt;的函数执行两个数的加法。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;    for (i = 0; i &amp;lt; size_b; ++i) {
&lt;&#x2F;span&gt;&lt;span&gt;        carry += a-&amp;gt;ob_digit[i] + b-&amp;gt;ob_digit[i];
&lt;&#x2F;span&gt;&lt;span&gt;        z-&amp;gt;ob_digit[i] = carry &amp;amp; PyLong_MASK;
&lt;&#x2F;span&gt;&lt;span&gt;        carry &amp;gt;&amp;gt;= PyLong_SHIFT;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    for (; i &amp;lt; size_a; ++i) {
&lt;&#x2F;span&gt;&lt;span&gt;        carry += a-&amp;gt;ob_digit[i];
&lt;&#x2F;span&gt;&lt;span&gt;        z-&amp;gt;ob_digit[i] = carry &amp;amp; PyLong_MASK;
&lt;&#x2F;span&gt;&lt;span&gt;        carry &amp;gt;&amp;gt;= PyLong_SHIFT;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    z-&amp;gt;ob_digit[i] = carry;
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;上面的代码片段取自 &lt;code&gt;x_add&lt;&#x2F;code&gt; 函数，你可以看到它在每个数位上进行迭代，执行数字加法，并计算和进位。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;当加法的结果是一个负数时，事情就变得有趣了。&lt;code&gt;ob_size&lt;&#x2F;code&gt; 的符号是整数的符号，这意味着，如果你有一个负数，那么 &lt;code&gt;ob_size&lt;&#x2F;code&gt; 将是负数。&lt;code&gt;ob_size &lt;&#x2F;code&gt;的绝对值将决定 &lt;code&gt;ob_digit &lt;&#x2F;code&gt;中的位数。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;jian-fa&quot;&gt;减法&lt;&#x2F;h2&gt;
&lt;p&gt;与加法的实现方式类似，减法也是以数字为单位进行的。文件&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;arpitbbhayani&#x2F;cpython&#x2F;blob&#x2F;0-base&#x2F;Objects&#x2F;longobject.c#L3150&quot;&gt;longobject.c&lt;&#x2F;a&gt;中名为&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;arpitbbhayani&#x2F;cpython&#x2F;blob&#x2F;0-base&#x2F;Objects&#x2F;longobject.c&quot;&gt;x_sub&lt;&#x2F;a&gt;的函数执行两个数字的减法。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;    for (i = 0; i &amp;lt; size_b; ++i) {
&lt;&#x2F;span&gt;&lt;span&gt;        borrow = a-&amp;gt;ob_digit[i] - b-&amp;gt;ob_digit[i] - borrow;
&lt;&#x2F;span&gt;&lt;span&gt;        z-&amp;gt;ob_digit[i] = borrow &amp;amp; PyLong_MASK;
&lt;&#x2F;span&gt;&lt;span&gt;        borrow &amp;gt;&amp;gt;= PyLong_SHIFT;
&lt;&#x2F;span&gt;&lt;span&gt;        borrow &amp;amp;= 1; &#x2F;* Keep only one sign bit *&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    for (; i &amp;lt; size_a; ++i) {
&lt;&#x2F;span&gt;&lt;span&gt;        borrow = a-&amp;gt;ob_digit[i] - borrow;
&lt;&#x2F;span&gt;&lt;span&gt;        z-&amp;gt;ob_digit[i] = borrow &amp;amp; PyLong_MASK;
&lt;&#x2F;span&gt;&lt;span&gt;        borrow &amp;gt;&amp;gt;= PyLong_SHIFT;
&lt;&#x2F;span&gt;&lt;span&gt;        borrow &amp;amp;= 1; &#x2F;* Keep only one sign bit *&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;上面的代码片段来自于&lt;code&gt;x_sub&lt;&#x2F;code&gt;函数，你可以看到它是如何迭代数字，并执行减法，计算和借位。确实和加法很相似。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;cheng-fa&quot;&gt;乘法&lt;&#x2F;h2&gt;
&lt;p&gt;同样，一个最简单的方法来实现乘法，就是我们在小学数学中所学的乘法，但它的效率并不高。为了保证效率，Python实现了&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Karatsuba_algorithm&quot;&gt;Karatsuba算法&lt;&#x2F;a&gt;，它可以用O( nlog23)的基本步数来实现两个n位数的乘法。&lt;&#x2F;p&gt;
&lt;p&gt;这个算法略显复杂，不在本文的范围之内，但你可以在文件 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;arpitbbhayani&#x2F;cpython&#x2F;blob&#x2F;0-base&#x2F;Objects&#x2F;longobject.c&quot;&gt;longobject.c&lt;&#x2F;a&gt; 中的 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;arpitbbhayani&#x2F;cpython&#x2F;blob&#x2F;0-base&#x2F;Objects&#x2F;longobject.c#L3397&quot;&gt;k_mul &lt;&#x2F;a&gt;和 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;arpitbbhayani&#x2F;cpython&#x2F;blob&#x2F;0-base&#x2F;Objects&#x2F;longobject.c#L3618&quot;&gt;k_lopsided_mul&lt;&#x2F;a&gt; 函数中找到它的实现。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;chu-fa-he-qi-ta-yun-suan-cao-zuo&quot;&gt;除法和其他运算操作&lt;&#x2F;h2&gt;
&lt;p&gt;所有关于整数的操作都在文件 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;arpitbbhayani&#x2F;cpython&#x2F;blob&#x2F;0-base&#x2F;Objects&#x2F;longobject.c&quot;&gt;longobject.c&lt;&#x2F;a&gt; 中定义了，找到并跟踪每一个操作都非常简单。警告：详细了解每一个操作都需要一些时间，所以在开始略读之前先拿些爆米花。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;dui-jiao-chang-shi-yong-de-zheng-shu-de-you-hua&quot;&gt;对较常使用的整数的优化&lt;&#x2F;h1&gt;
&lt;p&gt;Python &lt;a href=&quot;https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;c-api&#x2F;long.html#c.PyLong_FromLong&quot;&gt;预先分配&lt;&#x2F;a&gt; 在-5到256的范围内的小整数。这种分配发生在初始化过程中，由于我们不能更新整数 (不变性)，所以这些预分配的整数是单整数，直接引用而不是重新分配。这意味着，每次我们使用&#x2F;创建一个小整数时，python都会返回预分配的整数的引用，而不是重新分配。&lt;&#x2F;p&gt;
&lt;p&gt;这种优化可以在宏 &lt;code&gt;IS_SMALL_INT&lt;&#x2F;code&gt; 和函数&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;arpitbbhayani&#x2F;cpython&#x2F;blob&#x2F;0-base&#x2F;Objects&#x2F;longobject.c#L35&quot;&gt;longobject.c&lt;&#x2F;a&gt;中的函数&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;arpitbbhayani&#x2F;cpython&#x2F;blob&#x2F;0-base&#x2F;Objects&#x2F;longobject.c#L43&quot;&gt;get_small_int&lt;&#x2F;a&gt;中找到。这样python可以为常用的整数节省大量的空间和计算量。&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;这是《Python内部》系列的第二篇文章。第一篇文章是&lt;a href=&quot;https:&#x2F;&#x2F;arpitbhayani.me&#x2F;blogs&#x2F;i-changed-my-python&quot;&gt;我是如何改变我的Python并让它变得可疑的&lt;&#x2F;a&gt;，它帮助你迈出了Python源代码的第一步，为你成为Python核心开发者铺平了道路。&lt;&#x2F;p&gt;
&lt;p&gt;如果你想看更多这样的文章，请订阅我的时事通讯，并将文章直接发送到你的收件箱。我每周五都会写一些关于工程、系统设计和编程的文章。给原作者点赞&lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;arpit_bhayani&quot;&gt;@arpit_bhayani&lt;&#x2F;a&gt;。你可以找到原作者之前的文章&lt;a href=&quot;https:&#x2F;&#x2F;arpitbhayani.me&#x2F;blogs&quot;&gt;@arpitbhayani.me&#x2F;blogs&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>PVE后续使用记录Part1-UbuntuServer</title>
        <published>2020-04-11T09:08:28+00:00</published>
        <updated>2020-04-11T09:08:28+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/install-ubuntu-server-on-pve/"/>
        <id>https://ghost.livexia.xyz/install-ubuntu-server-on-pve/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/install-ubuntu-server-on-pve/">&lt;h2 id=&quot;an-zhuang-ubuntu-server-18-04&quot;&gt;安装Ubuntu Server 18.04&lt;&#x2F;h2&gt;
&lt;p&gt;需要使用Linux的环境来部署一些工具，由于这些工具对Ubuntu的支持都较为良好，所以选用Ubuntu Server.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;xia-zai&quot;&gt;下载&lt;&#x2F;h3&gt;
&lt;p&gt;可以在ubnutu的官网进行下载，虽然官网会根据地区自动优化下载镜像源，不过在这里还是推荐直接在国内的镜像源上下载镜像，保证高速下载，在此给出：&lt;a href=&quot;https:&#x2F;&#x2F;mirror.tuna.tsinghua.edu.cn&#x2F;ubuntu-releases&#x2F;bionic&#x2F;ubuntu-18.04.4-live-server-amd64.iso&quot;&gt;清华大学镜像源的下载地址&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;注意下载完的镜像需要上传到pve的存储中，或者在pve上利用wget进行下载&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zai-pveshang-chuang-jian-xu-ni-ji&quot;&gt;在PVE上创建虚拟机&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;part1-pvechuang-jian-xu-ni-ji&quot;&gt;Part1：PVE创建虚拟机&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;strong&gt;Step1：点击创建虚拟机&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;15051530&#x2F;79039176-0c8c5380-7c12-11ea-8e26-eb64636f071c.png&quot; alt=&quot;image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Step2：选择创建虚拟机在哪一个节点、VM的ID和名称，点击下一步&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;15051530&#x2F;79039189-275ec800-7c12-11ea-8086-864a54d4758f.png&quot; alt=&quot;image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Step3：选择前面上传的系统安装镜像，点击下一步&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;15051530&#x2F;79039197-30e83000-7c12-11ea-80e0-9c3685fd592c.png&quot; alt=&quot;image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Step4：选择图像选项和BISO类型，推荐图像选项选择VirtIO-GPU，BIOS类型可不选择UEFI，如果选择了UEFI，需要选择UEFI的存储位置，点击下一步&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;15051530&#x2F;79039202-42c9d300-7c12-11ea-854c-5fc1e9a54479.png&quot; alt=&quot;image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Step5：修改磁盘的默认大小，点击下一步&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;15051530&#x2F;79039206-4c533b00-7c12-11ea-964a-5d7776d82cf8.png&quot; alt=&quot;image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Step6：修改CPU核数和CPU启用的额外标志，此处默认，点击下一步&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;15051530&#x2F;79039210-55440c80-7c12-11ea-99c9-593fb0ab1e7f.png&quot; alt=&quot;image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Step7：修改内存大小，此处分配8G，点击下一步&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;15051530&#x2F;79039217-5d03b100-7c12-11ea-8770-45bef5a29fc7.png&quot; alt=&quot;image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Step8：修改网络设置即可，点击下一步&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;15051530&#x2F;79039225-642abf00-7c12-11ea-8161-5f1901a3f489.png&quot; alt=&quot;image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Step9：最后的整体设置预览，点击完成&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;15051530&#x2F;79039227-69880980-7c12-11ea-8800-4afc50732d83.png&quot; alt=&quot;image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;part2-an-zhuang-ubuntu-server-18-04&quot;&gt;Part2：安装Ubuntu Server 18，04&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;strong&gt;Step1：启动安装&lt;&#x2F;strong&gt;，点击z右上角的启动，进入安装阶段&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;15051530&#x2F;79039832-976f4d00-7c16-11ea-9dac-8011bcbbc531.png&quot; alt=&quot;image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Step2：点击控制台，输出vnc画面&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;15051530&#x2F;79039850-b241c180-7c16-11ea-929b-5232bf1a5222.png&quot; alt=&quot;image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Step3：选择语言&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;15051530&#x2F;79039881-f8972080-7c16-11ea-9ec2-0de5bc84b2c3.png&quot; alt=&quot;image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Step4：更新安装器&lt;&#x2F;strong&gt;，推荐进行更新，网络环境较差也可不更新&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;15051530&#x2F;79039527-6857dc00-7c14-11ea-8ef3-24d46f8f6512.png&quot; alt=&quot;image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Step5：配置语言和键盘&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;15051530&#x2F;79039537-74439e00-7c14-11ea-81ab-67875166db11.png&quot; alt=&quot;image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Step6：配置网络，默认即可&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;15051530&#x2F;79039540-79a0e880-7c14-11ea-809f-12be95bd2131.png&quot; alt=&quot;image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Step7：配置代理，按需配置&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;15051530&#x2F;79039551-7efe3300-7c14-11ea-81c8-bb10e9b4da81.png&quot; alt=&quot;image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Step8：配置镜像源，按需配置&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;15051530&#x2F;79039553-845b7d80-7c14-11ea-878e-87ea2409a7be.png&quot; alt=&quot;image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Step9：设置使用一整个磁盘，有需要要也可选择其他选项&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;15051530&#x2F;79039558-8f161280-7c14-11ea-9b6b-ec1752c43b77.png&quot; alt=&quot;image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Step10：选择安装的磁盘&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;15051530&#x2F;79039560-93dac680-7c14-11ea-9337-ddac162b12cd.png&quot; alt=&quot;image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Step11：确认自动分区情况&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;15051530&#x2F;79039565-99381100-7c14-11ea-969e-c13d1979a791.png&quot; alt=&quot;image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Step12：配置用户名、密码与host name&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;15051530&#x2F;79039569-a05f1f00-7c14-11ea-88d2-647293dcfd37.png&quot; alt=&quot;image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Step13：选择安装openssh-server&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;15051530&#x2F;79039578-a94ff080-7c14-11ea-8c3e-0a7215443ac1.png&quot; alt=&quot;image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Step14：推荐不在此页面选择任何额外的软件，此处的软件应该是通过ubnutu的snap包管理器进行安装的，如果不熟悉的情况下，可能选取之后找不到相应的安装结果，我就在前几次的安装中选择了docker，导致系统上有两个docker sever端，令人十分迷惑。&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;15051530&#x2F;79039582-b79e0c80-7c14-11ea-8633-ff004aaf9e37.png&quot; alt=&quot;image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Step15：开始安装，等待安装结束即可&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;15051530&#x2F;79039584-bf5db100-7c14-11ea-8622-9dfd90d3f1ec.png&quot; alt=&quot;image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>PVE折腾记录</title>
        <published>2020-04-07T17:19:31+00:00</published>
        <updated>2020-04-07T17:19:31+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/pve/"/>
        <id>https://ghost.livexia.xyz/pve/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/pve/">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Proxmox VE&lt;&#x2F;strong&gt;（英语：&lt;strong&gt;Proxmox Virtual Environment&lt;&#x2F;strong&gt;，通常简称为&lt;strong&gt;PVE&lt;&#x2F;strong&gt;、&lt;strong&gt;Proxmox&lt;&#x2F;strong&gt;），是一个&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;%E5%BC%80%E6%BA%90&quot;&gt;开源&lt;&#x2F;a&gt;的服务器虚拟化环境&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;Linux%E5%8F%91%E8%A1%8C%E7%89%88&quot;&gt;Linux发行版&lt;&#x2F;a&gt;。Proxmox VE基于&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;Debian&quot;&gt;Debian&lt;&#x2F;a&gt;，使用基于&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;Ubuntu&quot;&gt;Ubuntu&lt;&#x2F;a&gt;的定制&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;Linux%E5%86%85%E6%A0%B8&quot;&gt;内核&lt;&#x2F;a&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;Proxmox_VE#cite_note-1&quot;&gt;[1]&lt;&#x2F;a&gt; &lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;Proxmox_VE#cite_note-2&quot;&gt;[2]&lt;&#x2F;a&gt;，包含安装程序&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;Proxmox_VE#cite_note-3&quot;&gt;[3]&lt;&#x2F;a&gt;、网页控制台和命令行工具，并且向第三方工具提供了&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;REST&quot;&gt;REST&lt;&#x2F;a&gt; API，在&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;Affero%E9%80%9A%E7%94%A8%E5%85%AC%E5%85%B1%E8%AE%B8%E5%8F%AF%E8%AF%81&quot;&gt;Affero通用公共许可证&lt;&#x2F;a&gt;第三版下发行。&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;Proxmox_VE#cite_note-4&quot;&gt;[4]&lt;&#x2F;a&gt;。Proxmox VE支持两类虚拟化技术：基于容器的&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;LXC&quot;&gt;LXC&lt;&#x2F;a&gt;（自4.0版开始，3.4版及以前使用&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;OpenVZ&quot;&gt;OpenVZ&lt;&#x2F;a&gt;技术&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;Proxmox_VE#cite_note-5&quot;&gt;[5]&lt;&#x2F;a&gt;）和硬件抽象层全虚拟化的&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA&quot;&gt;KVM&lt;&#x2F;a&gt;。&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;Proxmox_VE#cite_note-6&quot;&gt;[6]&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;dian-nao-pei-zhi&quot;&gt;电脑配置&lt;&#x2F;h2&gt;
&lt;p&gt;去年年底将RX580换成5700xt，年初又将CPU换成了R9 3900X，于是闲置了2600和rx580，又将笔记本卖了，于是限制了一些ssd和硬盘，去年又趁着内存降价淘了两根16G的垃圾内存，在迫击炮上和十铨内存不兼容，于是萌生了组一个itx的念头，于是就有了下列的电脑配置。散热器用了3900x的，风扇选用了一个大风量的Arctic和利民的静音扇，实际体验也很不错，可以做到7*24。其余购入：主板、机箱与电源，都是在好友的推荐下购入&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CPU: AMD Ryzen R5 2600&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;MotherBoard: A320M-ITX&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Graphics card: MAXSUN MS-RX580 1340MHz&#x2F;8000MHz&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;RAM: Gloway 16 DDR4 2666 MHz * 2&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Stroage&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;SSD: LITEON_CV6-8Q128  128G&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;HDD:&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;ST1000LM048-2E7172   1T&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;ST2000LM015-2E8174   2T&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Power Supply: FSP MS450&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Case: GEEK N501&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Colling Fan: Arctic F8 PWM + Thermalright TY08015B&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;以上配置唯一不太满意的地方就是主板，其实还是直接加200上b450的itx更好些，不过这块主板也是妖板没有特别的问题。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;xi-tong-xuan-ze&quot;&gt;系统选择&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;Windows 10&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;ul&gt;
&lt;li&gt;Pro：游戏、日常办公&lt;&#x2F;li&gt;
&lt;li&gt;Con：由于主用机的存在，注定了使用率较少，意义不大&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Linux：Manjaro、Kali&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;ul&gt;
&lt;li&gt;Pro：编码与环境准备等&lt;&#x2F;li&gt;
&lt;li&gt;Con：使用率太低，经常还是通过ssh连接l简单运行docker，有很多软件包在不同发行版上有更加良好的体验。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;虚拟化系统&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;ul&gt;
&lt;li&gt;Pro：随心用，适合折腾&lt;&#x2F;li&gt;
&lt;li&gt;Con：上手门槛高，硬件直通效率可能是瓶颈&lt;&#x2F;li&gt;
&lt;li&gt;选取的部分版本：&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;ol&gt;
&lt;li&gt;EXSI：系统需要针对硬件特殊定制（增加网卡驱动等），易用性不足&lt;&#x2F;li&gt;
&lt;li&gt;PVE：开源，基于Debian，支持虚拟机与LXC容器，使用相对简单&lt;&#x2F;li&gt;
&lt;li&gt;Etc：Unraid等，主要都是商用版本，对于我的使用场景暂时没必要&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;pvean-zhuang&quot;&gt;PVE安装&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;下载ISO&lt;&#x2F;li&gt;
&lt;li&gt;利用工具将ISO写入U盘&lt;&#x2F;li&gt;
&lt;li&gt;利用U盘安装PVE&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;xia-zai-iso&quot;&gt;下载ISO&lt;&#x2F;h3&gt;
&lt;p&gt;从这个地址下载pve的iso镜像：&lt;a href=&quot;https:&#x2F;&#x2F;www.proxmox.com&#x2F;en&#x2F;downloads&#x2F;category&#x2F;iso-images-pve&quot;&gt;pve download&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;li-yong-gong-ju-jiang-isoxie-ru-upan&quot;&gt;利用工具将ISO写入U盘&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;rufus.ie&#x2F;&quot;&gt;rufus&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.balena.io&#x2F;etcher&#x2F;&quot;&gt;etcher&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;li-yong-upan-an-zhuang-pve&quot;&gt;利用U盘安装PVE&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;pve.proxmox.com&#x2F;wiki&#x2F;Installation&quot;&gt;官方链接&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;can-kao-lian-jie&quot;&gt;参考链接：&lt;&#x2F;h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;post.smzdm.com&#x2F;p&#x2F;768830&#x2F;&quot;&gt;https:&#x2F;&#x2F;post.smzdm.com&#x2F;p&#x2F;768830&#x2F;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;chu-shi-pei-zhi&quot;&gt;初始配置&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;qie-huan-debianyuan&quot;&gt;切换debian源&lt;&#x2F;h3&gt;
&lt;p&gt;pve 6.1是基于Debian buster上进一步定制而来，所以基础的软件源使用debian的源即可，这里放一个我认为比较好的镜像源地址：&lt;a href=&quot;https:&#x2F;&#x2F;mirror.tuna.tsinghua.edu.cn&#x2F;help&#x2F;debian&#x2F;&quot;&gt;清华Debian镜像使用帮助&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;an-zhuang-bi-yao-ruan-jian&quot;&gt;安装必要软件&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;vim curl wget net-tools&lt;&#x2F;li&gt;
&lt;li&gt;vim是我经常使用的一个文本编辑器，简单易用，也不需要过多的设置&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;qie-huan-pveyuan&quot;&gt;切换PVE源&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h5 id=&quot;shan-chu-shang-yong-yuan&quot;&gt;删除商用源&lt;&#x2F;h5&gt;
&lt;p&gt;&lt;code&gt;rm -f &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;pve-enterprise.list&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h5 id=&quot;tian-jia-fei-shang-yong-de-yuan&quot;&gt;添加非商用的源&lt;&#x2F;h5&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;echo &amp;quot;deb https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;proxmox&#x2F;debian&#x2F;pve buster pve-no-subscription&amp;quot; &amp;gt; &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;pve-install-repo.list
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h5 id=&quot;shi-yong-guo-nei-yuan-dai-li-jia-kuai-pvexiang-guan-de-geng-xin&quot;&gt;使用国内源代理，加快pve相关的更新&lt;&#x2F;h5&gt;
&lt;p&gt;如上图所示，采用了ustc，中科大的源&lt;&#x2F;p&gt;
&lt;h3 id=&quot;geng-xin-xi-tong-yu-ruan-jian&quot;&gt;更新系统与软件&lt;&#x2F;h3&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;apt update
&lt;&#x2F;span&gt;&lt;span&gt;apt dist-upgrade
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;xiu-gai-ceph-lsityi-jia-kuai-cephde-an-zhuang-ke-xuan&quot;&gt;修改ceph.lsit以加快ceph的安装（可选）&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;&#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;ceph.list&lt;&#x2F;code&gt; 是ceph的源，网上的教程里都没有提及这一点，如果需要使用ceph建议修改，文件内容如下&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;deb https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;proxmox&#x2F;debian&#x2F;ceph-nautilus&#x2F; buster main
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;注意：利用web gui安装ceph可能会导致ceph源修改失效，建议手动安装所有需要的软件包，在此不一一列出&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;xiu-gai-jswen-jian-yi-qu-xiao-wei-ding-yue-ti-shi-ke-xuan&quot;&gt;修改js文件以取消未订阅提示（可选）&lt;&#x2F;h3&gt;
&lt;p&gt;文件路径：&lt;code&gt;&#x2F;usr&#x2F;share&#x2F;javascript&#x2F;proxmox-widget-toolkit&#x2F;proxmoxlib.js&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;shell中使用VI等工具编辑，将&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;if(data.status!==&#x27;Active&#x27;){&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;替换为&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;if(false){&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;注意：如果更新时将pve相关组件更新，可能胡造成这个修改失效，需要每次重新进行修改&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ci-pan-pei-zhi&quot;&gt;磁盘配置&lt;&#x2F;h2&gt;
&lt;p&gt;在安装pve时，选择了ssd作为target，即将pve系统安装在ssd上，在option选项下调整了swap分区的大小为38G。&lt;&#x2F;p&gt;
&lt;p&gt;安装完成后SSD的磁盘分区状态如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;Device       Start       End   Sectors   Size Type
&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;dev&#x2F;sdc1       34      2047      2014  1007K BIOS boot
&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;dev&#x2F;sdc2     2048   1050623   1048576   512M EFI System
&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;dev&#x2F;sdc3  1050624 250069646 249019023 118.8G Linux LVM
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可见，其中主要是LVM分区，LVM分区在此不进行赘述。&lt;&#x2F;p&gt;
&lt;p&gt;LVM其中分区：有三分之一作为root分区，有三分之一作为data分区供最早的虚拟机使用，剩余三分之一就是交换分区了。由于其中大概只有60G是真正PVE可使用的分区，所以必须要有额外的空间作为使用。&lt;&#x2F;p&gt;
&lt;p&gt;机器上总共安装了一块2T、一块1T的机械硬盘，所以计划是将1T的磁盘用作存放ISO、LXC镜像和虚拟磁盘等，2T的磁盘专门用作虚拟磁盘使用，这样可以达到最大的使用率。&lt;&#x2F;p&gt;
&lt;p&gt;分区工具：gdisk，可以使用gdisk做gpt分区，也可以在pve的web gui上进行磁盘挂载与修改，如果玩坏了，可以使用gdisk来进行修改，使用大体上与fdisk相当。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;注意：不要使用fdisk进行分区，可能会破坏gpt分区表，导致pve界面无法识别&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;分区规划：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;1T：创建为Directory，可以实现最大的功能：磁盘映像, 容器模板, VZDump备份文件, 片段, 容器, ISO镜像&lt;&#x2F;li&gt;
&lt;li&gt;2T：创建为LLVM-Thin，用作虚拟机磁盘，保证虚拟机有足够的空间：磁盘映像, 容器&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;pciezhi-tong&quot;&gt;PCIE直通&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;yong-tu&quot;&gt;用途&lt;&#x2F;h3&gt;
&lt;p&gt;计划利用pve安装Ubuntu 18.04.4, 并在Ubuntu上安装ROCM，实现amd侧的深度学习环境搭建&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ji-chu-she-zhi&quot;&gt;基础设置&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;kai-qi-xu-ni-hua-iommu&quot;&gt;开启虚拟化、iommu&lt;&#x2F;h4&gt;
&lt;p&gt;在主板bios的选项中开启虚拟化和iommu设置，一般来说虚拟化还是比较好找到，但是iommu就不一定了，我是下载了主办的完整说明书，才找到相关设置的位置&lt;&#x2F;p&gt;
&lt;h4 id=&quot;xiu-gai-xi-tong-qi-dong-xuan-xiang-xi-tong-nei-he-mo-kuai&quot;&gt;修改系统启动选项、系统内核模块&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;strong&gt;Step 1: 修改Grub配置&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;vim &#x2F;etc&#x2F;default&#x2F;grub
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;修改这一行:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;GRUB_CMDLINE_LINUX_DEFAULT=&amp;quot;quiet&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;For Intel CPUs:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;GRUB_CMDLINE_LINUX_DEFAULT=&amp;quot;quiet intel_iommu=on&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;For AMD CPUs:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;GRUB_CMDLINE_LINUX_DEFAULT=&amp;quot;quiet amd_iommu=on&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;update-grub
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Step 2: 添加VFIO模块&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;vim &#x2F;etc&#x2F;modules
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;增加以下几行:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;vfio
&lt;&#x2F;span&gt;&lt;span&gt;vfio_iommu_type1
&lt;&#x2F;span&gt;&lt;span&gt;vfio_pci
&lt;&#x2F;span&gt;&lt;span&gt;vfio_virqfd
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Step 3: 更新grub并重启&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;update-grub
&lt;&#x2F;span&gt;&lt;span&gt;reboot
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Step4: 修改虚拟机&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;给虚拟机新增pci设备&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;All Functions: YES
&lt;&#x2F;span&gt;&lt;span&gt;Rom-Bar: YES
&lt;&#x2F;span&gt;&lt;span&gt;Primary GPU: NO
&lt;&#x2F;span&gt;&lt;span&gt;PCI-Express: NO (如果需要改动这一项，需要修改机器类型为q35)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;fang-an-shuo-ming&quot;&gt;方案说明&lt;&#x2F;h3&gt;
&lt;p&gt;这是我自己最初的方案，这个方案下，GPU不是PCIE直通，但是在第一次安装后，然后安装ROCM重新启动之后也还是能正常进入系统。其余方案我尝试各种设置都是没法在安装完ROCM后能够进入系统的，图形界面都属于挂起状态，如果能进入终端的时候，rocm也无法识别到显卡，这个方案有很大的不足那就是性能问题，下面会讲。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;bu-zu&quot;&gt;不足&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;性能不足：跑tf benchmark，普遍性能只有网上教程里的一半&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;xian-qia-zhi-tong-shuo-ming&quot;&gt;显卡直通说明&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;如果是多卡设备，推荐还是参考文末的&lt;a href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;homelab&#x2F;comments&#x2F;b5xpua&#x2F;the_ultimate_beginners_guide_to_gpu_passthrough&#x2F;&quot;&gt;reddit&lt;&#x2F;a&gt;链接的配置，可以实现完全的显卡直通，不丢失性能。&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;can-kao-lian-jie-1&quot;&gt;参考链接：&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;post.smzdm.com&#x2F;p&#x2F;768830&#x2F;&quot;&gt;https:&#x2F;&#x2F;post.smzdm.com&#x2F;p&#x2F;768830&#x2F;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;homelab&#x2F;comments&#x2F;b5xpua&#x2F;the_ultimate_beginners_guide_to_gpu_passthrough&#x2F;&quot;&gt;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;homelab&#x2F;comments&#x2F;b5xpua&#x2F;the_ultimate_beginners_guide_to_gpu_passthrough&#x2F;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>ROCm安装记录</title>
        <published>2020-04-06T14:21:08+00:00</published>
        <updated>2020-04-06T14:21:08+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/install-rocm/"/>
        <id>https://ghost.livexia.xyz/install-rocm/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/install-rocm/">&lt;h2 id=&quot;an-zhuang-huan-jing&quot;&gt;安装环境&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;PVE虚拟机：Ubuntu 18.04.4&lt;&#x2F;li&gt;
&lt;li&gt;显卡：直通RX580&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;an-zhuang-jiao-cheng&quot;&gt;安装教程&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;rocm-documentation.readthedocs.io&#x2F;en&#x2F;latest&#x2F;Installation_Guide&#x2F;Installation-Guide.html&quot;&gt;https:&#x2F;&#x2F;rocm-documentation.readthedocs.io&#x2F;en&#x2F;latest&#x2F;Installation_Guide&#x2F;Installation-Guide.html&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;strong&gt;简单将Ubuntu的部分简单翻译&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;cong-debiancang-ku-an-zhuang-rocm&quot;&gt;从debian仓库安装ROCm&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;strong&gt;Step1：执行下列命令，确保系统的组件为最新:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;建议替换为 &lt;a href=&quot;https:&#x2F;&#x2F;mirror.tuna.tsinghua.edu.cn&#x2F;help&#x2F;ubuntu&#x2F;&quot;&gt;清华源&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;sudo apt update
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;sudo apt dist-upgrade
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;sudo apt install libnuma-dev
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;sudo reboot
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Step2：增加ROCm apt 仓库地址&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;对于类似Ubuntu的基于Debian的系统执行下列命令：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;wget -q -O - http:&#x2F;&#x2F;repo.radeon.com&#x2F;rocm&#x2F;apt&#x2F;debian&#x2F;rocm.gpg.key | sudo apt-key add -
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;echo &amp;#39;deb [arch=amd64] http:&#x2F;&#x2F;repo.radeon.com&#x2F;rocm&#x2F;apt&#x2F;debian&#x2F; xenial main&amp;#39; | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;rocm.list
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Step3：更新仓库列表然后安装 rocm-dkms meta-package:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;sudo apt update
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;sudo apt install rocm-dkms
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Step4：设置权限。&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;必须成为video用户组的一员才能访问GPU。 利用以下命令确定当前用户是否是video用户组的一员&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;groups
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;执行下列语句添加当前用户到video组，需要当前用户是sudoer&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;sudo usermod -a -G video $LOGNAME
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;执行下列语句，会在下次新建用户时，默认将用户加到video组:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;echo &amp;#39;ADD_EXTRA_GROUPS=1&amp;#39; | sudo tee -a &#x2F;etc&#x2F;adduser.conf
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;echo &amp;#39;EXTRA_GROUPS=video&amp;#39; S| sudo tee -a &#x2F;etc&#x2F;adduser.conf
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Step5：重启&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Step6：简单测试安装&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;重启之后运行以下命令，确认安装是否成功，如果在命令输出结果中都能看见你的GPU，那么安装成功了&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;&#x2F;opt&#x2F;rocm&#x2F;bin&#x2F;rocminfo
&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;opt&#x2F;rocm&#x2F;opencl&#x2F;bin&#x2F;x86_64&#x2F;clinfo
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note:为了运行ROCm程序更加高效，可执行以下命令，增加ROCm二进制路径到PATH中.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;echo &amp;#39;export PATH=$PATH:&#x2F;opt&#x2F;rocm&#x2F;bin:&#x2F;opt&#x2F;rocm&#x2F;profiler&#x2F;bin:&#x2F;opt&#x2F;rocm&#x2F;opencl&#x2F;bin&#x2F;x86_64&amp;#39; |
&lt;&#x2F;span&gt;&lt;span&gt;sudo tee -a &#x2F;etc&#x2F;profile.d&#x2F;rocm.sh
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;cong-ubuntuzhong-shan-chu-rocmxiang-guan-ruan-jian-bao&quot;&gt;从Ubuntu中删除ROCm相关软件包&lt;&#x2F;h4&gt;
&lt;p&gt;从Ubuntu 16.04.6 或者 Ubuntu 18.04.4中卸载ROCm相关软件包，执行以下命令:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;sudo apt autoremove rocm-opencl rocm-dkms rocm-dev rocm-utils
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;an-zhuang-xiang-guan-kai-fa-ruan-jian-bao-yi-zhi-chi-kua-ping-tai-bian-yi&quot;&gt;安装相关开发软件包以支持跨平台编译&lt;&#x2F;h4&gt;
&lt;p&gt;推荐在不同的平台上开发和测试软件包。例如有的开发或者构建环境上并没有安装AMD的GPU，在这样的情况下应该避免安装ROCk 内核驱动在开发的机器中。&lt;&#x2F;p&gt;
&lt;p&gt;应该使用下列命令安装开发软件包：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;sudo apt update
&lt;&#x2F;span&gt;&lt;span&gt;sudo apt install rocm-dev
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note: 如果需要执行ROCm使能的应用软件，那么你必须在环境中安装完整的ROCm驱动栈。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;pei-he-shang-you-nei-he-shi-yong-ji-yu-debiande-rocm&quot;&gt;配合上有内核使用基于Debian的ROCm&lt;&#x2F;h4&gt;
&lt;p&gt;你可以不安装AMD的定制化ROCk内核驱动，直接安装ROCm作为用户层软件。&lt;&#x2F;p&gt;
&lt;p&gt;如果想要使用上游内核，使用以下命令安装ROCm而不是直接安装rocm-dkms：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;sudo apt update
&lt;&#x2F;span&gt;&lt;span&gt;sudo apt install rocm-dev
&lt;&#x2F;span&gt;&lt;span&gt;echo &amp;#39;SUBSYSTEM==&amp;quot;kfd&amp;quot;, KERNEL==&amp;quot;kfd&amp;quot;, TAG+=&amp;quot;uaccess&amp;quot;, GROUP=&amp;quot;video&amp;quot;&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;sudo tee &#x2F;etc&#x2F;udev&#x2F;rules.d&#x2F;70-kfd.rules
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;li-yong-tensorflow-benchmarksque-ren-an-zhuang-jie-guo&quot;&gt;利用TensorFLow benchmarks确认安装结果&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;下载代码&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;git clone https:&#x2F;&#x2F;github.com&#x2F;tensorflow&#x2F;benchmarks.git
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;安装依赖&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;sudo apt install rocm-libs python3-pip 
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如果运行报错：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;librccl.so: cannot open shared object file: No such file or directory&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;说明缺少依赖 rccl&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;sudo apt install rccl
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;安装tensorflow-rocm&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;参照 pypi&lt;a href=&quot;https:&#x2F;&#x2F;mirror.tuna.tsinghua.edu.cn&#x2F;help&#x2F;pypi&#x2F;&quot;&gt;镜像使用帮助&lt;&#x2F;a&gt; 利用清华源镜像下载tensorflow-rocm&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;pip install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple tensorflow-rocm
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;运行脚本&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;cd benchmarks&#x2F;scripts&#x2F;tf_cnn_benchmarks
&lt;&#x2F;span&gt;&lt;span&gt;python3 tf_cnn_benchmarks.py --num_gpus=1 --batch_size=64 --model=resnet50
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;运行结果&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;由于是在不完全显卡直通的pve虚拟机上运行的，基本性能只有网上测评的一般，上述命令测试结果是：88 images&#x2F;sec&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;后续测试&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;由于tensorflow benchmarks中的script不在推荐，下次会再次使用其中提供的perfzero进行测试。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Sleep Sort</title>
        <published>2020-04-05T16:03:21+00:00</published>
        <updated>2020-04-05T16:03:21+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/sleep-sort/"/>
        <id>https://ghost.livexia.xyz/sleep-sort/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/sleep-sort/">&lt;p&gt;别出新奇的算法：睡眠排序（sleep sort）&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>作者与读者的理解</title>
        <published>2020-04-05T15:39:01+00:00</published>
        <updated>2020-04-05T15:39:01+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/author-and-reader-understanding/"/>
        <id>https://ghost.livexia.xyz/author-and-reader-understanding/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/author-and-reader-understanding/">&lt;h2 id=&quot;wen-xue-zuo-pin-nei-han-de-yi-yi-yu-zuo-zhe-xia-bi-shi-de-xin-jing-he-du-zhe-yue-du-shi-de-li-jie&quot;&gt;文学作品内涵的意义与作者下笔时的心境和读者阅读时的理解&lt;&#x2F;h2&gt;
&lt;p&gt;读书的时候，并不理解为何在阅读理解的题目中，学生和老师为何要百般揣摩作者写下一句话时内里的含义与内心的想法，长久以来也还是能看见其实作者根本没这个意思的各种言论。在看完台北人之后，有了一些感悟，作家写下深刻的文字，有可能并不是想表达各种深意，而有可能是他的潜意识或者说生活给他带来的积淀，这种情况下，就很可能作者并没有考虑到那么深层的原因，但是在下笔时就自然而然的显现出来。当然也有是在深思熟虑中巧妙设计人物，搭建背景而形成的深刻文学，读者读之仍会有一千个哈姆雷特。就像最近看完的电视剧，老爸老妈浪漫史中，巴尼对电影的理解和常人相反。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>渺小一生 柳原汉雅</title>
        <published>2020-03-31T15:48:07+00:00</published>
        <updated>2020-03-31T15:48:07+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/a-little-life-note/"/>
        <id>https://ghost.livexia.xyz/a-little-life-note/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/a-little-life-note/">&lt;p&gt;打开kindle发现我下载了这本书的试读版本，又感觉自己又感觉自己太久没有读书了，就下单付款了。&lt;&#x2F;p&gt;
&lt;p&gt;故事开头其实有点无聊，描述了四个好友的日常故事，介绍了每个人物的背景、家庭。&lt;&#x2F;p&gt;
&lt;p&gt;人是由经历组成了特殊的人，初生的人之间只在形体上有差距。&lt;&#x2F;p&gt;
&lt;p&gt;成长中的各个经历塑造了人的思想，划定了人的行为。&lt;&#x2F;p&gt;
&lt;p&gt;主人公裘德在16岁之前经历了多少人一生都难以经历的困苦、磨难和不幸，导致在生命的最后阶段仍是绝望痛苦。&lt;&#x2F;p&gt;
&lt;p&gt;渺小一生中种种的悲剧，裘德快乐的日子稀少，幼年时与卢克修士在修道院的日子，大学时与朋友无忧的日子，毕业后被收养的快乐和与家人朋友共度的短暂时光。&lt;&#x2F;p&gt;
&lt;p&gt;而他的痛苦何止千千万万，幼年的虐待，在人群中的格格不入，永远无法轻易相信其他人，被第一个男友虐待，威廉和好友的不幸离世，无时不刻的生理上的痛苦，为了克服心里的不安与羞愧而伤害自己，难以启齿的过往，痛苦数不胜数。&lt;&#x2F;p&gt;
&lt;p&gt;人的一生最重要的就是找到方法抒发自己的情绪，找到那个人，找到那种方式，不要让过去控制了自己。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>2019阅读</title>
        <published>2020-03-04T13:03:21+00:00</published>
        <updated>2020-03-04T13:03:21+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/2019-reading-list/"/>
        <id>https://ghost.livexia.xyz/2019-reading-list/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/2019-reading-list/">&lt;h3 id=&quot;du-wan&quot;&gt;读完：&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;漫长的告别&lt;&#x2F;li&gt;
&lt;li&gt;神们自己&lt;&#x2F;li&gt;
&lt;li&gt;杀死一只知更鸟&lt;&#x2F;li&gt;
&lt;li&gt;一个叫欧维的男人决定去死&lt;&#x2F;li&gt;
&lt;li&gt;局外人&lt;&#x2F;li&gt;
&lt;li&gt;正红旗下&lt;&#x2F;li&gt;
&lt;li&gt;银河系搭车客指南&lt;&#x2F;li&gt;
&lt;li&gt;天生有罪&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;wei-du-wan&quot;&gt;未读完&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;枪炮、病菌与钢铁&lt;&#x2F;li&gt;
&lt;li&gt;莎士比亚书店&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>天生有罪，一个南非男孩成长的故事</title>
        <published>2019-10-04T08:06:49+00:00</published>
        <updated>2019-10-04T08:06:49+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/born-a-crime/"/>
        <id>https://ghost.livexia.xyz/born-a-crime/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/born-a-crime/">&lt;h3 id=&quot;tian-sheng-you-zui&quot;&gt;天生有罪&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;born-a-crime-stories-from-a-south-african-childhood&quot;&gt;Born a Crime: Stories from a South African Childhood&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;zuo-zhe-te-lei-fu-nuo-ya&quot;&gt;作者：特雷弗·诺亚&lt;&#x2F;h4&gt;
&lt;h4 id=&quot;zuo-zhe-xiang-guan-xiao-cui-mei-ri-xiu-zhu-chi-ren&quot;&gt;作者相关：《小崔每日秀》主持人&lt;&#x2F;h4&gt;
&lt;p&gt;作为一个在海外火遍的脱口秀的节目主持人，我经常在Youtube上偶然撞见作者主持的脱口秀节目。作者在中国大火还是因为他的一个5G视频:&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=CEQTo9usai4&quot;&gt;If You Don&#x27;t Know, Now You Know: 5G&lt;&#x2F;a&gt;，视频中作者以很幽默诙谐同时又略带嘲讽的方式讽刺了川普的政治主张，同时又科普了5G。光看节目很难想象作者从小生活的环境有多么的艰苦与恶劣。&lt;&#x2F;p&gt;
&lt;p&gt;南非，在我心目中一直是一个很活泼的国家，在这个国家白人黑人混杂，同时又给我一种他们生活环境、水平都很好的感觉。&lt;&#x2F;p&gt;
&lt;p&gt;通过阅读《天生有罪》，完完全全的推翻了我对作者和南非的认知。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;nan-fei&quot;&gt;南非&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;p&gt;摘选维基百科&lt;&#x2F;p&gt;
&lt;p&gt;一个非洲国家，现为南非共和国，南非拥有三个首都，同时莱索托王国完全位于南非境内。&lt;&#x2F;p&gt;
&lt;p&gt;行政首都：勒陀利亚，立法首都：开普敦，司法首都：布隆方丹&lt;&#x2F;p&gt;
&lt;p&gt;经济、文化中心：约翰内斯堡&lt;&#x2F;p&gt;
&lt;p&gt;官方语言：11种&lt;&#x2F;p&gt;
&lt;p&gt;地方语言：7种&lt;&#x2F;p&gt;
&lt;p&gt;族群：80.7% 黑人、8.8% 有色人种、7.9% 白人、2.6% 亚裔&lt;&#x2F;p&gt;
&lt;p&gt;宗教：73.2% 新教、14.9% 无宗教、7.4% 天主教、1.7% 伊斯兰教、1.1% 印度教、1.7% 其他信仰&lt;&#x2F;p&gt;
&lt;p&gt;独立：从英国殖民中独立&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;联邦：1910-5-31&lt;&#x2F;li&gt;
&lt;li&gt;自治：1931-12-11&lt;&#x2F;li&gt;
&lt;li&gt;共和国：1961-5-31&lt;&#x2F;li&gt;
&lt;li&gt;先行宪法：1997-2-4&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;种族斗争：少数的白人与占多数的黑人间的种族冲突&lt;&#x2F;p&gt;
&lt;p&gt;冲突顶峰：1948-1990&lt;&#x2F;p&gt;
&lt;p&gt;南非撤资运动：1960年起，抵制南非的种族隔离制度，1980年开始大规模行动。1986年美国联邦里发推行撤资行动。迫使南非政府开始就种族隔离问题进行谈判。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;书中作者描述了一个疯狂的南非，一个有白人、黑人、有色人构成的疯狂的南非，作者母亲是一个在逆境中顽强向上的妇女，和一个荷兰人创造了作者，所以作者是一个有色人：黑人与白人的后代。&lt;&#x2F;p&gt;
&lt;p&gt;作者在复杂的环境里，被母亲追赶，被母亲半强迫的去到各种不同的教堂，在母亲看似好不讲理实则是母亲的人生哲理的教育下逐渐成长。&lt;&#x2F;p&gt;
&lt;p&gt;由于种族冲突和斗争使得作者难以融入任何一个群体，黑人觉得有色人是白人那边的，白人很多时候根本瞧不起有色人，而有色人根本不知道自己该往哪里走。作者渐渐成为一个局外人，作者通过贩卖食物，到处都有人欢迎他，每个圈子都喜欢他出现，但是作者又部不属于其中任何一个圈子，作者慢慢的敞开自己，进而保护自己。&lt;&#x2F;p&gt;
&lt;p&gt;贩卖盗版音乐，自己制作混响音乐，都是在那个复杂环境下，作者为了生存每一次跳出自己的舒适圈，作者做过许多错事，但是从没有到不能回头的时候。&lt;&#x2F;p&gt;
&lt;p&gt;作者通过负责派对音乐，逐渐积累起了财富，让作者意识到有钱其实是赋予了选择的权力，有钱是为了拥有更多的选择，这就是金钱的自由。赚钱不是为了有钱，而是为了面对选择但时候，可以不那么受到限制，拥有更多的自由。&lt;&#x2F;p&gt;
&lt;p&gt;最深的感悟：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;但是后悔才是我们最该害怕的事。失败是一种答案，拒绝也是一种答案。但后悔却是你永远得不到答案的永恒问题。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>关于ssh认证</title>
        <published>2019-09-03T17:05:53+00:00</published>
        <updated>2019-09-03T17:05:53+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/aboutssh/"/>
        <id>https://ghost.livexia.xyz/aboutssh/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/aboutssh/">&lt;p&gt;ssh说明：Secure Shell的简称，建立安全网络隧道，连接到远程服务器&#x2F;工作站。&lt;&#x2F;p&gt;
&lt;p&gt;常见ssh连接要求：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;在远程连接地址（服务器）上开放ssh端口（默认22）&lt;&#x2F;li&gt;
&lt;li&gt;可以通过ip进行连接（ping通）&lt;&#x2F;li&gt;
&lt;li&gt;存在一定的身份验证机制&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;常见ssh连接场景（密码）：在本地shell终端输入ssh root@ip进行访或在本地ssh客户端输入ip、端口、用户名、密码进行连接。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>《局外人》读后感</title>
        <published>2019-09-03T17:05:24+00:00</published>
        <updated>2019-09-03T17:05:24+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/the-outsider-note/"/>
        <id>https://ghost.livexia.xyz/the-outsider-note/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/the-outsider-note/">&lt;p&gt;看到了自己&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>《神们自己》读后感</title>
        <published>2019-09-03T17:05:20+00:00</published>
        <updated>2019-09-03T17:05:20+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/the-gods-themselves-note/"/>
        <id>https://ghost.livexia.xyz/the-gods-themselves-note/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/the-gods-themselves-note/">&lt;blockquote&gt;
&lt;p&gt;面对愚昧，神们自己也缄口不言&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h4 id=&quot;di-yi-zhang-guan-yu-di-qiu&quot;&gt;第一章：关于地球&lt;&#x2F;h4&gt;
&lt;h4 id=&quot;di-er-zhang-guan-yu-ping-xing-yu-zhou&quot;&gt;第二章：关于平行宇宙&lt;&#x2F;h4&gt;
&lt;h4 id=&quot;di-san-zhang-guan-yu-shen&quot;&gt;第三章：关于神&lt;&#x2F;h4&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>3D打印机--Part1</title>
        <published>2019-09-03T17:04:38+00:00</published>
        <updated>2019-09-03T17:04:38+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/3dprinterpart1/"/>
        <id>https://ghost.livexia.xyz/3dprinterpart1/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/3dprinterpart1/">&lt;h3 id=&quot;chu-zhong&quot;&gt;初衷&lt;&#x2F;h3&gt;
&lt;p&gt;工作一段时间后，感觉平时空闲时间学习的东西太少，希望寻求一个项目让自己投入其中，同时尽量将钱花在可能可以提升自我的设备上。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;she-bei&quot;&gt;设备&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;Ender 3Pro&lt;&#x2F;li&gt;
&lt;li&gt;树莓派3b+&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;ruan-jian&quot;&gt;软件&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;octoprint.org&#x2F;&quot;&gt;OctoPrint&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;ji-hua&quot;&gt;计划&lt;&#x2F;h3&gt;
&lt;p&gt;Ender 3 Pro原装主板；ATmega1284P - 8-bit AVR Microcontrollers，缺点：板载内存太小，需要增加新功能时要舍弃部分功能来让出空间，且每次修改都需要利用IDE刷写固件，耗时耗力。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;xiang-guan-lian-jie&quot;&gt;相关链接&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=-XUQKQnUNig&quot;&gt;SKR Mini E3 - The best Ender 3 upgrade from stock?&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=1RuasPvZhx0&quot;&gt;OctoPrint: Control Your 3D Printer Remotely Using a Raspberry Pi!&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=SvZjNSLXAJc&quot;&gt;How to setup Octoprint &#x2F; Experimenting with Octolapse&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=yAfalR7-Tvw&amp;amp;t=931s&quot;&gt;Using a 32 bit Raspberry Pi to boost your 3D printer mainboard - Klipper Ender 3 guide&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>预言构思</title>
        <published>2019-09-03T16:53:40+00:00</published>
        <updated>2019-09-03T16:53:40+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/fiction-prophecy/"/>
        <id>https://ghost.livexia.xyz/fiction-prophecy/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/fiction-prophecy/">&lt;h2 id=&quot;yu-yan&quot;&gt;预言&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;对未来将发生的事情的预报或者断言。一般来说预言指的不是通过科学规律对未来所作的计算而得出的结论，而是指某人通过预知超能力出于灵感获得的预报。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;预言常常出现在虚构类文学中，往往预言贯穿整个故事，由预言引出故事，再由预言结束故事。&lt;&#x2F;p&gt;
&lt;p&gt;长期预言：未来很长一段时间内的预言&lt;&#x2F;p&gt;
&lt;p&gt;英雄预言：XX拯救世界、有个人从天降临&lt;&#x2F;p&gt;
&lt;p&gt;环境预言：末世预言、战争预言&lt;&#x2F;p&gt;
&lt;p&gt;短期预言：短期的预言，例如购买彩票&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>iPv6 折腾</title>
        <published>2019-05-10T14:56:16+00:00</published>
        <updated>2019-05-10T14:56:16+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/ipv6/"/>
        <id>https://ghost.livexia.xyz/ipv6/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/ipv6/">&lt;h4 id=&quot;zhe-teng-qian&quot;&gt;折腾前：&lt;&#x2F;h4&gt;
&lt;ul&gt;
&lt;li&gt;路由器：斐讯K3&lt;&#x2F;li&gt;
&lt;li&gt;路由器系统：Merlin（tbvvnet）基于Asuswrt&lt;&#x2F;li&gt;
&lt;li&gt;网络：校园移动网络&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;qi-yin&quot;&gt;起因：&lt;&#x2F;h4&gt;
&lt;p&gt;因为了解了iPv6的相关技术，所以希望在自己的环境里进行实验。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;ji-shu-jie-shao&quot;&gt;技术介绍：&lt;&#x2F;h4&gt;
&lt;ol&gt;
&lt;li&gt;Asuswrt：&lt;&#x2F;li&gt;
&lt;li&gt;OpenWrt：&lt;&#x2F;li&gt;
&lt;li&gt;iPv6：&lt;&#x2F;li&gt;
&lt;li&gt;DHCPV6-PD：pppoe-wan获取到ipv4和ipv6地址，在lan上直接获取到本地ISP的iPv6前缀，路由器再根据前缀分配ipv6地址给局域网设备。&lt;&#x2F;li&gt;
&lt;li&gt;域名解析，解析iPv6地址，需要在nameserver上增加AAAA的解析。&lt;&#x2F;li&gt;
&lt;li&gt;DDNS：动态域名解析。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h4 id=&quot;chu-bu-zhe-teng&quot;&gt;初步折腾：&lt;&#x2F;h4&gt;
&lt;ol&gt;
&lt;li&gt;直接在路由系统iPv6页面上设置，连接选项Native，端口ppp，勾选Dhcpv6-dp&lt;&#x2F;li&gt;
&lt;li&gt;这样设置之后本地可以直接获取到iPv6，因为本地ISP支持DHCPV6-PD，自动会分配给局域网每个支持iPv6设备iPv6。&lt;&#x2F;li&gt;
&lt;li&gt;DHCPV6-PD分配iPv6后缀有两种方式：stateless（无状态）、stateful（有状态）。简单来说无状态会分配一个较短的iPv6后缀地址，且相对稳定不变。&lt;&#x2F;li&gt;
&lt;li&gt;在路由器页面上放宽iPv6地址（直接ip或者ip后缀）的端口请求。&lt;&#x2F;li&gt;
&lt;li&gt;解析域名的AAAA为局域网内设备的iPv6地址配合防火墙放宽，可以实现iPv6互通。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h5 id=&quot;que-dian&quot;&gt;缺点：&lt;&#x2F;h5&gt;
&lt;ol&gt;
&lt;li&gt;路由器系统Merlin的httpd服务仅能绑定ipv4地址，不支持ipv6访问管理，导致无法利用公网iPv6对路由器进行管理，这是最为致命的缺点。&lt;&#x2F;li&gt;
&lt;li&gt;Merlin闭源，在进行DDNS设置中，收到闭源影响，导致支持较少。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h4 id=&quot;er-ci-zhe-teng&quot;&gt;二次折腾：&lt;&#x2F;h4&gt;
&lt;ol&gt;
&lt;li&gt;Merlin不理想之后，尝试转到开源的OpenWrt，我选择了目前支持最为广泛的K3-lede版本：&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;coolsnowwolf&#x2F;lede&quot;&gt;coolsnowwolf&#x2F;lede&lt;&#x2F;a&gt;，手动编译。&lt;&#x2F;li&gt;
&lt;li&gt;编译步骤见原文。&lt;&#x2F;li&gt;
&lt;li&gt;首次按照编译设置进行编译，编译第一次需要保持外网连接，之后编译不需要花费这么多的时间。第一次编译出来的固件版本，内置不含iPv6支持，需要后续安装iPv6协议以及odhcp，安装出错，依赖错误。&lt;&#x2F;li&gt;
&lt;li&gt;尝试修复依赖错误，删除了OpenWrt底层lib: libubox，导致所有操作都几乎失败。&lt;&#x2F;li&gt;
&lt;li&gt;利用CEF直接刷写LEDE固件，失败。利用CFE刷入&lt;a href=&quot;https:&#x2F;&#x2F;tvvb.net&quot;&gt;tb&lt;&#x2F;a&gt;的固件，成功。&lt;&#x2F;li&gt;
&lt;li&gt;进入tb固件刷入lean的LEDE固件，操作见上文网站。&lt;&#x2F;li&gt;
&lt;li&gt;此时LEDE固件的版本较低，但是iPv6的分配、操作都没有问题。虽然此时iPv6都可用，但是鉴于固件版本较低，我希望可以利用较新的固件。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;二次折腾之后，经历非常多次的编译设置、编译，终于编译了一个版本，可以初步实现iPv6协议以及odhcp的功能实现。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;zui-hou-zhe-teng&quot;&gt;最后折腾：&lt;&#x2F;h4&gt;
&lt;h5 id=&quot;bian-yi-she-zhi&quot;&gt;编译设置：&lt;&#x2F;h5&gt;
&lt;ol&gt;
&lt;li&gt;需要选用大部分的iPv6的功能。&lt;&#x2F;li&gt;
&lt;li&gt;需要安装luci-proto-ipv6、odhcp-onlyipv6&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h5 id=&quot;openwrtshe-zhi&quot;&gt;OpenWrt设置：&lt;&#x2F;h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;WAN接口：连接校园宽带。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;LAN接口：dhcp设置
config dhcp &#x27;lan&#x27;
option interface &#x27;lan&#x27;
option ra &#x27;server&#x27;
option dhcpv6 &#x27;server&#x27;
option ra_default &#x27;1&#x27;
option ra_management &#x27;2&#x27;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;WAN6接口：默认即可&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果编译设置成功以及ISP支持DHCPV6-PD，那么这个时候应该已经初步实现功能。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h5 id=&quot;nan-dian&quot;&gt;难点:&lt;&#x2F;h5&gt;
&lt;ol&gt;
&lt;li&gt;iPv6防火墙设置&lt;&#x2F;li&gt;
&lt;li&gt;局域网iPv6转发（端口放行）&lt;&#x2F;li&gt;
&lt;li&gt;通过iPv6访问管理路由器&lt;&#x2F;li&gt;
&lt;li&gt;通过DDNS实现路由器iPv6地址自动解析到域名&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h5 id=&quot;fang-huo-qiang-she-zhi&quot;&gt;防火墙设置：&lt;&#x2F;h5&gt;
&lt;ol&gt;
&lt;li&gt;需要开放路由器端口，由于已知ISP封禁80、443所以我这里选用开放8081、23333两个端口。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h5 id=&quot;ipv6zhuan-fa&quot;&gt;iPv6转发：&lt;&#x2F;h5&gt;
&lt;ol&gt;
&lt;li&gt;wan -&amp;gt; lan&lt;&#x2F;li&gt;
&lt;li&gt;端口自选（23333、8081　etc.）&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h5 id=&quot;ddnsjie-xi&quot;&gt;DDNS解析：&lt;&#x2F;h5&gt;
&lt;ol&gt;
&lt;li&gt;域名来自namesilo&lt;&#x2F;li&gt;
&lt;li&gt;早先域名解析由DnsPod完成，虽然速度快，但是ddns的支持比较差。&lt;&#x2F;li&gt;
&lt;li&gt;转由he.net进行解析&lt;&#x2F;li&gt;
&lt;li&gt;OpenWrt直接支持he.net&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Stacks  and Queues</title>
        <published>2019-04-15T11:01:11+00:00</published>
        <updated>2019-04-15T11:01:11+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/stacksandqueues/"/>
        <id>https://ghost.livexia.xyz/stacksandqueues/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/stacksandqueues/">&lt;p&gt;Stacks（栈）：后进先出LIFO&lt;&#x2F;p&gt;
&lt;p&gt;主要方法：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;push()&lt;&#x2F;li&gt;
&lt;li&gt;pop()：返回弹出的值&lt;&#x2F;li&gt;
&lt;li&gt;isempty()&lt;&#x2F;li&gt;
&lt;li&gt;size[optional]()&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;linked-list实现(Java)：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;inner class
&lt;&#x2F;span&gt;&lt;span&gt;private class NODE
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    String item;
&lt;&#x2F;span&gt;&lt;span&gt;    Node next;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Resizing array实现(Java):&lt;&#x2F;p&gt;
&lt;p&gt;当push超过数组长度时，翻倍数组（新建数组，复制原数据）。&lt;&#x2F;p&gt;
&lt;p&gt;Efficient solution.&lt;&#x2F;p&gt;
&lt;p&gt;・push(): double size of array s[] when array is full.&lt;&#x2F;p&gt;
&lt;p&gt;・pop(): halve size of array s[] when array is one-quarter full.&lt;&#x2F;p&gt;
&lt;p&gt;Queues（队列）：先进先出FIFO，排队&lt;&#x2F;p&gt;
&lt;p&gt;linked-list：&lt;&#x2F;p&gt;
&lt;p&gt;Generics（泛型）：&lt;&#x2F;p&gt;
&lt;p&gt;Primitive（基本类型）：&lt;&#x2F;p&gt;
&lt;p&gt;Iterator（迭代器）：&lt;&#x2F;p&gt;
&lt;p&gt;Bags（包）：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;public class Bag&amp;lt;Item&amp;gt; implements Iterable&amp;lt;Item&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    Bag() create an empty bag
&lt;&#x2F;span&gt;&lt;span&gt;    void add(Item x) insert a new item onto bag
&lt;&#x2F;span&gt;&lt;span&gt;    int size() number of items in bag
&lt;&#x2F;span&gt;&lt;span&gt;    Iterable&amp;lt;Item&amp;gt; iterator() iterator for all items in bag
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Analysis Of Algorithms</title>
        <published>2019-04-05T15:12:59+00:00</published>
        <updated>2019-04-05T15:12:59+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/analysisofalgorithms/"/>
        <id>https://ghost.livexia.xyz/analysisofalgorithms/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/analysisofalgorithms/">&lt;h3 id=&quot;analysis-of-algorithms-suan-fa-fen-xi&quot;&gt;Analysis Of Algorithms：算法分析&lt;&#x2F;h3&gt;
&lt;p&gt;科学的方法：Observe、Hypothesize 、Predict 、Verify、Validate&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;观察自然界的一些特征。&lt;&#x2F;li&gt;
&lt;li&gt;假设一个与观察结果一致的模型。&lt;&#x2F;li&gt;
&lt;li&gt;使用假设预测事件。&lt;&#x2F;li&gt;
&lt;li&gt;通过进一步观察来验证预测。&lt;&#x2F;li&gt;
&lt;li&gt;重复验证，直到假设和观察结果一致。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;observation&quot;&gt;Observation&lt;&#x2F;h3&gt;
&lt;p&gt;3-Sum problem：给定一系列的输入整数，输出其中三个相加为0的整数个数。&lt;&#x2F;p&gt;
&lt;p&gt;Java存在一个stopwatch，可以给出程序运行时间，stopwatch.elapsedTime()，给出stopwatch声明到当前所花费的时间。&lt;&#x2F;p&gt;
&lt;p&gt;双对数坐标：lg(T(N))=b*lg(N)+c&lt;&#x2F;p&gt;
&lt;p&gt;回归：a*N^b, a=2^c, b=lg ratio&lt;&#x2F;p&gt;
&lt;p&gt;影响b大小的因素：算法、输入数据&lt;&#x2F;p&gt;
&lt;p&gt;影响a大小的因素：计算机之间的差距、运行环境&lt;&#x2F;p&gt;
&lt;h3 id=&quot;mathematical-models&quot;&gt;Mathematical Models&lt;&#x2F;h3&gt;
&lt;p&gt;Don Knuth提出。&lt;&#x2F;p&gt;
&lt;p&gt;读取数组类似于二项式系数。&lt;&#x2F;p&gt;
&lt;p&gt;部分离散数学基础。&lt;&#x2F;p&gt;
&lt;p&gt;相近的数学模型非常有用。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;order-of-growth-classification&quot;&gt;Order Of Growth Classification&lt;&#x2F;h3&gt;
&lt;p&gt;Functions：1，logN，N，Nlog N，N^2，N^3，2^N&lt;&#x2F;p&gt;
&lt;p&gt;二分搜索：复杂度的证明&lt;&#x2F;p&gt;
&lt;h3 id=&quot;theory-of-algotithms&quot;&gt;Theory of Algotithms&lt;&#x2F;h3&gt;
&lt;p&gt;Best case:&lt;&#x2F;p&gt;
&lt;p&gt;Worst case:&lt;&#x2F;p&gt;
&lt;p&gt;Average case:Random input，预测结果。&lt;&#x2F;p&gt;
&lt;p&gt;根据最差输入，设计算法进行规避。&lt;&#x2F;p&gt;
&lt;p&gt;构造随机化&lt;&#x2F;p&gt;
&lt;h3 id=&quot;memory&quot;&gt;Memory&lt;&#x2F;h3&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Percolation</title>
        <published>2019-04-05T15:12:17+00:00</published>
        <updated>2019-04-05T15:12:17+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/percolation/"/>
        <id>https://ghost.livexia.xyz/percolation/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/percolation/">&lt;p&gt;Java基础：&lt;&#x2F;p&gt;
&lt;p&gt;关键点：&lt;&#x2F;p&gt;
&lt;p&gt;时间复杂度：允许Backwash时间复杂度下降，所有Memory&#x2F;Timing Test passed，但是会有部分测试安利错误。出现原因，当系统已经渗透成功，如果最底层存在open sites，所有open sites都会被标记为full，无论其是否与top连接。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;yao-qiu-fen-xi-xian-zhi&quot;&gt;要求分析&#x2F;限制：&lt;&#x2F;h4&gt;
&lt;p&gt;主要包含两个实验（Java Class），第一个是渗透模型具体API限制如下。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;public class Percolation {
&lt;&#x2F;span&gt;&lt;span&gt;   public Percolation(int n)                &#x2F;&#x2F; create n-by-n grid, with all sites blocked
&lt;&#x2F;span&gt;&lt;span&gt;   public    void open(int row, int col)    &#x2F;&#x2F; open site (row, col) if it is not open already
&lt;&#x2F;span&gt;&lt;span&gt;   public boolean isOpen(int row, int col)  &#x2F;&#x2F; is site (row, col) open?
&lt;&#x2F;span&gt;&lt;span&gt;   public boolean isFull(int row, int col)  &#x2F;&#x2F; is site (row, col) full?
&lt;&#x2F;span&gt;&lt;span&gt;   public     int numberOfOpenSites()       &#x2F;&#x2F; number of open sites
&lt;&#x2F;span&gt;&lt;span&gt;   public boolean percolates()              &#x2F;&#x2F; does the system percolate?
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;   public static void main(String[] args)   &#x2F;&#x2F; test client (optional)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;第二个是蒙特卡洛模拟（Monte Carlo simulation），模拟是为了探究当一个，具体API限制如下。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;public class PercolationStats {
&lt;&#x2F;span&gt;&lt;span&gt;   public PercolationStats(int n, int trials)    &#x2F;&#x2F; perform trials independent experiments on an n-by-n grid
&lt;&#x2F;span&gt;&lt;span&gt;   public double mean()                          &#x2F;&#x2F; sample mean of percolation threshold
&lt;&#x2F;span&gt;&lt;span&gt;   public double stddev()                        &#x2F;&#x2F; sample standard deviation of percolation threshold
&lt;&#x2F;span&gt;&lt;span&gt;   public double confidenceLo()                  &#x2F;&#x2F; low  endpoint of 95% confidence interval
&lt;&#x2F;span&gt;&lt;span&gt;   public double confidenceHi()                  &#x2F;&#x2F; high endpoint of 95% confidence interval
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;   public static void main(String[] args)        &#x2F;&#x2F; test client (described below)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;方法II：95&#x2F;100，错误3&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;yu-dao-wen-ti&quot;&gt;遇到问题：&lt;&#x2F;h4&gt;
&lt;p&gt;Backwash解决方法：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;利用两个WQUF（路径压缩的带权并查集），第一个含有一个虚拟Top、Bottom，该wquf可以快速判断是否渗透。第二个wquf只含虚拟Top，不会出现Backwash，在判断isFull的时候，利用第二个wquf来判断。缺点：内存&#x2F;时间复杂度翻倍。&lt;&#x2F;li&gt;
&lt;li&gt;直接取消虚拟Bottom，判断是否渗透时，循环扫描Bottom line的每一个site是否连接到Top。缺点时间复杂度大大增加，请求wquf中find方法的数量大大增加。&lt;&#x2F;li&gt;
&lt;li&gt;修改WQUF，在每一个site中存储一个“状态码”，状态码代表其是否连接到虚拟Top或者虚拟Bottom，每次union都更新该状态，当且仅当某一同时含有Top&#x2F;Bottom时渗透发生。参见@sigmainfy的方法。参见示例代码II。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Java示例代码I：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;import edu.princeton.cs.algs4.In;
&lt;&#x2F;span&gt;&lt;span&gt;import edu.princeton.cs.algs4.StdOut;
&lt;&#x2F;span&gt;&lt;span&gt;import edu.princeton.cs.algs4.WeightedQuickUnionUF;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;&#x2F; way2.Use both virtual bottom and top, backwash exists
&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;&#x2F; score 95&#x2F;100
&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;&#x2F;Correctness:  30&#x2F;33 tests passed
&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;&#x2F;Memory:       8&#x2F;8 tests passed
&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;&#x2F;Timing:       20&#x2F;20 tests passed
&lt;&#x2F;span&gt;&lt;span&gt;public class Percolation {
&lt;&#x2F;span&gt;&lt;span&gt;    private boolean[][] g;
&lt;&#x2F;span&gt;&lt;span&gt;    private int count;
&lt;&#x2F;span&gt;&lt;span&gt;    private int opensites;
&lt;&#x2F;span&gt;&lt;span&gt;    private WeightedQuickUnionUF weightedQuickUnionUF;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    public Percolation(int n) {
&lt;&#x2F;span&gt;&lt;span&gt;        if (n &amp;lt;= 0) {
&lt;&#x2F;span&gt;&lt;span&gt;            throw new IllegalArgumentException(&amp;quot;outside its prescribed range&amp;quot;);
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        count = n;
&lt;&#x2F;span&gt;&lt;span&gt;        g = new boolean[n + 1][n + 1];
&lt;&#x2F;span&gt;&lt;span&gt;        weightedQuickUnionUF = new WeightedQuickUnionUF(n * n + 2);
&lt;&#x2F;span&gt;&lt;span&gt;        for (int i = 1; i &amp;lt; n + 1; i++) {
&lt;&#x2F;span&gt;&lt;span&gt;            for (int j = 1; j &amp;lt; n + 1; j++) {
&lt;&#x2F;span&gt;&lt;span&gt;                g[i][j] = false;
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    public void open(int row, int col) {
&lt;&#x2F;span&gt;&lt;span&gt;        if (!isOpen(row, col)) {
&lt;&#x2F;span&gt;&lt;span&gt;            g[row][col] = true;
&lt;&#x2F;span&gt;&lt;span&gt;            if (row == 1)
&lt;&#x2F;span&gt;&lt;span&gt;                weightedQuickUnionUF.union(0, (row - 1) * count + col);
&lt;&#x2F;span&gt;&lt;span&gt;            if (row == count)
&lt;&#x2F;span&gt;&lt;span&gt;                weightedQuickUnionUF.union(count*count+1, (row - 1) * count + col);
&lt;&#x2F;span&gt;&lt;span&gt;            if (row&amp;gt;1 &amp;amp;&amp;amp; isOpen(row - 1, col))
&lt;&#x2F;span&gt;&lt;span&gt;                weightedQuickUnionUF.union((row - 1) * count + col, (row - 2) * count + col);
&lt;&#x2F;span&gt;&lt;span&gt;            if (row&amp;lt;count &amp;amp;&amp;amp; isOpen(row + 1, col))
&lt;&#x2F;span&gt;&lt;span&gt;                weightedQuickUnionUF.union((row - 1) * count + col, row * count + col);
&lt;&#x2F;span&gt;&lt;span&gt;            if (col&amp;gt;1 &amp;amp;&amp;amp; isOpen(row, col - 1))
&lt;&#x2F;span&gt;&lt;span&gt;                weightedQuickUnionUF.union((row - 1) * count + col, (row - 1) * count + col - 1);
&lt;&#x2F;span&gt;&lt;span&gt;            if (col &amp;lt; count &amp;amp;&amp;amp; isOpen(row, col + 1))
&lt;&#x2F;span&gt;&lt;span&gt;                weightedQuickUnionUF.union((row - 1) * count + col, (row - 1) * count + col + 1);
&lt;&#x2F;span&gt;&lt;span&gt;            opensites += 1;
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    public boolean isOpen(int row, int col) {
&lt;&#x2F;span&gt;&lt;span&gt;        if (row &amp;gt;= 1 &amp;amp;&amp;amp; row &amp;lt;= count &amp;amp;&amp;amp; col &amp;gt;= 1 &amp;amp;&amp;amp; col &amp;lt;= count)
&lt;&#x2F;span&gt;&lt;span&gt;            return g[row][col];
&lt;&#x2F;span&gt;&lt;span&gt;        else {
&lt;&#x2F;span&gt;&lt;span&gt;            throw new IllegalArgumentException(row + &amp;quot;,&amp;quot; + col + &amp;quot; outside its prescribed range&amp;quot;);
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    public boolean isFull(int row, int col) {
&lt;&#x2F;span&gt;&lt;span&gt;        if (row &amp;gt;= 1 &amp;amp;&amp;amp; row &amp;lt;= count &amp;amp;&amp;amp; col &amp;gt;= 1 &amp;amp;&amp;amp; col &amp;lt;= count)
&lt;&#x2F;span&gt;&lt;span&gt;            return weightedQuickUnionUF.connected(0, (row - 1) * count + col);
&lt;&#x2F;span&gt;&lt;span&gt;        else {
&lt;&#x2F;span&gt;&lt;span&gt;            throw new IllegalArgumentException(row + &amp;quot;,&amp;quot; + col + &amp;quot; outside its prescribed range&amp;quot;);
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    public int numberOfOpenSites() {
&lt;&#x2F;span&gt;&lt;span&gt;        return opensites;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    public boolean percolates() {
&lt;&#x2F;span&gt;&lt;span&gt;        return weightedQuickUnionUF.connected(0, count*count+1);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    public static void main(String[] args) {
&lt;&#x2F;span&gt;&lt;span&gt;        In in = new In(args[0]);      &#x2F;&#x2F; input file
&lt;&#x2F;span&gt;&lt;span&gt;        int n = in.readInt();
&lt;&#x2F;span&gt;&lt;span&gt;        Percolation percolation = new Percolation(n);
&lt;&#x2F;span&gt;&lt;span&gt;        while (!in.isEmpty()) {
&lt;&#x2F;span&gt;&lt;span&gt;            int row = in.readInt();
&lt;&#x2F;span&gt;&lt;span&gt;            int col = in.readInt();
&lt;&#x2F;span&gt;&lt;span&gt;            percolation.open(row, col);
&lt;&#x2F;span&gt;&lt;span&gt;            StdOut.println(&amp;quot;isPercolates: &amp;quot; + percolation.percolates());
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Algorithms——Union-Find</title>
        <published>2019-04-03T12:18:39+00:00</published>
        <updated>2019-04-03T12:18:39+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/algroithms-union-find/"/>
        <id>https://ghost.livexia.xyz/algroithms-union-find/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/algroithms-union-find/">&lt;p&gt;并查集（Union-Find）问题：研究动态连接性&lt;&#x2F;p&gt;
&lt;p&gt;基础算法：快速查找（Quick Find）、快速连接（Quick Union）&lt;&#x2F;p&gt;
&lt;p&gt;提升算法：带权的并查集（Weighted Union Find）、路径压缩后带权的并查集（Weighted Union Find with Path Compression）&lt;&#x2F;p&gt;
&lt;p&gt;快速查找（Quick Find）：维护数组id[i]，i代表各个连接单位，不同索引id[i]相同时代表这一系列i属于同一连通风量。若id[1]=id[2]=id[4]，则1、2、4三个单位处于同一连通分量，即1、2、4互相连接。&lt;&#x2F;p&gt;
&lt;p&gt;快速连接（Quick Union）：利用数组id[i]，维护森林，所有相连的单位处于同一棵树内，连接（Union）使得两颗不同的树合并为一棵树。id[i]的值为i的父亲，如果id[i]=i则i为i所处的树的根（root）。每当一棵树并入另一棵树，将并入树的根改为待并入树的根。&lt;&#x2F;p&gt;
&lt;p&gt;带权的并查集（Weighted Union Find）：改善Quick-Union，额外维护数组sz[i]，存储根为i的树的所有结点量&#x2F;权。当两棵树合并时，比较两棵树的权，权较小的树并入权较大的树。改善的目的是使得在树中较少出现“一枝独秀”。树的深度不超过lgN，每当叶子的深度增加时，该树最少并入相同大小的树，此时深度+1，若共有N个节点，则最多可以进行lgN次合并，使得所有节点处于同一颗树，该树深度最大，一次合并深度增加1。&lt;&#x2F;p&gt;
&lt;p&gt;路径压缩后带权的并查集（Weighted Union Find with Path Compression）：改善Weighted Union Find，相比带权并查集并不维护额外的数组。当每一次进行并、查操作时，尽量使得当前节点直接指向根（root），示例代码中仅仅使查询节点指向其爷爷。&lt;&#x2F;p&gt;
&lt;p&gt;算法复杂度：
&lt;img src=&quot;https:&#x2F;&#x2F;ghost.livexia.xyz&#x2F;algroithms-union-find&#x2F;__GHOST_URL__&#x2F;content&#x2F;images&#x2F;2019&#x2F;04&#x2F;M-union-find-operations-on-a-set-of-N-objects.png&quot; alt=&quot;&quot; &#x2F;&gt;
Python示例代码：&lt;&#x2F;p&gt;
&lt;p&gt;Quick-Find：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;class QF:
&lt;&#x2F;span&gt;&lt;span&gt;    id = []
&lt;&#x2F;span&gt;&lt;span&gt;    count = 0
&lt;&#x2F;span&gt;&lt;span&gt;    def __init__(self, n):
&lt;&#x2F;span&gt;&lt;span&gt;        self.id = list(range(n))
&lt;&#x2F;span&gt;&lt;span&gt;        self.count = n
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    def union(self, p, q):
&lt;&#x2F;span&gt;&lt;span&gt;        if self.connected(p,q):
&lt;&#x2F;span&gt;&lt;span&gt;            pass
&lt;&#x2F;span&gt;&lt;span&gt;        else:
&lt;&#x2F;span&gt;&lt;span&gt;            old_p = self.id[p]
&lt;&#x2F;span&gt;&lt;span&gt;            for i in range(self.count):
&lt;&#x2F;span&gt;&lt;span&gt;                if self.id[i] == old_p:
&lt;&#x2F;span&gt;&lt;span&gt;                    self.id[i] = self.id[q]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    def connected(self, p, q):
&lt;&#x2F;span&gt;&lt;span&gt;        if self.id[p] == self.id[q]:
&lt;&#x2F;span&gt;&lt;span&gt;            return 1
&lt;&#x2F;span&gt;&lt;span&gt;        return 0
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Quick-Union：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;class QU:
&lt;&#x2F;span&gt;&lt;span&gt;    id = []
&lt;&#x2F;span&gt;&lt;span&gt;    count = 0
&lt;&#x2F;span&gt;&lt;span&gt;    def __init__(self, n):
&lt;&#x2F;span&gt;&lt;span&gt;        self.id = list(range(n))
&lt;&#x2F;span&gt;&lt;span&gt;        self.count = n
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    def root(self, p):
&lt;&#x2F;span&gt;&lt;span&gt;        while p != self.id[p]:
&lt;&#x2F;span&gt;&lt;span&gt;            p = self.id[p]
&lt;&#x2F;span&gt;&lt;span&gt;        return p
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    def union(self, p, q):
&lt;&#x2F;span&gt;&lt;span&gt;        if self.connected(p,q):
&lt;&#x2F;span&gt;&lt;span&gt;            pass
&lt;&#x2F;span&gt;&lt;span&gt;        else:
&lt;&#x2F;span&gt;&lt;span&gt;            self.id[self.root(p)] = self.root(q)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    def connected(self, p, q):
&lt;&#x2F;span&gt;&lt;span&gt;        if self.root(p) == self.root(q):
&lt;&#x2F;span&gt;&lt;span&gt;            return 1
&lt;&#x2F;span&gt;&lt;span&gt;        return 0
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Weighted Union Find：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;class WQU:
&lt;&#x2F;span&gt;&lt;span&gt;    id = []
&lt;&#x2F;span&gt;&lt;span&gt;    sz = []
&lt;&#x2F;span&gt;&lt;span&gt;    count = 0
&lt;&#x2F;span&gt;&lt;span&gt;    def __init__(self, n):
&lt;&#x2F;span&gt;&lt;span&gt;        self.id = list(range(n))
&lt;&#x2F;span&gt;&lt;span&gt;        self.sz = [1] * n
&lt;&#x2F;span&gt;&lt;span&gt;        self.count = n
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    def root(self, p):
&lt;&#x2F;span&gt;&lt;span&gt;        while p != self.id[p]:
&lt;&#x2F;span&gt;&lt;span&gt;            p = self.id[p]
&lt;&#x2F;span&gt;&lt;span&gt;        return p
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    def union(self, p, q):
&lt;&#x2F;span&gt;&lt;span&gt;        if self.connected(p,q):
&lt;&#x2F;span&gt;&lt;span&gt;            pass
&lt;&#x2F;span&gt;&lt;span&gt;        else:
&lt;&#x2F;span&gt;&lt;span&gt;            rootp = self.root(p)
&lt;&#x2F;span&gt;&lt;span&gt;            rootq = self.root(q)
&lt;&#x2F;span&gt;&lt;span&gt;            if self.sz[rootp] &amp;gt;= self.sz[rootq]:
&lt;&#x2F;span&gt;&lt;span&gt;                self.id[rootq] = rootp
&lt;&#x2F;span&gt;&lt;span&gt;                self.sz[rootp] += self.sz[rootq]
&lt;&#x2F;span&gt;&lt;span&gt;            else:
&lt;&#x2F;span&gt;&lt;span&gt;                self.id[rootp] = rootq
&lt;&#x2F;span&gt;&lt;span&gt;                self.sz[rootq] += self.sz[rootp]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    def connected(self, p, q):
&lt;&#x2F;span&gt;&lt;span&gt;        if self.root(p) == self.root(q):
&lt;&#x2F;span&gt;&lt;span&gt;            return 1
&lt;&#x2F;span&gt;&lt;span&gt;        return 0
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Weighted Union Find With Compression：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;class WQUPC:
&lt;&#x2F;span&gt;&lt;span&gt;    id = []
&lt;&#x2F;span&gt;&lt;span&gt;    sz = []
&lt;&#x2F;span&gt;&lt;span&gt;    count = 0
&lt;&#x2F;span&gt;&lt;span&gt;    def __init__(self, n):
&lt;&#x2F;span&gt;&lt;span&gt;        self.id = list(range(n))
&lt;&#x2F;span&gt;&lt;span&gt;        self.sz = [1] * n
&lt;&#x2F;span&gt;&lt;span&gt;        self.count = n
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    def root(self, p):
&lt;&#x2F;span&gt;&lt;span&gt;        while p != self.id[p]:
&lt;&#x2F;span&gt;&lt;span&gt;            self.id[p] = self.id[self.id[p]]
&lt;&#x2F;span&gt;&lt;span&gt;            p = self.id[p]
&lt;&#x2F;span&gt;&lt;span&gt;        return p
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    def union(self, p, q):
&lt;&#x2F;span&gt;&lt;span&gt;        if self.connected(p,q):
&lt;&#x2F;span&gt;&lt;span&gt;            pass
&lt;&#x2F;span&gt;&lt;span&gt;        else:
&lt;&#x2F;span&gt;&lt;span&gt;            rootp = self.root(p)
&lt;&#x2F;span&gt;&lt;span&gt;            rootq = self.root(q)
&lt;&#x2F;span&gt;&lt;span&gt;            if self.sz[rootp] &amp;gt;= self.sz[rootq]:
&lt;&#x2F;span&gt;&lt;span&gt;                self.id[rootq] = rootp
&lt;&#x2F;span&gt;&lt;span&gt;                self.sz[rootp] += self.sz[rootq]
&lt;&#x2F;span&gt;&lt;span&gt;            else:
&lt;&#x2F;span&gt;&lt;span&gt;                self.id[rootp] = rootq
&lt;&#x2F;span&gt;&lt;span&gt;                self.sz[rootq] += self.sz[rootp]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    def connected(self, p, q):
&lt;&#x2F;span&gt;&lt;span&gt;        if self.root(p) == self.root(q):
&lt;&#x2F;span&gt;&lt;span&gt;            return 1
&lt;&#x2F;span&gt;&lt;span&gt;        return 0
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;C语言示例代码：&lt;&#x2F;p&gt;
&lt;h4 id=&quot;todo&quot;&gt;TODO&lt;&#x2F;h4&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>After Life 观后感</title>
        <published>2019-03-22T07:03:21+00:00</published>
        <updated>2019-03-22T07:03:21+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/after-life-netflix-note/"/>
        <id>https://ghost.livexia.xyz/after-life-netflix-note/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/after-life-netflix-note/">&lt;p&gt;一部带有喜剧气氛的温情剧。&lt;&#x2F;p&gt;
&lt;p&gt;失去妻子的主人公，仿佛世界崩塌，生活失去希望。&lt;&#x2F;p&gt;
&lt;p&gt;轻易的死去让主人公感觉对不起深爱的妻子，每次自杀的边缘都有老狗拯救他。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>C++ Primer笔记-第一部分</title>
        <published>2019-03-04T06:57:50+00:00</published>
        <updated>2019-03-04T06:57:50+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/cpp-primer-part1/"/>
        <id>https://ghost.livexia.xyz/cpp-primer-part1/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/cpp-primer-part1/">&lt;h3 id=&quot;1-1&quot;&gt;1.1&lt;&#x2F;h3&gt;
&lt;p&gt;main 函数的返回类型必须为int。&lt;&#x2F;p&gt;
&lt;p&gt;&amp;lt;&amp;lt; 运算符左侧ostream对象，右侧为打印值，返回左侧对象&lt;&#x2F;p&gt;
&lt;p&gt;&amp;gt;&amp;gt; 运算符左侧istream对象，右侧为运算对象（输入对象），返回左侧对象。从istream中读入数据，存入右侧对象。&lt;&#x2F;p&gt;
&lt;p&gt;endl 结束行，同时刷新流（确保缓冲区输出到设备）&lt;&#x2F;p&gt;
&lt;p&gt;:: 作用域运算符，指定命名空间（std）中的名字（cout），std::cout&lt;&#x2F;p&gt;
&lt;p&gt;cout 标准输出&lt;&#x2F;p&gt;
&lt;p&gt;cin 标准输入&lt;&#x2F;p&gt;
&lt;p&gt;clog log输出（Linux中的2）&lt;&#x2F;p&gt;
&lt;p&gt;cerr 错误输出（Linux中的2）&lt;&#x2F;p&gt;
&lt;p&gt;注释&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;单行注释：&#x2F;&#x2F;&lt;&#x2F;li&gt;
&lt;li&gt;多行注释：注释界定符（&#x2F;&lt;em&gt;和&lt;&#x2F;em&gt;&#x2F;），中间行往往在开头包含*表明属于多行注释的一部分。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;C++ 生成a-b间的随机数：rand() % (b - a + 1) + a&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;添加srand(time(NULL)); 生成更加随机的序列&lt;a href=&quot;https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;9459035&#x2F;why-does-rand-yield-the-same-sequence-of-numbers-on-every-run&quot;&gt;stackOverflow&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;1000-9999 number = rand() % 9000 + 1000;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Linux 管道重定向说明：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;$ program &lt;infile &gt;outfile&lt;&#x2F;p&gt;
&lt;p&gt;&#x2F;dev&#x2F;null 表示空设备文件&lt;&#x2F;p&gt;
&lt;p&gt;0 表示stdin标准输入&lt;&#x2F;p&gt;
&lt;p&gt;1 表示stdout标准输出&lt;&#x2F;p&gt;
&lt;p&gt;2 表示stderr标准错误&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;页数 52&#x2F;864&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>《月亮与六便士》读后感</title>
        <published>2018-10-27T06:56:24+00:00</published>
        <updated>2018-10-27T06:56:24+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/the-moon-and-sixpence-note/"/>
        <id>https://ghost.livexia.xyz/the-moon-and-sixpence-note/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/the-moon-and-sixpence-note/">&lt;blockquote&gt;
&lt;p&gt;听过《月亮与六便士》这本书的大名很多次了，这本书电子版也下了、买了好几个版本，终于在几个月前我买了本书的纸质版，可是一直没有时间沉下心来好好阅读，趁着最近刚刚结束实习和逐渐对电子设备没有什么兴趣，终于是慢慢的开始读和读完了。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;  鉴于我很久不看纸质书（传统文学），我的耐心逐渐被网络小说消磨殆尽，所以看这本书的时候经常没有耐心，真正使我感兴趣的部分从第八章开始，这章也是书中一处冲突的开始，书中前几章的部分说实在的并没有真正能让我深入阅读，但是我从第八章开始渐渐的感受到了作者的写作魅力。&lt;&#x2F;p&gt;
&lt;p&gt;  鉴于只是粗看，快速浏览了一遍，其中很多细节我可能都没有注意到，但是这本书讲述了关于生活的意义的故事，满地的六便士和抬头看见的月亮，都寓意了不同的生活寓意。选择六便士还是月亮，没有什么真理，这仅仅只是一个人自己如何看待生活，是完完全全自己的事情。&lt;&#x2F;p&gt;
&lt;p&gt;  我虽然活得不久，年纪不大，但是也对生活有自己的感受，小学的追求主流，中学时代逐渐发展的自我意识，大学时代渐渐的特立独行。很多时候自己也害怕自己迈出的步伐会不会是对自己最后沉重的致命一击。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;todo&quot;&gt;TODO&lt;&#x2F;h3&gt;
&lt;h2 id=&quot;zhai-xuan&quot;&gt;摘选&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;todo-1&quot;&gt;TODO&lt;&#x2F;h3&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>今日头条爬取分析</title>
        <published>2018-10-15T06:12:00+00:00</published>
        <updated>2018-10-15T06:12:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/jin-ri-tou-tiao-api-analysis/"/>
        <id>https://ghost.livexia.xyz/jin-ri-tou-tiao-api-analysis/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/jin-ri-tou-tiao-api-analysis/">&lt;h3 id=&quot;ke-cheng-xu-yao-dui-jin-ri-tou-tiao-de-nei-rong-jie-xi-jin-xing-yi-ge-fen-xi&quot;&gt;课程需要对今日头条的内容解析进行一个分析&lt;&#x2F;h3&gt;
&lt;p&gt;存在api：&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;iMeiji&#x2F;Toutiao&#x2F;wiki&#x2F;%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1Api%E5%88%86%E6%9E%90&quot;&gt;今日头条Api分析&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;正文：&lt;&#x2F;p&gt;
&lt;p&gt;评论：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;PC端可以获得20条评论&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;其余需要手机端api&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;分析：&lt;&#x2F;p&gt;
&lt;p&gt;评论存在Api（PC\手机）&lt;&#x2F;p&gt;
&lt;h1 id=&quot;update&quot;&gt;Update&lt;&#x2F;h1&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;url=&amp;quot;https:&#x2F;&#x2F;www.toutiao.com&#x2F;api&#x2F;pc&#x2F;feed&#x2F;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;params={
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;category&amp;quot;:&amp;quot;news_hot&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;utm_source&amp;quot;:&amp;quot;toutiao&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;widen&amp;quot;:&amp;quot;1&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;max_behot_time&amp;quot;:&amp;quot;1539572090&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;max_behot_time_tmp&amp;quot;:&amp;quot;1539572090&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;tadrequire&amp;quot;:&amp;quot;true&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;as&amp;quot;:&amp;quot;A1E54BFCD480436&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;cp&amp;quot;:&amp;quot;5BC4705493D6EE1&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;_signature&amp;quot;:&amp;quot;PzN5IAAAZP2VdNF1CwwtFj8zeT&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;headers={
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;user-agent&amp;quot;:&amp;quot;Mozilla&#x2F;5.0(Macintosh;IntelMacOSX10_14_0)AppleWebKit&#x2F;537.36(KHTML,likeGecko)&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;Chrome&#x2F;69.0.3497.100Safari&#x2F;537.36&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;重点关键字：&lt;&#x2F;p&gt;
&lt;p&gt;category：类别&lt;&#x2F;p&gt;
&lt;p&gt;max_behot_time：时间（难以获取，由服务器给出算法未知）&lt;&#x2F;p&gt;
&lt;p&gt;_signature：关键签名，代表唯一认证&lt;&#x2F;p&gt;
&lt;p&gt;结果：无法利用该入口获取所有新闻，尝试更换api&lt;&#x2F;p&gt;
&lt;p&gt;相比于正文，评论的api更好获取，尝试利用搜索关键字获取新闻列表&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;url=&amp;quot;https:&#x2F;&#x2F;www.toutiao.com&#x2F;search_content&#x2F;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;offset=20
&lt;&#x2F;span&gt;&lt;span&gt;count=20
&lt;&#x2F;span&gt;&lt;span&gt;keyword=&amp;quot;鸿茅药酒&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;params={
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;offset&amp;quot;:offset,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;format&amp;quot;:&amp;quot;json&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;keyword&amp;quot;:keyword,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;count&amp;quot;:count
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;headers={
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;user-agent&amp;quot;:&amp;quot;Mozilla&#x2F;5.0(Macintosh;IntelMacOSX10_14_0)AppleWebKit&#x2F;537.36(KHTML,likeGecko)&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;Chrome&#x2F;69.0.3497.100Safari&#x2F;537.36&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;结果：可行&lt;&#x2F;p&gt;
&lt;p&gt;利用上面的搜索结果api取得新闻id&lt;&#x2F;p&gt;
&lt;p&gt;新闻正文api：&lt;a href=&quot;https:&#x2F;&#x2F;m.toutiao.com&#x2F;i6612377651942261256&#x2F;info&#x2F;&quot;&gt;https:&#x2F;&#x2F;m.toutiao.com&#x2F;i6612377651942261256&#x2F;info&#x2F;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;新闻评论api：&lt;a href=&quot;https:&#x2F;&#x2F;ic.snssdk.com&#x2F;article&#x2F;v2&#x2F;tab_comments&#x2F;?count=50&amp;amp;group_id=6612377651942261256&amp;amp;item_id=6612377651942261256&amp;amp;offset=200&quot;&gt;https:&#x2F;&#x2F;ic.snssdk.com&#x2F;article&#x2F;v2&#x2F;tab_comments&#x2F;?count=50&amp;amp;group_id=6612377651942261256&amp;amp;item_id=6612377651942261256&amp;amp;offset=200&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>博客的目的</title>
        <published>2018-09-16T14:37:40+00:00</published>
        <updated>2018-09-16T14:37:40+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/purpose-of-the-blog/"/>
        <id>https://ghost.livexia.xyz/purpose-of-the-blog/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/purpose-of-the-blog/">&lt;p&gt;&lt;strong&gt;For Fun&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;乐趣第一&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>加布瑞埃拉•泽文 - 岛上书店 - 读书笔记</title>
        <published>2018-09-16T14:25:58+00:00</published>
        <updated>2018-09-16T14:25:58+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/the-storied-life-of-a-j-fikry-note/"/>
        <id>https://ghost.livexia.xyz/the-storied-life-of-a-j-fikry-note/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/the-storied-life-of-a-j-fikry-note/">&lt;h3 id=&quot;jia-bu-rui-ai-la-ze-wen-dao-shang-shu-dian&quot;&gt;加布瑞埃拉•泽文 - 岛上书店&lt;&#x2F;h3&gt;
&lt;p&gt;07&#x2F;22&#x2F;16164&lt;&#x2F;p&gt;
&lt;p&gt;她一回到普罗维登斯，A.J.就在Skype上联系她。“我一直在想，我们应该请利昂•弗里德曼八月份来书店签售，那时夏季来度假的人还在。”&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;22&#x2F;16171&lt;&#x2F;p&gt;
&lt;p&gt;作家跟他们书上的照片从来不是很像，但A.J.见到利昂•弗里德曼时首先想到的，是他跟照片完全不像。照片上的利昂•弗里德曼要瘦一点，鼻子显得长一点，脸上刮得干干净净的。现实中的利昂•弗里德曼长得介于老年海明威和百货商场里的圣诞老人之间：红红的大鼻子，大肚子，茂密的白色大胡子，闪烁的眼神，显得比作家像上的他年轻约十岁。&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;22&#x2F;16187&lt;&#x2F;p&gt;
&lt;p&gt;“您就是他，难道不是吗？”阿米莉娅说，“您就是利昂•弗里德曼。” 利昂诺拉摇摇头。“也不全是。” “此话怎讲？” “很久以前，有个女孩写了部长篇小说，她试图把它卖出去，但是没人想要。&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;22&#x2F;16199&lt;&#x2F;p&gt;
&lt;p&gt;当然！那本书是凯特•肖邦[94]的《觉醒》。她十七岁时，可真是爱那部长篇小说（中篇小说？）啊。 玛雅的妈妈也是这样结束了自己的生命。伊斯梅想知道玛丽安•华莱士是否读过《觉醒》，这个念头可不是第一回出现。这几年她想到过玛丽安•华莱士很多次。&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;22&#x2F;16208&lt;&#x2F;p&gt;
&lt;p&gt;《与父亲的对话》 1972&#x2F;格蕾斯•佩利[101] 垂死的父亲跟女儿争论何为讲故事的“最佳”方式。你会喜欢这一篇的，玛雅，我能肯定。也许我会下楼一趟，立马把它塞进你手里。 ——A.J.F.&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;25&#x2F;16222&lt;&#x2F;p&gt;
&lt;p&gt;获第三名的短篇宣布了，玛雅抓紧了A.J.的手。《逮香蕉鱼的最佳日子》 1948&#x2F;J.D.塞林格 如果什么东西是好的，且普遍被认为如此，这并不是个讨厌它的好理由。（旁注：我花了整整一下午的时间来写这个句子。我的脑子一直在琢磨这个短语：“普遍被认为。”） 你参加县里短篇小说竞赛的《海滩一日》让我有点想到塞林格的短篇。我提到这个，是因为我觉得你应该是第一名。获第一名的那篇——我想题目是《奶奶的手》——跟你那篇相比，在形式和叙事上都要简单得多，在感情上更是如此。振作起来，玛雅。作为一个卖书的，我可以向你保证，获奖对销售来说多少有其重要性，但就质量来说很少有关。 ——A.J.F.&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;25&#x2F;16232&lt;&#x2F;p&gt;
&lt;p&gt;玛雅认为A.J.肯定是对她感到失望，但就在他们下车前，他说：“这种事情从来就不公平。人们喜欢他们所喜欢的，那样很棒，也很糟糕。事关个人趣味和某一天特定的一批人。例如，前三名中有两个女性，这样有可能让天平往男性那边倾斜。要么其中一个评委的奶奶上周去世了，这让那个短篇特别能打动他。谁都不晓得。但是我真切地知道：玛雅•帖木儿•费克里的《海滩一日》是由一位作家写出来的。”她觉得他会要拥抱她，但他只是跟她握了握手，就像他跟一位同事打招呼那样——也许是跟来到书店的一位作家。 她脑海里出现了一句话：父亲跟我握手的那天，我知道我是一名作家。&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;25&#x2F;16233&lt;&#x2F;p&gt;
&lt;p&gt;A.J.吻了吻女儿的额头。他为自己培养出这样一个妙不可言的书呆子感到开心。&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;25&#x2F;16234&lt;&#x2F;p&gt;
&lt;p&gt;妮可建议道，想要拥有文学生活，可能有更好、更快乐的方式。我说：“是嘛，例如呢？” 她说：“开书店。” “说详细点。”我说。 “你知道我老家那里没有书店吗？” “真的吗？艾丽丝岛那种地方似乎应该有一家书店。” “我知道，”她说，“一个地方如果没有一家书店，就算不上个地方了。”&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;25&#x2F;16246&lt;&#x2F;p&gt;
&lt;p&gt;他的警察目光锁定了那个儿童背囊，因为它有点跟那里不相协调。他知道自己不应该，但还是把它抽了下来，拉开拉链。里面的拉链袋里有蜡笔和几本涂色书。他拿起那本涂色书，封面上写着“玛雅”。涂色书下面是另外一本书，薄薄的，更像是一本小册子，而不是一本书。兰比亚斯看封面： 帖木儿 及 其他诗歌 一位波士顿人 著 封面有一道道蜡笔画过的痕迹。 兰比亚斯不知道这是怎么回事。&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;25&#x2F;16249&lt;&#x2F;p&gt;
&lt;p&gt;《铁头》 2005&#x2F;艾梅•本德[113] 需要指出的是，新生的一切并非都比老旧的糟糕。 南瓜脑子的父母有个铁脑袋的孩子。我最近对这篇想得比较多，我想原因很明显。 ——A.J.F. 又及：我还发现自己在考虑托拜厄斯•沃尔夫的《脑子中的子弹》。你或许也可以去读下那篇。&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;25&#x2F;16265&lt;&#x2F;p&gt;
&lt;p&gt;“那个男孩在读《无尽的玩笑》。他说他没法在家里读，因为他有五个弟弟妹妹要照看。他没法在学校里看，因为他的朋友会笑话他。所以他逃学，去安安静静地读。那本书需要很专心地阅读。‘听着，hombre[115]，’他说，‘学校对我而言一无是处。一切都在这本书里。’”&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;25&#x2F;16278&lt;&#x2F;p&gt;
&lt;p&gt;《当我们谈论爱情时我们在谈论什么》 1980&#x2F;雷蒙德•卡佛&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;25&#x2F;16282&lt;&#x2F;p&gt;
&lt;p&gt;“那种情况完全不一样。”阿米莉娅坚持说。过了一秒，她叫了起来：“操！”A.J.以为肯定出了什么严重的事，因为阿米莉娅从来不讲粗口。 “怎么了？” “嗯，问题是，我很喜欢你的大脑。” 他笑她，她有点在哭。 “噢，别哭了，我不需要你的同情。” “我不是为你哭，我在为我自己哭。你知道我花了多久才找到你？你知道我经历了多少次糟糕的约会？我不能——”她这时已经泣不成声了——“我不能再上婚恋网站了，真的不能。” “‘大鸟’——永远要往前看。”&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;25&#x2F;16283&lt;&#x2F;p&gt;
&lt;p&gt;“‘大鸟’。这是怎么……？我们走到这一步，你不可以起外号！” “你会遇到某个人的，我就遇到了。” “混蛋。我喜欢你，我习惯了你，你是唯一，你这个混蛋。我不想再去认识新的人。” 他吻了她，接着她把手伸进他的病号服里，捏了一下他的裆部。“我很喜欢跟你做爱，”她说，“如果手术做完后你成了个植物人，我还能不能跟你做爱？”她问。 “当然可以。”A.J.说。 “你不会看低我？” “不会。”他顿了一下，“我们谈着谈着拐到了这儿，我说不上来是不是感觉自在。”他说。&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;25&#x2F;16290&lt;&#x2F;p&gt;
&lt;p&gt;玛雅，”他说，“只有一个词是重要的。”他望着她，看她是否明白他的话。她皱着眉。他看得出自己并没有讲清。该死。他最近讲出来的话大多含糊不清。如果他想让别人听明白，最好把自己限于用一个单词来回答，但是有些事情一个单词解释不清楚。 他会再试试，他永远不会放弃尝试。“玛雅，我们会成为我们所爱的那样。是爱成就了我们。” 玛雅在摇头。“爸爸，对不起，我听不明白。” “我们不是我们所收集的、得到的、所读的东西，只要我们还活着，我们就是爱，我们所爱的事物，我们所爱的人。所有这些，我认为真的会存活下去。”&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;25&#x2F;16293&lt;&#x2F;p&gt;
&lt;p&gt;伊斯梅哭了起来。&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;25&#x2F;16294&lt;&#x2F;p&gt;
&lt;p&gt;伊斯梅哭得更厉害了一点。&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;25&#x2F;16300&lt;&#x2F;p&gt;
&lt;p&gt;兰比亚斯和费克里第一任妻子有一句话变着说了很多遍：“没有书店的小镇算不上个小镇。”可以肯定，他们都读过尼尔•盖曼[120]的《美国众神》。&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;25&#x2F;16304&lt;&#x2F;p&gt;
&lt;p&gt;我们不全是长篇小说，也不全是短篇故事 最后的最后，我们成为一部人生作品集&lt;&#x2F;p&gt;
&lt;p&gt;End&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>无声告白 - 读书笔记</title>
        <published>2018-09-16T14:11:59+00:00</published>
        <updated>2018-09-16T14:11:59+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/everything-i-never-told-you-note/"/>
        <id>https://ghost.livexia.xyz/everything-i-never-told-you-note/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/everything-i-never-told-you-note/">&lt;h2 id=&quot;wu-sheng-gao-bai-wu-qi-shi-zuo-zhe&quot;&gt;无声告白 - 伍绮诗(作者)&lt;&#x2F;h2&gt;
&lt;p&gt;07&#x2F;26&#x2F;16134&lt;&#x2F;p&gt;
&lt;p&gt;晚饭时，玛丽琳告诉孩子们外婆去世了，莉迪亚翘起脑袋问：“你难过吗？”&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;27&#x2F;16172&lt;&#x2F;p&gt;
&lt;p&gt;看来这个办法没有用，她还是弄不明白。&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;27&#x2F;16173&lt;&#x2F;p&gt;
&lt;p&gt;她想也没想就明白，今天晚上自己还要再试一次，还有明晚、明晚的明晚。她睁开眼睛，把毯子推到一边，小心地越过散落在地上的鞋子和衣服，向门口走去。&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;29&#x2F;16249&lt;&#x2F;p&gt;
&lt;p&gt;他把她推下去，然后又把她拉上来。在莉迪亚的一生中，她将会记住一件事。在内斯的一生中，他也会记住另一件事。&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;29&#x2F;16256&lt;&#x2F;p&gt;
&lt;p&gt;（那么，汉娜呢？他们把汉娜的摇篮搬进阁楼上的卧室，那里堆放着他们不再想要的东西，甚至等汉娜长大一点之后，他们也会时常忘记她的存在——比如有天晚上，玛丽琳在餐桌上摆了四个盘子，直到汉娜来到桌边，她才意识到少拿了一个。汉娜也仿佛明白她在家庭这个宇宙中的位置，她从安静的婴儿成长为善于察言观色的小孩：她喜欢躲在角落和柜子里，还有沙发后面、桌布底下，退出家人的视野和脑海，从而确保家中的领土划分不会出现丝毫的变动。）&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;29&#x2F;16257&lt;&#x2F;p&gt;
&lt;p&gt;十五岁半的莉迪亚刚开始放寒假，再过五个月，她就死了。那年十二月，她独自待在屋里打开书包，拽出一张物理试卷，卷子顶端用红笔写着“55”。&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;29&#x2F;16271&lt;&#x2F;p&gt;
&lt;p&gt;有什么东西在莉迪亚的身体里摇摇欲坠，随后便轰然&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;29&#x2F;16272&lt;&#x2F;p&gt;
&lt;p&gt;倒塌——像是听到了倒塌的声音，他们抬起头，望着莉迪亚。&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;29&#x2F;16274&lt;&#x2F;p&gt;
&lt;p&gt;他正准备离开，“内斯。”莉迪亚小声说。听到她颤抖的声音，他知道她哭了。她又要开始了。 “晚安。”他说完，关上了身后的门。&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;29&#x2F;16275&lt;&#x2F;p&gt;
&lt;p&gt;自那天晚上开始，莉迪亚就拒绝和内斯说话，因为她怀疑——这是正确的——内斯也在生她的气；&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;29&#x2F;16317&lt;&#x2F;p&gt;
&lt;p&gt;詹姆斯一把拽过儿子的肩膀，非常用力，连指关节都在响。“不许你这样和我说话，”他说，“不许这样问我。你根本不了解我的生活。”然后，他不假思索地脱口而出，“就像你根本不了解你妹妹的生活一样。”&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;29&#x2F;16323&lt;&#x2F;p&gt;
&lt;p&gt;玛丽琳颤抖着说，她双手紧握，仿佛这样做就能平息内心的震颤，“如果她是个白人女孩，他们就会调查下去。”&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;29&#x2F;16394&lt;&#x2F;p&gt;
&lt;p&gt;这时，书架底下的空间里出现了一本书：厚厚的，红色封皮，书脊上贴着透明胶带。&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;29&#x2F;16398&lt;&#x2F;p&gt;
&lt;p&gt;然而，店员问：“你妹妹就是死的那个女孩？” 内斯觉得喉咙疼，仿佛那里有个伤口。他点点头，盯着柜台后面的架子，那里堆着很多香烟，盛在红白相间的烟盒里。 店员又拿下一瓶威士忌，把它和第一瓶一起放进袋子里递给内斯，同时把内斯放在柜台上的那张十美元纸币也还给了他。&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;29&#x2F;16430&lt;&#x2F;p&gt;
&lt;p&gt;“至少我不用别人来告诉我，我想要什么。”他说，语气里的轻蔑让她退缩，她好几个月都没听到这样的话了，“至少我知道我是谁，我想要什么。”他眯起眼睛，“你呢，李小姐？你想要什么？”&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;29&#x2F;16438&lt;&#x2F;p&gt;
&lt;p&gt;踢水。我抓住你了。踢。&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;29&#x2F;16441&lt;&#x2F;p&gt;
&lt;p&gt;她低头看着湖水，黑暗中仿佛空无一物，只有黑幽幽的颜色，一片巨大的虚无在她脚下铺展开来。没关系的，她告诉自己，然后，她就跨出小船，走进水中。&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;29&#x2F;16441&lt;&#x2F;p&gt;
&lt;p&gt;她能做到，她很肯定。只需要踢水，她就能一路游向码头，攀上那些木板，离开水面。&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;29&#x2F;16447&lt;&#x2F;p&gt;
&lt;p&gt;“爸爸，”汉娜耳语道，“你能再来一次吗？”&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;29&#x2F;16450&lt;&#x2F;p&gt;
&lt;p&gt;“我以为你走了。”她终于说。 詹姆斯的声音嘶哑而尖利：“我以为你走了。”&lt;&#x2F;p&gt;
&lt;p&gt;07&#x2F;29&#x2F;16462&lt;&#x2F;p&gt;
&lt;p&gt;“内斯？”汉娜叫道。她站在码头上向下看，小脸煞白。接着，另一个脑袋出现了——杰克的——一只手向他伸过来。他知道那是杰克的手，当他游过去的时候，他会抓住它。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>申请Let&#x27;s Encrypt SSL证书</title>
        <published>2018-09-16T14:11:04+00:00</published>
        <updated>2018-09-16T14:11:04+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://ghost.livexia.xyz/install-lets-encrypt-ssl-certificate/"/>
        <id>https://ghost.livexia.xyz/install-lets-encrypt-ssl-certificate/</id>
        
        <content type="html" xml:base="https://ghost.livexia.xyz/install-lets-encrypt-ssl-certificate/">&lt;p&gt;需要知识基础：Http、Https、SSL、域名解析、手动设置域名解析服务器、Nginx配置编写&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;安装Nginx&lt;&#x2F;li&gt;
&lt;li&gt;域名解析：Dnspod加速解析&lt;&#x2F;li&gt;
&lt;li&gt;安装Certbot客户端&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;申请证书的三种方式&lt;&#x2F;p&gt;
&lt;p&gt;dns-01：给域名添加一个 DNS TXT 记录。&lt;&#x2F;p&gt;
&lt;p&gt;http-01：在域名对应的 Web 服务器下放置一个 HTTP well-known URL 资源文件。&lt;&#x2F;p&gt;
&lt;p&gt;tls-sni-01：在域名对应的 Web 服务器下放置一个 HTTPS well-known URL 资源文件。&lt;&#x2F;p&gt;
&lt;p&gt;针对单一域名，需要指定网站的根目录：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;$ sudo certbot --authenticator webroot --installer nginx
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这样会自动在在域名对应的 Web 服务器下放置一个 well-known URL 资源文件。&lt;&#x2F;p&gt;
&lt;p&gt;通配符证书只能使用dns-01&lt;&#x2F;p&gt;
&lt;p&gt;通配符证书：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;sudo certbot certonly  -d &amp;quot;*.livexia.xyz&amp;quot; --manual --preferred-challenges dns-01  --server https:&#x2F;&#x2F;acme-v02.api.letsencrypt.org&#x2F;directory
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;需要给域名增加一个txt，dns解析，具体输入命令后会有细节&lt;&#x2F;p&gt;
&lt;p&gt;利用dig查询解析是否成功，解析成功在进行下一步操作&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;$ dig  -t txt _acme-challenge.xxx.com @8.8.8.8 
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;90天会到期，需要进行续期。&lt;&#x2F;p&gt;
&lt;p&gt;自动renewal：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;$ sudo certbot renew --dry-run
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Nginx配置文件的编写：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;server {
&lt;&#x2F;span&gt;&lt;span&gt;    server_name xxx.com;
&lt;&#x2F;span&gt;&lt;span&gt;    listen 443 http2 ssl;
&lt;&#x2F;span&gt;&lt;span&gt;    ssl on;
&lt;&#x2F;span&gt;&lt;span&gt;    ssl_certificate &#x2F;etc&#x2F;cert&#x2F;xxx.com&#x2F;fullchain.pem;
&lt;&#x2F;span&gt;&lt;span&gt;    ssl_certificate_key &#x2F;etc&#x2F;cert&#x2F;xxx.com&#x2F;privkey.pem;
&lt;&#x2F;span&gt;&lt;span&gt;    ssl_trusted_certificate  &#x2F;etc&#x2F;cert&#x2F;xxx.com&#x2F;chain.pem;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    location &#x2F; {
&lt;&#x2F;span&gt;&lt;span&gt;      proxy_pass http:&#x2F;&#x2F;127.0.0.1:6666;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;letsencrypt.org&#x2F;getting-started&#x2F;&quot;&gt;https:&#x2F;&#x2F;letsencrypt.org&#x2F;getting-started&#x2F;&lt;&#x2F;a&gt;
&lt;a href=&quot;https:&#x2F;&#x2F;certbot.eff.org&#x2F;&quot;&gt;https:&#x2F;&#x2F;certbot.eff.org&#x2F;&lt;&#x2F;a&gt;
&lt;a href=&quot;https:&#x2F;&#x2F;www.dnspod.cn&#x2F;console&#x2F;dns&#x2F;livexia.xyz&quot;&gt;https:&#x2F;&#x2F;www.dnspod.cn&#x2F;console&#x2F;dns&#x2F;livexia.xyz&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Update:&lt;&#x2F;strong&gt; 2021-12-20，准备移除Ghost，所以记录之前对证书自动刷新的命令，留有记录。&lt;&#x2F;p&gt;
&lt;p&gt;执行 crontab -e 增加如下内容，保证每周日0点对证书进行刷新&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;0 0 * * 0 sudo &#x2F;home&#x2F;ghost-mgr&#x2F;.acme.sh&#x2F;acme.sh --force --renew --home &#x2F;etc&#x2F;letsencrypt --domain [domain] --webroot &#x2F;var&#x2F;www&#x2F;ghost&#x2F;system&#x2F;nginx-root --reloadcmd &amp;quot;nginx -s reload&amp;quot; --accountemail [email] --debug &amp;amp;&amp;gt; &#x2F;home&#x2F;ghost-mgr&#x2F;renew.log
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote&gt;
&lt;p&gt;crontab参考网址：https:&#x2F;&#x2F;crontab.guru&#x2F;#0_0_&lt;em&gt;_&lt;&#x2F;em&gt;_0s&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
</content>
        
    </entry>
</feed>
